
/*
'***************************************************************************
'Copyright (C) 2010-2012 KBasic Software: www.kbasic.com. All rights reserved.
'Source codes are created by Bernd Noetscher sales@kbasic.com 
'
'You may use this source codes under the terms of the GNU Public License (Version 3) as published 
'by the Free Software Foundation. 
'
'If you are interested in using the source codes for other licenses or 
'commercial development, you must buy commercial licenses from KBasic Software.
'***************************************************************************
*/
 






//
// Windows

// "C:\Users\Bernd\Desktop\MyProject" -CompileItself -QTDIRc:\Qt\4.8.0 -VM
// "C:\Users\Bernd\Desktop\objb_q7basic\Q7Basic" -CompileItself -QTDIRc:\Qt\4.8.0
// "C:\Users\Bernd\Desktop\q7basic_release\Q7Basic\Examples\Application\mainwindow" -CompileItself -QTDIRc:\Qt\4.8.0



// "C:\Users\Bernd\Desktop\TPanel" -CompileItself -QTDIRc:\Qt\4.8.0
// "C:\Users\Bernd\Desktop\objb_q7basic\Q7Basic" -CompileItself -QTDIRc:\QtSDK\Desktop\Qt\4.8.0\mingw -MINGW
// "C:\Users\Bernd\Desktop\objb_q7basic\Q7Basic" -CompileItself -QTDIRc:\Qt\4.8.0

// "C:\Users\Bernd\Desktop\objb_q7basic\q7b\RELEASE_Examples_DONT_TOUCH_THEM\!Application\mainwindow" -QTDIRc:\QtSDK\Desktop\Qt\4.8.0\mingw -MINGW

// "C:\Users\Bernd\Desktop\objb_q7basic\q7b\RELEASE_Examples_DONT_TOUCH_THEM\Qt Controls\QButtonGroup3" -QTDIRc:\Qt\4.8.0

// /Users/berndnoetscher/Desktop/objb_q7basic/Q7Basic -CompileItself -QTDIR/Users/berndnoetscher/QtSDK



#include "_Q7BCompiler.h"







QMap<QString, QString> CONFIG;


_parser_me Parser::Me;
_compiler_me Compiler::Me;

MakeInterface *make;
QStringList compiler_sOBJECTFILES;


extern void generateScanner();


int StartMeUp(int argc, char *argv[])
{

  QCoreApplication app(argc, argv);


  bool bError = false; QString sError; int nErrorLine = 0;




  //QString sdf = Scanner::scan("i=i+1\n", &bError, &sError, &nErrorLine).join(" ");
  




  CONFIG.clear();


  CONFIG["APPNAME"] = "Q7Basic";
  CONFIG["GLOBALFILENAME"] = "Global.QObject.q7b";
  CONFIG["RuntimePath"] = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "/objb_q7basic/q7b/Runtime";
  CONFIG["ADDITIONALSOURCEDIR"] = "cpp";
  CONFIG["BasePath"] = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "/objb_q7basic";



#ifdef Q_OS_WIN32
    CONFIG["SPECVC"] = "win32-msvc2008";
    CONFIG["SPECGCC"] = "win32-g++";
    CONFIG["BuildReleasePath"] = "/Build/release/";

    CONFIG["VC"] = "C:/Programme/Microsoft Visual Studio 9.0/VC";
    CONFIG["Psapi"] = "C:\\Program Files\\Microsoft SDKs\\Windows\\v6.0A\\Lib\\Psapi.lib";


    


#elif defined Q_OS_MAC
    CONFIG["SPECVC"] = "";
    CONFIG["SPECGCC"] = "macx-g++";
    CONFIG["BuildReleasePath"] = "/Build/";
#elif defined Q_OS_X11
    CONFIG["SPECVC"] = "";
    CONFIG["SPECGCC"] = "linux-g++";
    CONFIG["BuildReleasePath"] = "/Build/";
#endif


  CONFIG["CompileItself"] = "false";

  QStringList arguments = qApp->arguments();

  if (arguments.size() <= 1){
    
    Parser::error("No arguments given or no files in the current project folder", false);
    return false;
  }

  for (int i = 0; i < arguments.size(); i++){ 


    if (arguments.at(i) == "-Deploy"){ CONFIG["Deploy"] = "true"; }




    else if (arguments.at(i).startsWith("-VCDIR")){ CONFIG["VC"] = arguments.at(i).mid(QString("-VCDIR").length()).replace("/", "\\"); }
   
    else if (arguments.at(i).startsWith("-MINGW")){
      CONFIG["MINGW"] = "true";
    }
    else if (arguments.at(i).startsWith("-QTDIR")){ CONFIG["QTDIR"] = arguments.at(i).mid(QString("-QTDIR").length()).replace("/", "\\"); }




   else if (arguments.at(i) == "-VM"){ CONFIG["VM"] = "true"; }


    //else if (arguments.at(i) == "-Documentation"){ CONFIG["Documentation"] = "true"; }

    else if (arguments.at(i) == "-CompileItself"){ CONFIG["CompileItself"] = "true"; }
    else if (arguments.at(i) == "-xcodeproj"){ CONFIG["xcodeproj"] = "true"; }

  }
  
  if (CONFIG["Deploy"] == "true"){
    CONFIG["VM"] = "";  
  }






#ifdef Q_OS_WIN32
 if (CONFIG["MINGW"].isEmpty()){
    CONFIG["QMAKE"] = CONFIG["QTDIR"] + "\\bin\\qmake";
    CONFIG["SPEC"] = CONFIG["QTDIR"] + "\\mkspecs\\" + CONFIG["SPECVC"];
    CONFIG["CONFIG"] += "\nQMAKE_CXXFLAGS_RELEASE-=/O2\nQMAKE_CXXFLAGS_RELEASE+=/Od\n";
 } else {
    CONFIG["QMAKE"] = CONFIG["QTDIR"] + "\\bin\\qmake";
    CONFIG["SPEC"] = CONFIG["QTDIR"] + "\\mkspecs\\" + CONFIG["SPECGCC"];
    CONFIG["CONFIG"] += "\nQMAKE_CXXFLAGS_RELEASE-=-O2\nQMAKE_CXXFLAGS_RELEASE+=-O0\n";
 }
 CONFIG["MINGWDIR"] = CONFIG["QTDIR"] + "/mingw";

#elif defined Q_OS_MAC
  CONFIG["QTDIR"] = CONFIG["QTDIR"].replace("\\", "/");

  CONFIG["QMAKE"] = CONFIG["QTDIR"] + "/bin/qmake";
  CONFIG["SPEC"] = CONFIG["QTDIR"] + "/mkspecs/" + CONFIG["SPECGCC"];
  CONFIG["CONFIG"] += "\nQMAKE_CXXFLAGS_RELEASE-=-O2\nQMAKE_CXXFLAGS_RELEASE+=-O0\nCONFIG-=ppc\nCONFIG-=x86\nCONFIG+=x86_64\n";

#elif defined Q_OS_X11
  CONFIG["QTDIR"] = CONFIG["QTDIR"].replace("\\", "/");

  CONFIG["QMAKE"] = "/usr/bin/qmake";
  CONFIG["SPEC"] = CONFIG["SPECGCC"];
  CONFIG["CONFIG"] += "\nQMAKE_CXXFLAGS_DEBUG+=-fpermissive\nQMAKE_CXXFLAGS_RELEASE+=-fpermissive\n";  
#endif


  Parser::CreateListOfKeywords(); 

  if (CONFIG["CompileItself"] == "true"){
    generateScanner();
  }
    Parser::CreateListOfcppobjcjava_keywords();

    Parser::CreateListOfSubsFunctions();
    Parser::CreateListOfConstants();
    Parser::CreateListOfClasses();
    Parser::CreateListOfObjects();
    Parser::CreateListOfControls();
    Parser::CreateListOfTypes();
    Parser::CreateListOfOperators();

  Parser::CreateListOfInitFunctions();

  Parser::createDocumentation(); 

    // QStringList h = Parser::Me.sub_classes["QPushButton"];
    // QString asfd = h.join(";");


    if (CONFIG["CompileItself"] == "true"){
      Parser::createCompilerFiles();
      Parser::createRuntimeFiles();
      Parser::createTxtFiles();
    }


  make = new MakeInterface();
  int ret = 0;

  if (Parser::runCompiler()){
    ret = 0;
    goto re;
  }

  ret = -1;
re:

  delete make;
  return ret;


}



bool Parser::runCompiler()
{


  QStringList lAllTypes;

  compiler_sOBJECTFILES.clear();

  QStringList arguments = qApp->arguments();


  Write_To_stdout("Starting compiler...\n");

  

  CONFIG["VMDIR"] = "vm";


  CONFIG["GCCDIR"] = "gcc";
 // if (CONFIG["VM"] == "true"){
 //   CONFIG["BUILDDIR"] = CONFIG["VMDIR"];
 
    CONFIG["BUILDDIR"] = CONFIG["GCCDIR"];
 




        if (arguments.count() > 0){
          CONFIG["PROJECTPATH"] = arguments.at(1);
        }

  CONFIG["SINGLEFILEPROJECT"] = "false";

        if (CONFIG["PROJECTPATH"].endsWith(".q7basic")){
          CONFIG["SINGLEFILEPROJECT"] = "true";
          CONFIG["GLOBAL"] = getFileName(CONFIG["PROJECTPATH"]);
  } else {
    CONFIG["SINGLEFILEPROJECT"] = "false";
  }


        CONFIG["PROJECTNAME"] = getFileName(CONFIG["PROJECTPATH"]);
       //   Write_To_stdout(CONFIG["PROJECTPATH"] + "\n");
       //   Write_To_stdout("!" + CONFIG["PROJECTNAME"] + "!\n");
 QString wwer = CONFIG["PROJECTPATH"];
  QDir dir(CONFIG["PROJECTPATH"]);

  if (CONFIG["SINGLEFILEPROJECT"] == "false"){
    Me.files = dir.entryList();
  }


  if (CONFIG["SINGLEFILEPROJECT"] == "false" && Me.files.size() == 0){
    error("No input files given to the " + CONFIG["APPNAME"] + "-Compiler or given path is not valid or empty", false);
    return false;
  }

 
  if (CONFIG["SINGLEFILEPROJECT"] == "true"){
    CONFIG["PROJECTPATHORIGINAL"] = CONFIG["PROJECTPATH"];
    Me.files << getFileName(CONFIG["PROJECTPATH"]);

          QDir("/").mkpath(QDir::tempPath() + "/Q7Basic");

    CONFIG["PROJECTPATH"] = QDir::tempPath() + "/Q7Basic/" + getBaseName(CONFIG["PROJECTPATH"]); 
    QFile::remove(CONFIG["PROJECTPATH"] + "/" + getFileName(CONFIG["PROJECTPATHORIGINAL"]));
    QFile::copy(CONFIG["PROJECTPATHORIGINAL"], CONFIG["PROJECTPATH"] + "/" + getFileName(CONFIG["PROJECTPATHORIGINAL"]));
  }

  QStringList sourceFiles;
  QStringList uiFiles;
  QStringList qrcFiles;

  QStringList sourceFilesUICheck;

  

  // get source related files in project path
  for (int i = 0; i < Me.files.size(); i++){

    if (Me.files.at(i) != "." && Me.files.at(i) != ".."){
  QString hhh =  Me.files.at(i);
        if (isSourceFile(Me.files.at(i))){
          sourceFiles << Me.files.at(i);
          sourceFilesUICheck << getBaseName(getBaseName(Me.files.at(i)));
        }


         if (Me.files.at(i).endsWith(".ui")){
                  uiFiles << Me.files.at(i);

        }
        if (Me.files.at(i).endsWith(".qrc")){
                  qrcFiles << Me.files.at(i);
        }



     }
  }



  if (sourceFiles.size() == 0){
    error("No input files given to the " + CONFIG["APPNAME"] + "-Compiler or given path is not valid or empty", false);
    return false;
  }

  Me.files = sourceFiles;
   if (Me.files.size() == 0){
    error("No arguments given to the " + CONFIG["APPNAME"] + "-Compiler", false);
    return false;
 }


   if (CONFIG["xcodeproj"] == "true"){

       QDir().mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"]);

       for (int i = 0; i < Me.files.size(); i++){
         Me.sFileName = Me.files.at(i);

         
         SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + getClassName(Me.sFileName) + ".mm", "", false);
         SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + getClassName(Me.sFileName) + ".h", "", false);

       }

       if (!build()){
          error("Creation of files aborted due to unknown error");
          return false;
       }
       return true;
   }


  

  for (int i = 0; i < uiFiles.size(); i++){
     if (sourceFilesUICheck.contains(getBaseName(uiFiles.at(i)))){
      Me.uiCompileFiles << uiFiles.at(i);

      Me.uiCompileFiles2 << getBaseName(uiFiles.at(i));
    } else {
      Me.uiRuntimeFiles << uiFiles.at(i);
      Me.uiRuntimeFiles2 << getBaseName(uiFiles.at(i));
    }

    
    for (int q = 0; q < Me.files.size(); q++){
      if (Me.files.at(q).startsWith(getBaseName(uiFiles.at(i)) + ".")){

        QString uis = LoadFile(CONFIG["PROJECTPATH"] + "/" + getFileName(uiFiles.at(i)));
        int n = uis.indexOf("<widget class=\"");

        if (n >= 0){
          n += 15;
          int n2 = uis.indexOf("\"", n);

          QString uitype = uis.mid(n, n2 - n);

          QString sSuper = getSuperClassName(Me.files.at(q));
          if (sSuper != "uiClass" && sSuper != uitype){
            error(QString("ui file '%1' widget class type (class = %2) differs from source code file '%3' (super class = %4)").arg(getBaseName(uiFiles.at(i))).arg(uitype).arg(Me.files.at(q)).arg(sSuper), false);
          }

        }

      }
    }
  }




  

  QMap<QString, QString> sFileCachedSource;
  QMap<QString, QString> sFileCachedDestination;
  QMap<QString, bool> filesScannerNotCached;

  bool bCompile = false;

   for (int i = 0; i < Me.files.size(); i++){

      Me.sFileName = Me.files.at(i);

      Me.Classes[getClassName(Me.sFileName)] = getSuperClassName(Me.sFileName);

      sFileCachedDestination[Me.sFileName]  = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Parser/";
      if (i == 0){
        QDir("/").mkpath(getPath(sFileCachedDestination[Me.sFileName]));
      }

    sFileCachedSource[Me.sFileName] = CONFIG["PROJECTPATH"] + "/" + getFileName(Me.files.at(i));

    sFileCachedDestination[Me.sFileName] += getFileName(sFileCachedSource[Me.sFileName]);

   QFileInfo fi(sFileCachedSource[Me.sFileName]);

    QFileInfo fiCached(sFileCachedDestination[Me.sFileName]);

    filesScannerNotCached[Me.files.at(i)] = true;

    if (QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + getClassName(getFileName(Me.files.at(i))) + ".h") && fiCached.exists()){

      if (fi.size() == fiCached.size() && LoadFile(sFileCachedSource[Me.sFileName]) == LoadFile(sFileCachedDestination[Me.sFileName])){
      } else {
        bCompile = true;
        filesScannerNotCached[Me.files.at(i)] = true;
      }
    } else {
       bCompile = true;
       QDir("/").mkpath(getPath(sFileCachedDestination[Me.sFileName]));
       if (QFile::exists(sFileCachedDestination[Me.sFileName])) QFile::remove(sFileCachedDestination[Me.sFileName]);
       QFile::copy(sFileCachedSource[Me.sFileName], sFileCachedDestination[Me.sFileName]);
    }
  }

   if (bCompile == false){
     goto build_;
   }
  

  CONFIG["GLOBALFILE"] = "false";
  CONFIG["MAINWINDOWFILE"] = "false";
  CONFIG["SYSTEMTRAYICONFILE"] = "false";
  CONFIG["APPLICATIONFILE"] = "false";

  for (int i = 0; Me.bError == false && i < Me.files.size(); i++){

    QString sdf = Me.files.at(i);
    if (isGlobalFile(Me.files.at(i))){
      CONFIG["GLOBALFILE"] = "true";
      CONFIG["GLOBALFILEPATH"] = Me.files.at(i);
    } else

    if (isMainWindowFile(Me.files.at(i))){
      CONFIG["MAINWINDOWFILE"] = "true";
      CONFIG["MAINWINDOWFILEPATH"] = Me.files.at(i);
        } else

    if (isSystemTrayIcon(Me.files.at(i))){
      CONFIG["SYSTEMTRAYICONFILE"] = "true";
      CONFIG["SYSTEMTRAYICONFILEPATH"] = Me.files.at(i);
        } else

    if (isApplication(Me.files.at(i))){
      CONFIG["APPLICATIONFILE"] = "true";
      CONFIG["APPLICATIONFILEPATH"] = Me.files.at(i);
        }

        if (!isFileSuperClassValid(Me.files.at(i))){
      error("File ending not allowed. Use different super class name instead", false);
      return false;
    }

    for (int z = 0; z < Me.cppobjcjava_keywords.size(); z++){
      if (Me.files.at(i).startsWith(Me.cppobjcjava_keywords.at(z) + ".")){
        error("File name contains '" + Me.cppobjcjava_keywords.at(z) + ".', which is not allowed to use, because it is a C++ keyword.", false);
        return false;
      }
      if (Me.files.at(i).startsWith(Me.cppobjcjava_keywords.at(z) + ".")){
        error("File name contains '" + Me.cppobjcjava_keywords.at(z) + ".', which is not allowed to use, because it is a Objective-C keyword.", false);
        return false;
      }
    }

  }

  if (CONFIG["GLOBALFILE"] == false){
    error("File '" + CONFIG["GLOBALFILENAME"] + "' not in project", false);
    return false;
  }

  if (CONFIG["SINGLEFILEPROJECT"] == "false"){


    if (CONFIG["MAINWINDOWFILE"] == "false"){
      error("File 'MainWindow.QMainWindow' not in project", false);
      return false;
    }


  if (CONFIG["SINGLEFILEPROJECT"] == "false"){
    for (int i = 0; Me.bError == false && i < Me.files.size(); i++){
      QString sSuperClassName = (getSuperClassName(Me.files.at(i)));

      if (Me.classes.contains(sSuperClassName) || Me.controls.contains(sSuperClassName) || Me.objects.contains(sSuperClassName)){
        continue;
      }


      for (int q = 0; Me.bError == false && q < Me.files.size(); q++){
        QString sClassName = getClassName(Me.files.at(q));

        if (sClassName == sSuperClassName){
          error(QString("Sorry. Sub classing a user defined class is not allowed yet.").arg(Me.files.at(q)), false);
          return false;
        }
        



     }
    }


  

  lAllTypes << Me.types;
  lAllTypes << Me.classes.values();
  lAllTypes << Me.controls.values();
  lAllTypes << Me.objects.values();

  for (int i = 0; Me.bError == false && i < Me.files.size(); i++){

    for (int z = 0; z < lAllTypes.size(); z++){
      if (Me.files.at(i).startsWith(lAllTypes.at(z) + ".")){
        error("File name " + Me.files.at(i) + " contains '" + lAllTypes.at(z) + ".', which is not allowed to use", false);
        return false;
      }
    }
  }


  //Me.allTypes << transformedTypes.keys(); 


  
  {
    QDir dir(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"]);
    QStringList ll = dir.entryList();

    for (int i = 0; i < ll.size(); i++){
      QString s = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i);
      if (!(QFileInfo(s).isDir())){
        QFile f(s);
        f.remove();
      }
    }
  }



  
  Write_To_stdout("Read source files...\n");

  for (int i = 0; i < Me.files.size(); i++){

    Me.sFileName = Me.files.at(i);

    Me.nLine = 1;

   QString s = Me.sSourceCode[Me.sFileName] = LoadFile(CONFIG["PROJECTPATH"] + "/" + Me.sFileName);

    if (CONFIG["SINGLEFILEPROJECT"] == "true"){
      if (!s.contains("\nEvent Init(") && s.contains("\nSub Main(")){
        s += "\n\nEvent Init()\n  Main()\nEnd Event\n";
      }
    }

    Me.sFileNameForClass[getClassName(Me.sFileName)] = Me.sFileName;

    if (filesScannerNotCached.contains(Me.sFileName) || !QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Scanner/" + Me.sFileName)){

      bool bError = false;
      QString sError;
      int nErrorLine = 1;

   
      Me.tokens[Me.sFileName] = Scanner::scan(s, &bError, &sError, &nErrorLine);

      if (bError){
        error(sError, false);
        return false;
      }

      QDir("/").mkpath(getPath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Scanner/" + Me.sFileName));
      SaveFileAsStringList(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Scanner/" + Me.sFileName, Me.tokens[Me.sFileName]);

    } else {
      Me.tokens[Me.sFileName] << LoadFileAsStringList(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Scanner/" + Me.sFileName);

    }
  }

  

  if (Me.bError){
     error("Parsing files aborted due to unknown error", false);
     return false;
  }

  

  for (int y = 0; y < 2; y++){
    Me.nPass = y;

    for (int i = 0; Me.bError == false && i < Me.files.size(); i++){
      if (!parse(Me.files.at(i))){
        break;
      }
    }

    if (Me.bError){
       error("Parsing of files aborted due to unknown error");
       return false;
    }

  }

   if (QFile::exists(CONFIG["PROJECTPATH"] + "/Resources/splash.png")){
     CONFIG["SPLASH"] = "true";
   }

   { 
      QDir dir(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"]);
      QStringList filter; filter << "*.pro"; filter << "*.pri";
      QStringList ll = dir.entryList(filter, QDir::Files);
     
      {
        for (int i = 0; i < ll.size(); i++){
          Me.sCPPProHeaderFiles += "#include \"./" + getBaseName(ll.at(i)) + "/" + getBaseName(ll.at(i)) + ".h\"\n";
        }
      }
   }

   
  for (int i = 0; Me.bError == false && i < Me.files.size(); i++){
    if (!Compiler::compile(Me.files.at(i))) break;
  }

  if (Me.bError){
     error("Compilation of files aborted due to unknown error");
     return false;
  }

  
build_:
  Me.sFileName = "";
  Me.nLine = 1;

  if (!build()){
     error("Creation of files aborted due to unknown error");
     return false;
  }
}



}
  return true;
}



bool Parser::build()
{



    Write_To_stdout("Copy " + CONFIG["APPNAME"] + " runtime...\n");

    QString sPathReleaseOrDebug;
    if (CONFIG["Deploy"] == "true" ||CONFIG["CompileItself"] == "true"){
      sPathReleaseOrDebug = "release";
    } else {
      sPathReleaseOrDebug = "debug";
    }


    QString sQ7BRuntimeObjectFileName;

      QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build");

      QString sCopyRuntimeFromPath;
      if (CONFIG["CompileItself"] == "true"){
        sCopyRuntimeFromPath = CONFIG["RuntimePath"] + "/";
      } else {
        sCopyRuntimeFromPath = qApp->applicationDirPath() + "/";
      }

      
      {
        QString sPath = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/";

        if (!QFile::exists(sPath + "ImageButton.h")) SaveFile(sPath + "ImageButton.h", "#include \"Q7BRuntime.h\"\n#define ImageButton Q7B_ImageButton\n", true);
        if (!QFile::exists(sPath + "CommandButton.h")) SaveFile(sPath + "CommandButton.h", "#include \"Q7BRuntime.h\"\n#define CommandButton Q7B_CommandButton\n", true);
        if (!QFile::exists(sPath + "CommandLinkButton.h")) SaveFile(sPath + "CommandLinkButton.h", "#include \"Q7BRuntime.h\"\n#define CommandLinkButton Q7B_CommandButton\n", true);
        if (!QFile::exists(sPath + "ToolButton.h")) SaveFile(sPath + "ToolButton.h", "#include \"Q7BRuntime.h\"\n#define ToolButton Q7B_ToolButton\n", true);
        if (!QFile::exists(sPath + "CheckBox.h")) SaveFile(sPath + "CheckBox.h", "#include \"Q7BRuntime.h\"\n#define CheckBox Q7B_CheckBox\n", true);
        if (!QFile::exists(sPath + "RadioButton.h")) SaveFile(sPath + "RadioButton.h", "#include \"Q7BRuntime.h\"\n#define RadioButton Q7B_RadioButton\n", true);
        if (!QFile::exists(sPath + "Label.h")) SaveFile(sPath + "Label.h", "#include \"Q7BRuntime.h\"\n#define Label Q7B_Label\n", true);
        if (!QFile::exists(sPath + "Frame.h")) SaveFile(sPath + "Frame.h", "#include \"Q7BRuntime.h\"\n#define Frame Q7B_Frame\n", true);
        if (!QFile::exists(sPath + "ImageBox.h")) SaveFile(sPath + "ImageBox.h", "#include \"Q7BRuntime.h\"\n#define ImageBox Q7B_ImageBox\n", true);
        if (!QFile::exists(sPath + "TextBox.h")) SaveFile(sPath + "TextBox.h", "#include \"Q7BRuntime.h\"\n#define TextBox Q7B_TextBox\n", true);

        if (!QFile::exists(sPath + "uiClass.h")) SaveFile(sPath + "uiClass.h", "#include \"Q7BRuntime.h\"\n#define uiClass Q7B_uiClass\n", true);
        if (!QFile::exists(sPath + "Class.h")) SaveFile(sPath + "Class.h", "#include \"Q7BRuntime.h\"\n#define Class Q7B_Class\n", true);
        if (!QFile::exists(sPath + "Module.h")) SaveFile(sPath + "Module.h", "#include \"Q7BRuntime.h\"\n#define Module Q7B_Module\n", true);

        //SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Box.h", "#include \"Q7BRuntime.h\"\n#define Box Q7B_Box\n");

        QFile f(sCopyRuntimeFromPath + "Q7BRuntime.h");

        if (CONFIG["CompileItself"] == "true"){
          QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BRuntime.h");
          f2.remove();
          QFile::copy(f.fileName(), f2.fileName());
        }

        if (QFile::exists(f.fileName())){
          copyIfNeeded(f.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + "Q7BRuntime.h", true);
          if (CONFIG["CompileItself"] == "true"){
            copyIfNeeded(f.fileName(), sCopyRuntimeFromPath + "Q7BRuntime.h", true);
          }
        }
      }
      {
        QFile f(sCopyRuntimeFromPath + "Q7BRuntime.cpp");

        if (CONFIG["CompileItself"] == "true"){
          QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BRuntime.cpp");
          f2.remove();
          QFile::copy(f.fileName(), f2.fileName());
        }

        if (QFile::exists(f.fileName())){
          copyIfNeeded(f.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + "Q7BRuntime.cpp", true);
          if (CONFIG["CompileItself"] == "true"){
            copyIfNeeded(f.fileName(), sCopyRuntimeFromPath + "Q7BRuntime.cpp", true);
          }
        }
      }

      
      if (CONFIG["CompileItself"] == "true"){

        QFile f(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "/objb_q7basic/Compiler/Interface/Q7BCompiler.h");
        QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BCompiler.h");
        f2.remove();
        QFile::copy(f.fileName(), f2.fileName());

        copyIfNeeded(f2.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Q7BCompiler.h", true);
      }

      if (CONFIG["CompileItself"] == "true"){
        QFile f(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "/objb_q7basic/Compiler/Interface/Q7BCompiler.cpp");
        QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BCompiler.cpp");
        f2.remove();
        QFile::copy(f.fileName(), f2.fileName());

        copyIfNeeded(f2.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Q7BCompiler.cpp", true);
      }

      
      if (CONFIG["CompileItself"] == "true"){
        QFile f(CONFIG["RuntimePath"] + "/Q7BCodeView/Q7BCodeView.h");
        QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BCodeView.h");
        f2.remove();
        QFile::copy(f.fileName(), f2.fileName());

        copyIfNeeded(f2.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Q7BCodeView.h", true);
      }

      if (CONFIG["CompileItself"] == "true"){
        QFile f(CONFIG["RuntimePath"] + "/Q7BCodeView/Q7BCodeView.cpp");
        QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BCodeView.cpp");
        f2.remove();
        QFile::copy(f.fileName(), f2.fileName());

        copyIfNeeded(f2.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Q7BCodeView.cpp", true);
      }

      
      if (CONFIG["CompileItself"] == "true"){
        QFile f(CONFIG["RuntimePath"] + "/Q7BProjectWindow/Q7BProjectWindow.h");
        QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BProjectWindow.h");
        f2.remove();
        QFile::copy(f.fileName(), f2.fileName());

        copyIfNeeded(f2.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Q7BProjectWindow.h", true);
      }

      if (CONFIG["CompileItself"] == "true"){
        QFile f(CONFIG["RuntimePath"] + "/Q7BProjectWindow/Q7BProjectWindow.cpp");
        QFile f2(CONFIG["PROJECTPATH"] + "/cpp/Q7BProjectWindow.cpp");
        f2.remove();
        QFile::copy(f.fileName(), f2.fileName());

        copyIfNeeded(f2.fileName(), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "Q7BProjectWindow.cpp", true);
      }




    




    if (QDir().exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"])){

        Write_To_stdout("Copy custom *.cpp and *.h from project to gcc directory, if necessary...\n");

      
      {
        QDir dir(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"]);
        QStringList ll = dir.entryList(QDir::Files);

        for (int i = 0; i < ll.size(); i++){
          if (ll.at(i) != "." && ll.at(i) != ".."){
            QString q = ll.at(i);
            if (q.endsWith(".user")) continue;
            if (q.endsWith(".pro")){
              q = "Build/" + getBaseName(q) + ".pri";
            }

            copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"] + "/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + q, true);
          }
        }
      }
    }

    Write_To_stdout("Copy *.cpp and *.h to Build directory, if necessary...\n");

    QStringList sFiles;
    
    {

      QDir dir(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"]);
      QStringList ll = dir.entryList();

      for (int i = 0; i < ll.size(); i++){
        if (!(QFileInfo(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i)).isDir())){

          sFiles << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i) );

          copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + ll.at(i), true);


        }
      }
    }

    bool bAllowCachingOfQ7BRuntime = false; 

    // caching build of Q7BRuntime, after Q7BRuntime.h Q7BRuntime.cpp are copied
    if (CONFIG["CompileItself"] == "false"){

      if (QFile::exists(qApp->applicationDirPath() + "/Q7BRuntime.txt")){

        QString sMode = LoadFile(qApp->applicationDirPath() + "/Q7BRuntime.txt");

        if (sMode == "release" && CONFIG["Deploy"] == "true") bAllowCachingOfQ7BRuntime = true;
        else if (sMode == "debug" && CONFIG["Deploy"] != "true") bAllowCachingOfQ7BRuntime = true;

      }

      SaveFile(qApp->applicationDirPath() + "/Q7BRuntime.txt", CONFIG["Deploy"] == "true" ? "release" : "debug", false);

    #ifdef Q_OS_WIN32
        if (CONFIG["MINGW"].isEmpty()){
          sQ7BRuntimeObjectFileName = "/Q7BRuntime.obj";
        } else {
          sQ7BRuntimeObjectFileName = "/Q7BRuntime.o";
        }
    #else
         sQ7BRuntimeObjectFileName = "/Q7BRuntime.o";
    #endif

      if (bAllowCachingOfQ7BRuntime == false){
        QFile::remove(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
  
        QFile f2;

        #ifdef Q_OS_WIN32
          QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);

          f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug + sQ7BRuntimeObjectFileName);
        #elif defined Q_OS_MAC
          QString sProjectName = getFileName(CONFIG["PROJECTPATH"]);
          QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS");

          f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + sQ7BRuntimeObjectFileName);
//          f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS" + sQ7BRuntimeObjectFileName);
        #elif defined Q_OS_X11
          QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build");

          f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + sQ7BRuntimeObjectFileName);
        #endif

        f2.remove();

      }

      if (bAllowCachingOfQ7BRuntime){

        if (QFile::exists(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName)){

          QFileInfo fh(qApp->applicationDirPath() + "/Q7BRuntime.h");
          QFileInfo fcpp(qApp->applicationDirPath() + "/Q7BRuntime.cpp");
          QFileInfo fo(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);


          if (fo.lastModified() < fcpp.lastModified() || fo.lastModified() < fh.lastModified()){ 
            QFile::remove(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
          } else {

            QFile f;
            QFile f2;

            #ifdef Q_OS_WIN32
              QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);

              f.setFileName(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
              f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug + sQ7BRuntimeObjectFileName);
            #elif defined Q_OS_MAC
              QString sProjectName = getFileName(CONFIG["PROJECTPATH"]);
              QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS");

              f.setFileName(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
              f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + sQ7BRuntimeObjectFileName);
//              f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS" + sQ7BRuntimeObjectFileName);
            #elif defined Q_OS_X11
              QDir("/").mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build");

              f.setFileName(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
              f2.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + sQ7BRuntimeObjectFileName);
            #endif

            f2.remove();
            QFile::copy(f.fileName(), f2.fileName());

          }

        }
      }

    }
    QString sResourceFiles;
    if (QDir().exists(CONFIG["PROJECTPATH"] + "/Resources")){
      Write_To_stdout("Copy resources, if necessary...\n");

      copyResourceFolder(sResourceFiles, CONFIG["PROJECTPATH"] + "/Resources", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Resources", "");

      copyDir(CONFIG["PROJECTPATH"] + "/Resources", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + "/Resources");
    }


    Write_To_stdout("Copy *.ui *.qrc *.ts, if necessary...\n");
    
    {
      QDir().mkpath(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache");

      QDir dir(CONFIG["PROJECTPATH"]);
      QStringList ll = dir.entryList();

      for (int i = 0; i < ll.size(); i++){

        if (ll.at(i) != "." && ll.at(i) != ".." && ((ll.at(i).endsWith(".ui") && !Me.uiRuntimeFiles2.contains(getBaseName(getBaseName(ll.at(i))))) || ll.at(i).endsWith(".qrc") || ll.at(i).endsWith(".ts"))){

          if (!ll.at(i).endsWith(".ui")){
            if (ll.at(i).endsWith(".qrc")){
              sFiles << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i));
            } else {
              sFiles << (CONFIG["PROJECTPATH"] + "/" + ll.at(i));
            }

            copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i));
            copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + ll.at(i));
          } else {

            sFiles << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i));

            if (copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i))){


              int nui_index = Me.uiCompileFiles2.indexOf(getBaseName(ll.at(i)));

              if (nui_index >= 0){

                QString rr;
                if (QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i))){
                  rr = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i);
                } else {
                  rr = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i);
                }
                QMap<QString, QString> sLOADED;

                QString s = LoadFile(rr);
                int k = s.indexOf("<class>");
                if (k >= 0){
                  k += 7;
                  int k2 = s.indexOf("</class>", k);
                  QString nn = s.mid(k, k2 - k);
                  if (nn != getBaseName(ll.at(i))){
                    s.replace(k, k2 - k, getBaseName(ll.at(i)));
                    SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), s, false);
                    sLOADED[getBaseName(ll.at(i))] = s;
                  }
                }

                for (int y = 0; y < Me.files.size(); y++){

                  if (getBaseName(getBaseName(Me.files.at(y))) == getBaseName(ll.at(i))){

                    QString sFILE;
                    sFILE = Me.files.at(y);

                    if (!Me.sOutletsName[sFILE].isEmpty()){
                      QString sadfwer = Me.sOutletsName[sFILE].join(";");
                      QString sadfwer2 = Me.sOutletsSet[sFILE].join(";");

                      for (int yy = 0; yy < Me.sOutletsName[sFILE].size(); yy++){
                        QString sett = Me.sOutletsSet[sFILE].at(yy);

                        if (!sett.isEmpty()){
                          QString n = Me.sOutletsName[sFILE].at(yy);
                          QString t = Me.sOutletsType[sFILE].at(yy);
                          QString tt;

                          QString s;
                          if (sLOADED.contains(getBaseName(ll.at(i)))){
                            s = sLOADED[getBaseName(ll.at(i))];
                          } else {
                            QString rr;
                            if (QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i))){
                              rr = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i);
                            } else {
                              rr = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i);
                            }

                            s = LoadFile(rr);
                          }
                          int m = 0;
                          while((m = s.indexOf("<widget class=\"", m)) >= 0){
                            m += 15;
                            int k = s.indexOf("name=\"", m);
                            if (k > m){
                              k += 6;
                              int k2 = s.indexOf("\"", k);
                              QString nn = s.mid(k, k2 - k);
                              if (nn == n){
                                int m2 = s.indexOf("\"", m);
                                tt = s.mid(m, m2 - m);
                                s.replace(m, m2 - m, t);
                                break;
                              }
                            }

                            m++;

                          }

                          QString w;
                          int x = s.lastIndexOf("</customwidget>\n");

                          if (x >= 0){
                            x += 16;

                          w = QString("<customwidget>\n") +
                           "<class>" + t + "</class>\n" +
                           "<extends>" + tt + "</extends>\n" +
                           "<header>" + t + ".h</header>\n" +
                          "</customwidget>\n";

                          s.insert(x, w);

                          } else {
                           x = s.lastIndexOf("</widget>\n");

                           x += 10;

                          w = QString("<customwidgets>\n") +
                           "<customwidget>\n" +
                           "<class>" + t + "</class>\n" +
                           "<extends>" + tt + "</extends>\n" +
                           "<header>" + t + ".h</header>\n" +
                          "</customwidget>\n" +
                          "</customwidgets>\n";

                          s.insert(x, w);

                          }

                          SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), s, false);

                        }
                      }
                    }
                  }
                }
              } else {
                copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i));
              }

              if (!QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i))){
                if (copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i))){

                  
                //  QString s = LoadFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i));
               //   SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), s, true);
                }

              }

              if (QFileInfo(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/ui_cache/" + ll.at(i)).lastModified() > QFileInfo(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i)).lastModified()){

                
                QString s = LoadFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i));
                SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), s, true);
              }

              copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + ll.at(i));
            }
          }
        }
      }
    }

    
    {
      if (!sResourceFiles.isEmpty() || Me.uiRuntimeFiles2.size() > 0){
        Write_To_stdout("Create runtime ui file resource file q7b_default.qrc...\n");

        QString s = "<RCC>\n\n<qresource prefix=\"uifiles\">\n";
        for (int i = 0; i < Me.uiRuntimeFiles2.size(); i++){
          s += QString("<file>../../") + Me.uiRuntimeFiles2.at(i) + ".ui</file>\n";
        }
        s += "</qresource>\n\n<qresource prefix=\"Resources\">\n";
        s += sResourceFiles;
        s += "</qresource>\n";
        s += "</RCC>\n";

        SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + "q7b_default.qrc", s, false);
        SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + "q7b_default.qrc", s, false);

        sFiles << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + "q7b_default.qrc");
      }
    }

    QString sProjectName = getFileName(CONFIG["PROJECTPATH"]);


    

    Write_To_stdout("qmake - create pro file...\n");
   // qmake - create pro file
   {
     QString sCPPProFiles;
     
     { 
        QDir dir(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"]);
        QStringList filter; filter << "*.pro"; filter << "*.pri";
        QStringList ll = dir.entryList(filter, QDir::Files);
       
        {
          for (int i = 0; i < ll.size(); i++){
            sCPPProFiles += "include(" + getBaseName(ll.at(i)) + ".pri)\n";

            if (!QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"] + "/" + getBaseName(ll.at(i)) + "/" + getBaseName(ll.at(i)) + ".h")){
              error("mising header file for sub project -> not found: " + CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"] + "/" + getBaseName(ll.at(i)) + "/" + getBaseName(ll.at(i)) + ".h\n");
            }
          //  Me.sCPPProHeaderFiles += "#include \"./" + getBaseName(ll.at(i)) + "/" + getBaseName(ll.at(i)) + ".h\"\n";

            copyDir(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"] + "/" + getBaseName(ll.at(i)), CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + getBaseName(ll.at(i)), true);  
            copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["ADDITIONALSOURCEDIR"] + "/" + getBaseName(ll.at(i)) + "/" + getBaseName(ll.at(i)) + ".h", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + getBaseName(ll.at(i)) + ".h"); 
          }
        }
     }

     QString sDEFINES = "\nDEFINES+=Q7BASIC\n";     

     QString sOBJMOC;
     for (int qz = 0; qz < Me.DeclareClasses.keys().size(); qz++){
       sOBJMOC += "OBJMOC+=\"" + Me.DeclareClasses.keys().at(qz) + ".h\"\n";
     }

     QString program = CONFIG["QMAKE"];
     QString sRC_FILE;
     if (QFile::exists(CONFIG["PROJECTPATH"] + "/Resources/windows_application_icon.rc")){
       sRC_FILE = "RC_FILE+=../Resources/windows_application_icon.rc\n";
     }
   
     QString sConfig = "\nCONFIG+=warn_off\nQT+=webkit\nQT+=webkit\nQT+=svg\nQT+=phonon\nQT+=sql\nQT+=network\nQT+=declarative\nQT+=xml\n" + sRC_FILE + sOBJMOC + sDEFINES + sCPPProFiles;
//     QString sConfig = "CONFIG-=debug\nCONFIG+=warn_off\nCONFIG+=uitools\nQT+=webkit\nQT+=svg\nQT+=phonon\nQT+=sql\nQT+=network\nQT+=declarative\n" + sRC_FILE + sOBJMOC + sDEFINES;
#ifdef Q_OS_MAC
    //sConfig += "\nCONFIG-=ppc\nCONFIG+=x86\nCONFIG-=x86_64\n";
#else
     sConfig += "\nCONFIG+=uitools";
#endif

     


    if (CONFIG["Deploy"] == "true" || CONFIG["CompileItself"] == "true"){

       sConfig += CONFIG["CONFIG"] + "\nCONFIG-=debug\nCONFIG+=release\n";

    } else {

      sConfig += "\nCONFIG+=debug\nCONFIG-=release\n";
    }

    //QString sdfa9z = CONFIG["PROJECTPATH"];
    //QString sdfa9?z = CONFIG["QTDIR"];

    QStringList arguments;
    arguments << "-project";
    arguments << "-nopwd";
    arguments << sFiles;
    arguments << "-o";
    arguments << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + sProjectName + ".pro");
    arguments << sConfig;
#ifdef Q_OS_MAC
    arguments << "\nLIBS+=-framework Carbon\n";
#endif

     //Parser::SaveFile("C:\\Users\\Bernd\\Desktop\\debug3.txt", sFiles.join("\n"), true);
//     Parser::SaveFile("C:\\Users\\Bernd\\Desktop\\debug4.txt", arguments.join("\n"), true);


    //QString sfdsfd = arguments.join(" ");

     QProcess p;
     p.start(program, arguments);

     p.waitForFinished(-1);

     QString s = p.readAllStandardError();

     if (!s.isEmpty()){
       error(s);
       return false;
     }
     

   }
  // .q7basic_project: manually lines can be added to the generated pro file
   //
   {
     QString q7basic_project;
     
     if (QFile::exists(CONFIG["PROJECTPATH"] + "/" + sProjectName + ".q7basic_project")) q7basic_project = LoadFile(CONFIG["PROJECTPATH"] + "/" + sProjectName + ".q7basic_project");

     if (!q7basic_project.isEmpty()){
       q7basic_project = q7basic_project.mid(q7basic_project.indexOf("<key>profile</key>"));
       q7basic_project = q7basic_project.mid(q7basic_project.indexOf("<string>") + 8);
       q7basic_project = q7basic_project.left(q7basic_project.indexOf("</string>"));
     }

     //if (!q7basic_project.isEmpty())
     {
       QString sPRO = LoadFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + sProjectName + ".pro");

       sPRO = sPRO.replace(" ../../../", " # ../../../");

       SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + sProjectName + ".pro", sPRO + "\n" + q7basic_project, false);
     }
   }


            


            if (CONFIG["CompileItself"] == "false"){
              QStringList lll;
              QString sPRO = LoadFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + sProjectName + ".pro");
              int n = sPRO.indexOf("SOURCES");
//QMessageBox::information(0, QString("%1").arg(n), sPRO);

              if (n >= 0){

                int n2 = sPRO.indexOf("\n", n);
                if (n2 == -1) n2 = sPRO.length();

                lll = sPRO.mid(n, n2 - n).split(" ", QString::SkipEmptyParts);
                lll.removeAt(0);
                lll.removeAt(0);
                
               // compiler_nCountDone = 0;

                for (int ii = 0; ii < lll.count(); ii++){
                  QString z = lll.at(ii).trimmed();
                  z = z.replace("/", "");
                  z = z.replace("\\", "");
                  z = z.trimmed();
                  if (z.isEmpty()) continue;

                  QString zz;
                  if (CONFIG["MINGW"].isEmpty()){
                    zz = z.left(z.length() - 4) + ".obj"; // -4 for ".h \"
                  } else {
                    zz = z.left(z.length() - 4) + ".o"; // -4 for ".h \"
                  }


                  if (!QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + CONFIG["BuildReleasePath"] + zz)){
                    compiler_sOBJECTFILES << z;
                  }


                  if (!QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + CONFIG["BuildReleasePath"] + "moc_" + zz)){
                    compiler_sOBJECTFILES << "moc_" + z;
                  }

                  if (CONFIG["MINGW"].isEmpty()){
                  } else {

                    if (!QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + CONFIG["BuildReleasePath"] + "moc_" + z.left(z.length() - 4) + ".cpp")){ // -4 for ".h \"

                      if (!compiler_sOBJECTFILES.contains("moc_" + z)){
                        compiler_sOBJECTFILES << "moc_" + z; 
                      }
                      compiler_sOBJECTFILES << "moc_" + z;
                    }
                  }


                }

              }
              //QMessageBox::information(0, "compiler_Started", QString("'%1'").arg(lll.count()));
              
              Write_To_stdout(QString("OBJECTFILES:%1\n").arg(compiler_sOBJECTFILES.join("||")));
            }

            






    Write_To_stdout("Copy cache pro file, if necessary and build real pro file in /Build...\n");
   
   {


     if (copyIfNeeded(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + sProjectName + ".pro", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".pro", true) || !QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/Makefile")){

          
          {
            QString program = CONFIG["QMAKE"];

            QStringList arguments;
            arguments << "-makefile";
        //    arguments << "-nocache";

            arguments << "-spec";
            arguments << CONFIG["SPEC"];

            arguments << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".pro");
            arguments << "-o";
            arguments << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/Makefile");

            QProcess p;
            p.start(program, arguments);

            p.waitForFinished(-1);

            QString s = p.readAllStandardError();

            if (!s.isEmpty()){
              error(s);
              return false;
            }

            
            #ifdef Q_OS_WIN32
            if (CONFIG["CompileItself"] != "true" && CONFIG["MINGW"].isEmpty()){
              QString ss = " $$$$/Qt/4.8.0/lib/qtmaind.lib $$$$/Qt/4.8.0/lib/QtDeclaratived4.lib $$$$/Qt/4.8.0/lib/QtWebKitd4.lib $$$$/Qt/4.8.0/lib/phonond4.lib $$$$/Qt/4.8.0/lib/QtSvgd4.lib $$$$/Qt/4.8.0/lib/QtSqld4.lib $$$$/Qt/4.8.0/lib/QtXmld4.lib $$$$/Qt/4.8.0/lib/QtGuid4.lib $$$$/Qt/4.8.0/lib/QtNetworkd4.lib $$$$/Qt/4.8.0/lib/QtCored4.lib $$$$/Qt/4.8.0/lib/QtUiToolsd.lib";
              ss = ss.replace("$$$$", qApp->applicationDirPath());

              QString ss2 = " $$$$/Qt/4.8.0/lib/qtmain.lib $$$$/Qt/4.8.0/lib/QtDeclarative4.lib $$$$/Qt/4.8.0/lib/QtWebKit4.lib $$$$/Qt/4.8.0/lib/phonon4.lib $$$$/Qt/4.8.0/lib/QtSvg4.lib $$$$/Qt/4.8.0/lib/QtSql4.lib $$$$/Qt/4.8.0/lib/QtXml4.lib $$$$/Qt/4.8.0/lib/QtGui4.lib $$$$/Qt/4.8.0/lib/QtNetwork4.lib $$$$/Qt/4.8.0/lib/QtCore4.lib $$$$/Qt/4.8.0/lib/QtUiTools.lib";
              ss2 = ss2.replace("$$$$", qApp->applicationDirPath());

              {
                QString s = LoadFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/Makefile.Debug");
                int n = s.indexOf("\nLIBS");
                n = s.indexOf("=", n) + 1;
                int n2 = s.indexOf("\n", n); 
                ss = ss.replace("/", "\\");
                s = s.replace(n, n2 - n, ss);
                SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/Makefile.Debug", s, false);         
              }

              {
                QString s = LoadFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/Makefile.Release");
                int n = s.indexOf("\nLIBS");
                n = s.indexOf("=", n) + 1;
                int n2 = s.indexOf("\n", n); 
                ss2 = ss2.replace("/", "\\");
                s = s.replace(n, n2 - n, ss2);
                SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/Makefile.Release", s, false);              
              }

            }
            #endif

          }

      }

   }

     #ifdef Q_OS_WIN32
     //if (CONFIG["CompileItself"] == "true") // TODO
     {


          
          if (CONFIG["MINGW"].isEmpty()){
            QString program = CONFIG["QMAKE"];

            QStringList arguments;

            arguments << "-spec";
            arguments << CONFIG["SPEC"];

            arguments << "-t";
            arguments << "vcapp";


            arguments << "-o";
            arguments << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".vcproj");

            arguments << (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".pro");

            QProcess p;
            p.start(program, arguments);

            p.waitForFinished(-1);

            QString s = p.readAllStandardError();

            if (!s.isEmpty()){
              error(s);
              return false;
            }


          }

     }
     #endif
  
#ifdef Q_OS_WIN32
  {
    //QString sPath9;
    if (CONFIG["CompileItself"] == "true"){

      QDir d;

      if (!d.exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/MySQL")) copyDir(CONFIG["RuntimePath"] + "/Windows/MySQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/MySQL", false);
      if (!d.exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/PostgreSQL")) copyDir(CONFIG["RuntimePath"] + "/Windows/PostgreSQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/PostgreSQL", false);
      if (!d.exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/vs")) copyDir(CONFIG["RuntimePath"] + "/Windows/vs", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/vs", false);
      if (!d.exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/mingw")) copyDir(CONFIG["RuntimePath"] + "/Windows/mingw", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/mingw", false);
      if (!d.exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/designer")) copyDir(CONFIG["RuntimePath"] + "/Windows/vs", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", false);

      copyDir(CONFIG["RuntimePath"] + "/Windows/MySQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", false); 
      copyDir(CONFIG["RuntimePath"] + "/Windows/PostgreSQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", false); 
      copyDir(CONFIG["RuntimePath"] + "/Windows/vs", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", false);
      //copyDir(CONFIG["RuntimePath"] + "/Windows/vs_debug", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", false);

     // sPath9 = CONFIG["RuntimePath"] + "/Windows/";


    //  SaveFile(CONFIG["RuntimePath"] + "/qtversion.txt", qVersion());

    } else if (CONFIG["Deploy"] == "true" || (CONFIG["CompileItself"] == "true")){ 
      Write_To_stdout("Copy all needed dll files...\n");

      copyDir(qApp->applicationDirPath() + "/MySQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);
      copyDir(qApp->applicationDirPath() + "/PostgreSQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);



      bool bCopyFilesEvenExists = true;
      QStringList ignoreFilter = QStringList();
      bool bFirst = true;
      QString sFilter1 = "d4.dll";
      QString sFilter2;

      if (CONFIG["MINGW"].isEmpty()){
        

        copyDir(qApp->applicationDirPath() + "/vs", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug, bCopyFilesEvenExists, ignoreFilter, bFirst, sFilter1, sFilter2);

        

      } else {
        
        copyDir(qApp->applicationDirPath() + "/mingw", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug, bCopyFilesEvenExists, ignoreFilter, bFirst, sFilter1, sFilter2);

        

      }
      //sPath9 = qApp->applicationDirPath() + "/";
    } else {
        
    
        if (!CONFIG["MINGW"].isEmpty()){
          copyDir(qApp->applicationDirPath() + "/mingw/plugins", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/debug/plugins");

          
          copyDir(qApp->applicationDirPath() + "/MySQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);
          copyDir(qApp->applicationDirPath() + "/PostgreSQL", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);

        } else {
          copyDir(qApp->applicationDirPath() + "/vs/plugins", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/debug/plugins");
        }
    }

    

    //copyIfNeeded("C:/Users/Bernd/Desktop/objb/QtBasicRuntime/q7bplugins/release/q7bplugins.dll", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/q7bplugins.dll");
  }


#endif

  Write_To_stdout("Launch make (C++ compiler)...\n");
  
  {
#ifdef Q_OS_WIN32
    QString program;
    QStringList arguments;

     if (CONFIG["MINGW"].isEmpty()){
       QString sss = LoadFile(CONFIG["VC"] + "\\vcvarsall.bat");

       sss = sss.replace(".bat\" goto", "!?$%&/()=?");

       if (CONFIG["Deploy"] == "true" ||CONFIG["CompileItself"] == "true"){

         sss = sss.replace(".bat\"", ".bat\"\nnmake /C /F \"" + CONFIG["PROJECTPATH"] + "/gcc/Build/Makefile.Release\"");

       } else {

        sss = sss.replace(".bat\"", ".bat\"\nnmake /C /F \"" + CONFIG["PROJECTPATH"] + "/gcc/Build/Makefile.Debug\"");
       }       

       sss = sss.replace("!?$%&/()=?", ".bat\" goto");
       sss = sss.replace("%~dp0bin", CONFIG["VC"] + "\\bin");


       SaveFile(CONFIG["PROJECTPATH"] + "/gcc/Build/q7bmake.bat", sss, false);
       program = CONFIG["PROJECTPATH"] + "/gcc/Build/q7bmake.bat";

       arguments << "x86";
     } else {
    //   QString tz = CONFIG["QTDIR"];
       QString sMake = CONFIG["QTDIR"].left(CONFIG["QTDIR"].indexOf("QtSDK") + 5);
       program = sMake + "/mingw/bin/mingw32-make.exe";
       arguments << "PATH=" + sMake + "/mingw/bin";


     }

#elif defined Q_OS_MAC
     QString program = "/usr/bin/make";
     QStringList arguments;

#elif defined Q_OS_X11
     QString program = "/usr/bin/make";
    QStringList arguments;


#endif



    QString s;



      if (CONFIG["CompileItself"] == "false"){
        QObject::connect(&make->p, SIGNAL(readyReadStandardOutput()), make, SLOT(readyReadStandardOutput()));
      }

     
      make->p.setWorkingDirectory(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build");
      make->p.start(program, arguments);

      make->p.waitForStarted(-1);

     


      if (CONFIG["CompileItself"] == "false"){
        
        while(make->p.state() == QProcess::Running){ qApp->processEvents(); }
#ifdef Q_OS_WIN
        QMap<QString, qint64> pids = getPids();
        QStringList lkeys = pids.keys();

        for (int ooi = 0; ooi < lkeys.size(); ++ooi){
          QString weg = lkeys.at(ooi);

          if (CONFIG["MINGW"].isEmpty()){
            if (weg.contains("nmake")){
              KillProcessTree(pids[weg], 0);
            }
          } else {
            if (weg.contains("mingw32-make")){
              KillProcessTree(pids[weg], 0);
            }
          }

        }
#endif

      } else {
        make->p.waitForFinished(-1);
        
      }


      

      s = make->p.readAllStandardError().trimmed();
//QString sk9s = make->p.readAllStandardOutput();


    if (!s.isEmpty()){
      


       if (CONFIG["CompileItself"] == "true"){
        QString sks = make->p.readAllStandardOutput();

        if (!sks.isEmpty() && (!sks.contains("/MANIFEST /MANIFESTFILE:") && !sks.contains("error LNK") && !sks.contains("error LNK") || sks.contains("unresolved externals"))){
          if (sks.indexOf("error")){
            int n = sks.indexOf("error") - 30;
            if (n < 0) n = 0;
            sks = sks.mid(sks.indexOf("error"));
            error(sks);
            return false;
          }

        }
      } else {
        error(s);
      }


    }


      make->p.terminate();
      make->p.kill();
      make->p.close();


  }

    // copy "copy directory"
    {

       if (CONFIG["CompileItself"] == "true"){
         copyIfNeeded(sCopyRuntimeFromPath + "Q7BRuntime.cpp", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release" + "/Q7BRuntime.cpp");
         copyIfNeeded(sCopyRuntimeFromPath + "Q7BRuntime.h", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release" + "/Q7BRuntime.h");


            #ifdef Q_OS_WIN32
              copyDir(CONFIG["PROJECTPATH"] + "/CopyWindows", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", true);
              copyDir(CONFIG["PROJECTPATH"] + "/CopyAll", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release", true);

            #elif defined Q_OS_MAC
              copyDir(CONFIG["PROJECTPATH"] + "/CopyMac", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS", true);
              copyDir(CONFIG["PROJECTPATH"] + "/CopyAll", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS", true);
            #elif defined Q_OS_X11
              copyDir(CONFIG["PROJECTPATH"] + "/CopyLinux", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build", true);
              copyDir(CONFIG["PROJECTPATH"] + "/CopyAll", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build", true);
           #endif
       } else {


           QFile f;
           QFile f2;

            #ifdef Q_OS_WIN32
              f.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug + sQ7BRuntimeObjectFileName);
              f2.setFileName(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
              if (QDir().exists(CONFIG["PROJECTPATH"] + "/Copy")) copyDir(CONFIG["PROJECTPATH"] + "/Copy", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);
            #elif defined Q_OS_MAC
              f.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + sQ7BRuntimeObjectFileName);
//              f.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS" + sQ7BRuntimeObjectFileName);
              f2.setFileName(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
              if (QDir().exists(CONFIG["PROJECTPATH"] + "/Copy")) copyDir(CONFIG["PROJECTPATH"] + "/Copy", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS");
            #elif defined Q_OS_X11
              f.setFileName(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build" + sQ7BRuntimeObjectFileName);
              f2.setFileName(qApp->applicationDirPath() + sQ7BRuntimeObjectFileName);
              if (QDir().exists(CONFIG["PROJECTPATH"] + "/Copy")) copyDir(CONFIG["PROJECTPATH"] + "/Copy", CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build");
            #endif

           f2.remove();
           QFile::copy(f.fileName(), f2.fileName()); 

      }
    }

#ifdef Q_OS_MAC
    //QString sTarget = QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName).replace(" ", "\\ ");
    if (CONFIG["CompileItself"] == "true"){
      copyDir(CONFIG["RuntimePath"] + "/Mac/MySQL", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/MacOS/MySQL", false);
      copyDir(CONFIG["RuntimePath"] + "/Mac/PostgreSQL", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/MacOS/PostgreSQL", false);
      copyDir(CONFIG["RuntimePath"] + "/Mac/Frameworks", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/Frameworks", false);
      copyDir(CONFIG["RuntimePath"] + "/Mac/PlugIns", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/PlugIns", false);
    } else {
      copyDir(qApp->applicationDirPath() + "/MySQL", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/Frameworks/MySQL");
      copyDir(qApp->applicationDirPath() + "/PostgreSQL", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/Frameworks/PostgreSQL");
      copyDir(qApp->applicationDirPath() + "/Frameworks", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/Frameworks");
      copyDir(qApp->applicationDirPath() + "/plugins", QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/PlugIns");
    }


    if (!QFile::exists(QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/MacOS/plugins")){
      QStringList lll;
      lll << "-s";
      lll << CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/PlugIns";
      lll << CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS/plugins";

       QProcess::execute("ln", lll);
       //QProcess::execute(QString(QString("ln") + " -s " + (sTarget + ".app/Contents/PlugIns") + " " + (sTarget + ".app/Contents/MacOS/plugins")));
    }

    if (CONFIG["CompileItself"] == "true"){
        if (!QFile::exists(QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName) + ".app/Contents/MacOS/Frameworks")){
           QProcess::execute(QString(QString("ln") + " -s " + (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/Frameworks") + " " + (CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS/Frameworks")));
        }
    }

    if (CONFIG["CompileItself"] == "false"){
      QStringList frameworks; frameworks << "QtCore" << "QtWebKit" << "QtDeclarative" << "QtXmlPatterns" << "phonon" << "QtSvg" << "QtSql" << "QtXml" << "QtGui" << "QtNetwork" << "QtDBus" << "QtScript";

      for (int ooi = 0; ooi < frameworks.size(); ++ooi){
        QString ru = frameworks.at(ooi);

      QStringList lll;
      lll << "-change";
      lll << CONFIG["QTDIR"] + "/lib/" + ru + ".framework/Versions/4/" + ru;
      lll << "@executable_path/../Frameworks/" + ru + ".framework/Versions/4/" + ru;
      lll << CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS/" + sProjectName;

       QProcess::execute("install_name_tool", lll);

      { 
        QStringList lll;
        lll << "-change";
        lll << ru + ".framework/Versions/4/" + ru;
        lll << "@executable_path/../Frameworks/" + ru + ".framework/Versions/4/" + ru;
        lll << CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS/" + sProjectName;

        QProcess::execute("install_name_tool", lll);
      }


       // QString sdf = QString(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sProjectName + ".app/Contents/MacOS/" + sProjectName).replace(" ", "\\ ");
      //  QProcess::execute(QString("install_name_tool -change " + ru + ".framework/Versions/4/" + ru + " @executable_path/../Frameworks/" + ru + ".framework/Versions/4/" + ru + " " + sdf));
      }

    }
#endif

      if (CONFIG["CompileItself"] == "false"){

        
        Write_To_stdout("Q7BFinished");

        if (CONFIG["Deploy"] == "true"){

    #ifdef Q_OS_WIN32 
         QDir directory = QDir(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug);
         QStringList l; l << "*.cpp" << "*.obj" << "*.o";
         QStringList filesToRemove = directory.entryList(l, QDir::Files | QDir::NoSymLinks);
         for (int i = 0; i < filesToRemove.size(); i++){
           QFile::remove(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/" + sPathReleaseOrDebug + "/" + filesToRemove.at(i));
         }
//         QDesktopServices::openUrl( QUrl("file:///" + CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/release/") );
    #else
         //QDesktopServices::openUrl( QUrl("file:///" + CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Build/") );
    #endif


        }
      }



      return true;

}

void MakeInterface::directoryChanged(const QString  & path)
{
   if (QFile::exists(qApp->applicationDirPath() + "/stop.txt")){

    QString s;
    QFile f(qApp->applicationDirPath() + "/stop.txt");
    if (!f.open(QIODevice::ReadOnly)){
    } else {
      QTextStream t(&f);
      s = t.readAll();
      f.close();
    }

    // QMessageBox::information(0, "", QString("%1\n%2 ").arg(s.toLongLong()).arg(qApp->applicationPid()));

     if (s.toLongLong() == qApp->applicationPid()){
      QFile::remove(qApp->applicationDirPath() + "/stop.txt");

      make->p.close();
     }
   }
}

bool Parser::isFileSuperClassValid(QString s)
{
  bool b = Me.classes.contains(getClassName(s)) || Me.Classes.contains(getClassName(s));
  if (b == false){
    b = b;
  }
  return b;
};






#include "_Q7BCompiler.h"



#define COMMENT ; Parser::doComment(CLASS,SUPERCLASS,SUBFUNCTION,lAlias,sType,l,sGROUP,sSEEALSO,sCOMMENT,sCLASSCOMMENT,sEXAMPLE,bProperty,bEvent,bSignal,bDelegate,Me.comments_classes, Me.classes_properties,Me.classes_subsfunctions, Me.classes_events, Me.classes_signals, Me.classes_delegates, Me.classes_declare_events_signals_delegates, Me.classes_declarecast_events_signals_delegates, Me.classes_declarecode_events_signals_delegates, Me.classes_declaretype_events_signals_delegates, sDeclare, sCast, sCode);Me.comments_classes[CLASS][SUBFUNCTION]._COMMENT



#define CLASSCOMMENT ;Me.comments_classes[CLASS][""]._COMMENT

#define Property ;bProperty=true;sDeclare="";SUBFUNCTION=
#define Function ;sType="";sDeclare="";SUBFUNCTION=
#define Sub ;sType="";sDeclare="";SUBFUNCTION=
#define Slot ;sType="";sDeclare="";SUBFUNCTION=
#define Event ;bEvent=true;sType="";sDeclare="";SUBFUNCTION=
#define Signal ;bSignal=true;sType="";sDeclare="";SUBFUNCTION=
#define Delegate ;bDelegate=true;sType="";sDeclare="";SUBFUNCTION=

#define As ;sType=

#define Declare ;sCast="";sCode="";sDeclare=
#define Cast ;sCast=
#define Code ;sCode=

#define Class ;SUPERCLASS="";CLASS=
#define SuperClass ;SUPERCLASS=

#define End_Class ;Me.classes[CLASS]=SUPERCLASS;

#define SEEALSO ;sSEEALSO
#define EXAMPLE ;sEXAMPLE



#define ___ ;l<<Parser::SubFunction
#define As ;sType=
#define Alias ;lAlias<<





void Parser::CreateListOfClasses()
{      
  QString CLASS;
  QString SUPERCLASS;
  QString SUBFUNCTION;
  QStringList lAlias; 
  QString sType;
  QString sDeclare;
  QString sCast;  
  QString sCode;
  QStringList l;

  QString sGROUP;
  QString sSEEALSO;
  QString sCOMMENT;
  QString sEXAMPLE;
  QString sCLASSCOMMENT;  

  bool bProperty = false;
  bool bEvent = false;
  bool bSignal = false;
  bool bDelegate = false;

  

  if (Me.classes_properties.size() == 0){    
    

    




    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QObject" 
  
      Property "ObjectName" As "String";    COMMENT = "";
      Property "Parent" As "QObject";    COMMENT = "";

      Function "Sender"___("") As "QObject";  COMMENT = "";
      Function "Child"___("ObjectName As String") As "QObject";  COMMENT = "";
      Function "Children"___("") As "List";  COMMENT = "";
      Function "Inherits"___("ClassName As String") As "Boolean";  COMMENT = "";
      Function "isWidgetType"___("") As "Boolean";  COMMENT = "";

      Sub "killTimer"___("theId As Integer");  COMMENT = "";
      Function "startTimer"___("interval As Integer") As "Integer";  COMMENT = "";
      Event "timerEvent"___("e As QTimerEvent") Declare "void	timerEvent(QTimerEvent * e)"   COMMENT = "";
       
      Event "Init"___("") Declare ""   COMMENT = "";
      Event "Finalize"___("") Declare ""   COMMENT = "";

    End_Class

    

    Class "QAction" SuperClass "QObject"
  
      Property "Visible" As "Boolean";    COMMENT = "";
      Property "Enabled" As "Boolean";    COMMENT = "";
      Property "Checkable" As "Boolean";    COMMENT = "";
      Property "Checked" As "Boolean";    COMMENT = "";
      Property "Text" As "String";    COMMENT = "";
      Property "Tag" As "String";    COMMENT = "";
      Property "Icon" As "QIcon";    COMMENT = "";

      Sub      "SetNextState"___("");  COMMENT = "";
      Sub      "Highlight"___("Argument As Boolean");  COMMENT = "Marks the button to be lit.";

      Signal "triggered"___("Checked As Boolean") Declare "void triggered(bool Checked)"   COMMENT = "";
      Signal "triggeredAction"___("Action As QAction") Declare "void triggered(QAction *Action)"   COMMENT = "";

    End_Class

    

    Class "Dictionary"
  
      Function "Contains"___("Key As String") As "Boolean";  COMMENT = "";
      Function "Length"___("") As "Integer";  COMMENT = "";
      Sub      "RemoveAll"___("");  COMMENT = "";
      Function "Keys"___("") As "List";  COMMENT = "";
      Function "Values"___("") As "List";  COMMENT = "";

      Sub      "Remove"___("Key As String");  COMMENT = "";
      Function "Object"___("Key As String") As "id";  COMMENT = "";
 
      Sub      "SetObject"___("Key As String, Argument As id");  COMMENT = ""; 
 
    End_Class

    

    Class "QWidget" SuperClass "QObject"
  
      Property "MinimumWidth" As "Integer";    COMMENT = "";
      Property "MaximumWidth" As "Integer";    COMMENT = "";
      Property "Visible" As "Boolean";    COMMENT = "";
      Property "Enabled" As "Boolean";    COMMENT = "";
      Property "WindowTitle" As "String";    COMMENT = "";
      Property "WindowIcon" As "QIcon";    COMMENT = "";
      Property "WindowFlags" As "Integer";    COMMENT = "";
      Property "ContextMenuPolicy" As "Integer";    COMMENT = "";

      Function "Widget"___("ObjectName As String") As "QWidget";  COMMENT = "";

      Function "Actions"___("") As "List";  COMMENT = "Returns actions which are owned by this widget.";
      Sub      "ShowFullScreen"___("");  COMMENT = "";
      Sub      "ShowMaximized"___("");  COMMENT = "";
      Sub      "ShowMinimized"___("");  COMMENT = "";
      Sub      "ShowNormal"___("");  COMMENT = "";
      Sub      "Show"___("");  COMMENT = "";
      Sub      "Hide"___("");  COMMENT = "";
      Sub      "ToggleVisible"___("");  COMMENT = "";
      Sub      "SetAttribute"___("Attribute As Integer, On As Boolean");  COMMENT = "";
      Sub      "SetParent"___("w As QWidget");  COMMENT = "";

      Event "CloseEvent"___("e As QCloseEvent") Declare "void closeEvent(QCloseEvent *e)"   COMMENT = "";
      Event "FocusInEvent"___("e As QFocusInEvent") Declare "void focusInEvent(QCloseEvent *e)"   COMMENT = "";
      Event "ResizeEvent"___("e As QResizeEvent") Declare "void resizeEvent(QResizeEvent *e)"   COMMENT = "";
      Event "PaintEvent"___("e As QResizeEvent") Declare "void paintEvent(QPaintEvent *e)"   COMMENT = "";

    End_Class

    

    Class "List"
      
      Function "toQStringList"___("") As "QStringList";  COMMENT = "";
      Sub "fromQStringList"___("");  COMMENT = "";

      Function "Length"___("") As "Integer";  COMMENT = "";
      Sub      "RemoveAll"___("");  COMMENT = "";

      Sub      "Append"___("Argument As id");  COMMENT = "";
      Function "Object"___("Index As Integer") As "id";  COMMENT = "";
      Sub      "Remove"___("Index As Integer");  COMMENT = "";
      Sub      "Insert"___("Index As Integer, Argument As id");  COMMENT = "";
      Sub      "SetObject"___("Index As Integer, Argument As id");  COMMENT = "";
 
    End_Class     

    

    Class "QIcon"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QMenu" SuperClass "QWidget"
  
      Sub      "Clear"___("");  COMMENT = "";
      Function "AddSeparator"___("") As "QAction";  COMMENT = "";
      Function "AddAction"___("Text As String") As "QAction";  COMMENT = "";
      Sub      "AddAction2"___("theAction As QAction")  COMMENT = "";
      Function "AddMenu"___("Text As String") As "QMenu";  COMMENT = "";
  
      Signal "aboutToShow"___("") Declare "void aboutToShow()"   COMMENT = "";
      Signal "triggered"___("Action As QAction") Declare "void triggered(QAction *Action)"   COMMENT = "";

    End_Class

    

    Class "QMenuBar" SuperClass "QWidget"

      Signal "hovered"___("action As QAction") Declare "void hovered(QAction *action)"   COMMENT = "";
      Signal "triggered"___("action As QAction") Declare "void triggered(QAction *action)"   COMMENT = "";
  
    End_Class

    

    Class "QGraphicsView" SuperClass "QAbstractScrollArea"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QDeclarativeView" SuperClass "QGraphicsView"
  
	    Property "resizeMode" As "QDeclarativeView::ResizeMode";	COMMENT = "";
	    Property "source" As "QUrl";	COMMENT = "";
	    Property "status" As "QDeclarativeView::Status";	COMMENT = "";

	    Function "initialSize"___("") As "QSize";	COMMENT = "";
	    Function "resizeMode"___("") As "QDeclarativeView::ResizeMode";	COMMENT = "";
	    Function "rootContext"___("") As "QDeclarativeContext";	COMMENT = "";
	    Function "rootObject"___("") As "QGraphicsObject";	COMMENT = "";
	    Sub "setResizeMode"___("Mode As QDeclarativeView::ResizeMode");	COMMENT = "";
	    Sub "setSource"___("Url As QUrl");	COMMENT = "";
	    Function "source"___("") As "QUrl";	COMMENT = "";
	    Function "status"___("") As "QDeclarativeView::Status";	COMMENT = "";

	    Signal "sceneResized"___("Size As QSize") Declare "void sceneResized(QSize size)"	COMMENT = "";
	    Signal "statusChanged"___("Status As QDeclarativeView::Status") Declare "void statusChanged(QDeclarativeView::Status status)"	COMMENT = "";

    End_Class

    

    Class "QDeclarativeContext" //SuperClass "QObject"
  
	    Function "baseUrl"___("") As "QUrl";	COMMENT = "";
	    Function "contextObject"___("") As "QObject";	COMMENT = "";
	    Function "contextProperty"___("Name As String") As "QVariant";	COMMENT = "";
	    Function "isValid"___("") As "Boolean";	COMMENT = "";
	    Function "parentContext"___("") As "QDeclarativeContext ";	COMMENT = "";
	    Function "resolvedUrl"___("Src As QUrl") As "QUrl";	COMMENT = "";

    End_Class

    

    Class "QPrinterInfo"
  
	    Function "isDefault"___("") As "Boolean";	COMMENT = "";
	    Function "isNull"___("") As "Boolean";	COMMENT = "";
	    Function "printerName"___("") As "String";	COMMENT = "";
	    //Function "supportedPaperSizes"___("") As "List";	COMMENT = "";

      
	    Function "availablePrinters"___("") As "List";	COMMENT = "";
	    Function "defaultPrinter"___("") As "QPrinterInfo";	COMMENT = "";

    End_Class

    

    Class "QWebView" SuperClass "QWidget"
  
      Sub      "Load"___("URL As String");  COMMENT = "";
      Sub      "SetHtml"___("Html As String");  COMMENT = "";
  
      Signal "loadFinished"___("Ok As Boolean") Declare "void loadFinished(bool Ok)"   COMMENT = "";
      Signal "urlChangedAsString"___("URL As String") Declare "void urlChanged(const QUrl & URL)" Cast "Q7B_ID(URL.toString())"  COMMENT = "";
  
    End_Class

    

    Class "QBoxLayout" SuperClass "QLayout"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QVBoxLayout" SuperClass "QBoxLayout"
  
    End_Class

    

    Class "QHBoxLayout" SuperClass "QBoxLayout"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QGridLayout" SuperClass "QLayout"
  
    End_Class

    

    Class "QFormLayout" SuperClass "QLayout"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QTabWidget" SuperClass "QWidget"

	  Property "CurrentIndex" As "Integer";    COMMENT = "";

      Function "Count"___("") As "Integer";  COMMENT = "";
      Function "Widget"___("Index As Integer") As "QWidget";  COMMENT = "";

    End_Class

    

    Class "QTableView" SuperClass "QAbstractItemView"
  
      Sub      "SetColumnWidth"___("Column As Integer, Width As Integer");  COMMENT = "";

    End_Class

    

    Class "QTableWidget" SuperClass "QTableView"
  
      Property "RowCount" As "Integer";    COMMENT = "";
      Property "ColumnCount" As "Integer";    COMMENT = "";

      Sub      "ClearContents"___("");  COMMENT = "";
      Sub      "SetHorizontalHeaderAutoResize"___("");  COMMENT = "";

      Function "CurrentRow"___("") As "Integer";  COMMENT = "";
      Sub      "SortItems"___("Column As Integer");  COMMENT = "";
      Sub      "RemoveRow"___("Row As Integer");  COMMENT = "";
      Sub      "SetCurrentCell"___("Row As Integer, Column As Integer");  COMMENT = "";
      Function "ItemText"___("Row As Integer, Column As Integer") As "String";  COMMENT = "";
      Function "ItemSelected"___("Row As Integer, Column As Integer") As "Boolean";  COMMENT = "";
      Function "ItemCheckState"___("Row As Integer, Column As Integer") As "Integer";  COMMENT = "";
      Sub      "SetItemFontBold"___("Row As Integer, Column As Integer, Yes As Boolean");  COMMENT = "";
      Sub      "SetItemsText"___("Row As Integer, Column As Integer, TextItems As List");  COMMENT = "";
  
      Sub      "SetItemText"___("Row As Integer, Column As Integer, Text As String");  COMMENT = "";
      Sub      "SetItemFlags"___("Row As Integer, Column As Integer, Flags As Integer");  COMMENT = "";
      Sub      "SetItemSelected"___("Row As Integer, Column As Integer, Yes As Boolean");  COMMENT = "";
      Sub      "SetItemCheckState"___("Row As Integer, Column As Integer, CheckState As Integer");  COMMENT = "";

      Function "FindItemInColumn"___("Text As String, Column As Integer, StartRow As Integer = 0, MatchFlags As Integer = QTableWidget.MatchExactly") As "Integer";  COMMENT = "";
      Function "FindItemInRow"___("Text As String, Row As Integer, StartColumn As Integer = 0, MatchFlags As Integer = QTableWidget.MatchExactly") As "Integer";  COMMENT = "";

    End_Class

    

    Class "QGroupBox" SuperClass "QWidget"
  
      Property "Caption" As "String";    COMMENT = "";
      Property "Text" As "String";    COMMENT = "";

    End_Class

    

    Class "QToolBox" SuperClass "QFrame"
  
      Property "CurrentIndex" As "Integer";    COMMENT = "";

    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------


    

    Class "QStackedWidget" SuperClass "QFrame"
  
      Property "CurrentIndex" As "Integer";    COMMENT = "";

    End_Class

    

    Class "QTextEdit" SuperClass "QAbstractScrollArea"
  
      Property "Html" As "String";    COMMENT = "";
      Sub      "Print"___("");  COMMENT = "";
      Sub      "PrintToPDF"___("FileName As String");  COMMENT = "";      

      Signal "cursorPositionChanged"___("") Declare "void cursorPositionChanged()"   COMMENT = "";
      Signal "textChanged"___("") Declare "void textChanged()"   COMMENT = "";
      Signal "copyAvailable"___("Yes As Boolean") Declare "void copyAvailable(bool yes)"   COMMENT = "";
      Signal "redoAvailable"___("Yes As Boolean") Declare "void redoAvailable(bool yes)"   COMMENT = "";
      Signal "undoAvailable"___("Yes As Boolean") Declare "void undoAvailable(bool yes)"   COMMENT = "";
      Signal "selectionChanged"___("") Declare "void selectionChanged()"   COMMENT = "";
  
    End_Class

    

    Class "QPlainTextEdit" SuperClass "QAbstractScrollArea"
  
      Property "PlainText" As "String";    COMMENT = "";
      Property "ReadOnly" As "Boolean";    COMMENT = "";

      Sub      "AppendPlainText"___("Text As String")   COMMENT = "";
      Sub      "Print"___("");  COMMENT = "";
      Sub      "PrintToPDF"___("FileName As String");  COMMENT = "";      

      Signal "selectionChanged"___("") Declare "void selectionChanged()"   COMMENT = "";
      Signal "redoAvailable"___("Yes As Boolean") Declare "void redoAvailable(bool yes)"   COMMENT = "";
      Signal "undoAvailable"___("Yes As Boolean") Declare "void undoAvailable(bool yes)"   COMMENT = "";
      Signal "modificationChanged"___("Yes As Boolean") Declare "void modificationChanged(bool yes)"   COMMENT = "";
      Signal "blockCountChanged"___("newBlockCount As Integer") Declare "void blockCountChanged(int newBlockCount)"   COMMENT = "";

    End_Class

    

    Class "QDockWidget" SuperClass "QWidget"
  
      Property "WindowTitle" As "String";    COMMENT = "";

      Function "Widget"___("") As "QWidget";   COMMENT = "";

    End_Class

    

    Class "uiClass" SuperClass "QWidget"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "FormClass" SuperClass "QWidget"
  
    End_Class

    

    Class "QLineEdit" SuperClass "QWidget"
  
      Property "Text" As "String";    COMMENT = "";
      Property "Alignment" As "Integer";    COMMENT = "";
      Property "EchoMode" As "Integer";    COMMENT = "";
      Property "InputMask" As "String";    COMMENT = "";
      Property "ReadOnly" As "Boolean";    COMMENT = "";
      Property "ValidatorFloat" As "Boolean";    COMMENT = "";
      Property "ValidatorInteger" As "Boolean";    COMMENT = "";
      Property "Maximum" As "Integer";    COMMENT = "";
      Property "Completer" As "List";    COMMENT = "";

      Function "IsValid"___("") As "Boolean";   COMMENT = "";
      Sub      "SelectAll"___("");   COMMENT = "";

      Signal "selectionChanged"___("") Declare "void selectionChanged()"   COMMENT = "";
      Signal "editingFinished"___("") Declare "void editingFinished()"   COMMENT = "";
      Signal "returnPressed"___("") Declare "void returnPressed()"   COMMENT = "";
      Signal "cursorPositionChanged"___("OldPosition As Integer, NewPosition As Integer") Declare "void cursorPositionChanged(int OldPosition, int NewPosition)"   COMMENT = "";
      Signal "textChanged"___("Text As String") Declare "void textChanged(const QString & Text)"   COMMENT = "";
      Signal "textEdited"___("Text As String") Declare "void textEdited(const QString & Text)"   COMMENT = "";

    End_Class

    

    Class "Class" SuperClass "QObject"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "Module" SuperClass "QObject"
  
    End_Class

    

    Class "QSpinBox" SuperClass "QAbstractSpinBox"
  
      Property "Value" As "Integer";    COMMENT = "";
      Property "Minimum" As "Integer";    COMMENT = "";
      Property "Maximum" As "Integer";    COMMENT = "";

    End_Class

    

    Class "PhononVideoPlayer" SuperClass "QWidget"
  
      Sub      "Play"___("FileName As String");   COMMENT = "";

    End_Class

    

    Class "PhononSeekSlider" SuperClass "QWidget"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "PhononVolumeSlider" SuperClass "QWidget"
  
    End_Class

    

    Class "QDoubleSpinBox" SuperClass "QAbstractSpinBox"
  
      Property "Value" As "Float";    COMMENT = "";
      Property "Minimum" As "Float";    COMMENT = "";
      Property "Maximum" As "Float";    COMMENT = "";

    End_Class

    

    Class "QDateEdit" SuperClass "QDateTimeEdit"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QScrollBar" SuperClass "QAbstractSlider"
  
    End_Class

    

    Class "QLabel" SuperClass "QFrame"
  
      Property "Text" As "String";    COMMENT = "";
      Property "OpenExternalLinks" As "Boolean";    COMMENT = "";
      Property "WordWrap" As "Boolean";    COMMENT = "";
      Property "ScaledContents" As "Boolean";    COMMENT = "";
      Property "Alignment" As "Integer";    COMMENT = "";
      Property "TextInteractionFlags" As "Integer";    COMMENT = "";

     // Sub      "testit"___("");   COMMENT = "";
      
    End_Class

    

    Class "QProgressBar" SuperClass "QWidget"
  
      Property "Value" As "Integer";    COMMENT = "";
      Property "Minimum" As "Integer";    COMMENT = "";
      Property "Maximum" As "Integer";    COMMENT = "";
      Property "TextVisible" As "Boolean";    COMMENT = "";

    End_Class

    

    Class "QMdiArea" SuperClass "QAbstractScrollArea"
  
      Property "ViewMode" As "Integer";    COMMENT = "";

      Sub      "AddSubWindow"___("Widget As QWidget");   COMMENT = "";
      
      Signal "GotFocusMDI"___("theWidget As QWidget") Declare "void subWindowActivated(QMdiSubWindow * window)" Cast "window ? Q7B_ID(window->widget()) : Q7B_IDNIL()"  COMMENT = "";

    End_Class

    

    Class "QShowEvent" SuperClass "QEvent"

    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QStatusTipEvent" SuperClass "QEvent"

	    Function "tip"___("") As "String";	COMMENT = "";

    End_Class

    

    Class "QTimerEvent" SuperClass "QEvent"

    	Function "timerId"___("") As "Integer";	COMMENT = "";

    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QWhatsThisClickedEvent" SuperClass "QEvent"

    	Function "href"___("") As "String";	COMMENT = "";

    End_Class

    

    Class "QWindowStateChangeEvent" SuperClass "QEvent"

    	Function "oldState"___("") As "Qt::WindowStates";	COMMENT = "";

    End_Class

    

    Class "QByteArray" 

	    Function "append"___("Ba As QByteArray") As "QByteArray";	COMMENT = "";
	    Function "append2"___("Str As String") As "QByteArray";	COMMENT = "";
	    Function "at"___("I As Integer") As "String";	COMMENT = "";
	    Function "capacity"___("") As "Integer";	COMMENT = "";
	    Sub "chop"___("N As Integer");	COMMENT = "";
	    Sub "clear"___("");	COMMENT = "";
	    Function "contains"___("Ba As QByteArray") As "Boolean";	COMMENT = "";
	    Function "contains2"___("Str As String") As "Boolean";	COMMENT = "";
	    Function "count"___("Ba As QByteArray") As "Integer";	COMMENT = "";
	    Function "count2"___("Str As String") As "Integer";	COMMENT = "";
	    Function "count3"___("") As "Integer";	COMMENT = "";
	    Function "data"___("") As "String";	COMMENT = "";
	    Function "endsWith"___("Ba As QByteArray") As "Boolean";	COMMENT = "";
	    Function "endsWith2"___("Str As String") As "Boolean";	COMMENT = "";
	    Function "fill"___("Ch As String, Size As Integer") As "QByteArray";	COMMENT = "";
	    Function "indexOf"___("Str As String, From As Integer") As "Integer";	COMMENT = "";
	    Function "insert"___("I As Integer, Ba As QByteArray") As "QByteArray";	COMMENT = "";
	    Function "insert2"___("I As Integer, Str As String") As "QByteArray";	COMMENT = "";
	    Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	    Function "isNull"___("") As "Boolean";	COMMENT = "";
	    Function "lastIndexOf"___("Ba As QByteArray, From As Integer") As "Integer";	COMMENT = "";
	    Function "lastIndexOf2"___("Str As String, From As Integer") As "Integer";	COMMENT = "";
	    Function "left"___("Len As Integer") As "QByteArray";	COMMENT = "";
	    Function "leftJustified"___("Width As Integer, Fill As String, Truncate As Boolean") As "QByteArray";	COMMENT = "";
	    Function "length"___("") As "Integer";	COMMENT = "";
	    Function "mid"___("Pos As Integer, Len As Integer") As "QByteArray";	COMMENT = "";
	    Function "prepend"___("Ba As QByteArray") As "QByteArray";	COMMENT = "";
	    Function "prepend2"___("Str As String") As "QByteArray";	COMMENT = "";
	    Sub "push_back"___("Other As QByteArray");	COMMENT = "";
	    Sub "push_back2"___("Str As String");	COMMENT = "";
	    Sub "push_front"___("Other As QByteArray");	COMMENT = "";
	    Sub "push_front2"___("Str As String");	COMMENT = "";
	    Function "replace"___("Pos As Integer, Len As Integer, After As QByteArray") As "QByteArray";	COMMENT = "";
	    Function "replace2"___("Pos As Integer, Len As Integer, After As String, Alen As Integer") As "QByteArray";	COMMENT = "";
	    Function "replace3"___("Before As QByteArray, After As QByteArray") As "QByteArray";	COMMENT = "";
	    Sub "reserve"___("Size As Integer");	COMMENT = "";
	    Sub "resize"___("Size As Integer");	COMMENT = "";
	    Function "right"___("Len As Integer") As "QByteArray";	COMMENT = "";
	    Function "rightJustified"___("Width As Integer, Fill As String, Truncate As Boolean") As "QByteArray";	COMMENT = "";
	    Function "setNum"___("N As Integer, Base As Integer") As "QByteArray";	COMMENT = "";
	    Function "setNum2"___("N As Float, Base As Integer") As "QByteArray";	COMMENT = "";
	    Function "simplified"___("") As "QByteArray";	COMMENT = "";
	    Function "size"___("") As "Integer";	COMMENT = "";
	    //Function "split"___("Sep As String") As "List";	COMMENT = "";
	    Sub "squeeze"___("");	COMMENT = "";
	    Function "startsWith"___("Ba As QByteArray") As "Boolean";	COMMENT = "";
	    Function "startsWith2"___("Str As String") As "Boolean";	COMMENT = "";
	    Sub "swap"___("Other As QByteArray");	COMMENT = "";
	    Function "toBase64"___("") As "QByteArray";	COMMENT = "";
	    Function "toFloat"___("Ok As Boolean") As "Float";	COMMENT = "";
	    Function "toHex"___("") As "QByteArray";	COMMENT = "";
	    Function "toInt"___("Ok As Boolean, Base As Integer") As "Integer";	COMMENT = "";
	    Function "toLower"___("") As "QByteArray";	COMMENT = "";
	    Function "toPercentEncoding"___("Exclude As QByteArray, Include As QByteArray, Percent As String") As "QByteArray";	COMMENT = "";
	    Function "toUpper"___("") As "QByteArray";	COMMENT = "";
	    Function "trimmed"___("") As "QByteArray";	COMMENT = "";
	    Sub "truncate"___("Pos As Integer");	COMMENT = "";

    End_Class

    

    Class "QShortcutEvent" SuperClass "QEvent"

	    Function "isAmbiguous"___("") As "Boolean";	COMMENT = "";
	    Function "key"___("") As "QKeySequence ";	COMMENT = "";
	    Function "shortcutId"___("") As "Integer";	COMMENT = "";
      
    End_Class

    

    Class "QResizeEvent" SuperClass "QEvent"

	    Function "oldSize"___("") As "QSize";	COMMENT = "";
	    Function "size"___("") As "QSize";	COMMENT = "";
  
    End_Class

    

    Class "QTextBlockFormat" SuperClass "QTextFormat"

	    Function "alignment"___("") As "Qt::Alignment";	COMMENT = "";
	    Function "bottomMargin"___("") As "Float";	COMMENT = "";
	    Function "indent"___("") As "Integer";	COMMENT = "";
	    Function "isValid"___("") As "Boolean";	COMMENT = "";
	    Function "leftMargin"___("") As "Float";	COMMENT = "";
	    Function "lineHeight"___("ScriptLineHeight As Float, Scaling As Float") As "Float";	COMMENT = "";
	    Function "lineHeight"___("") As "Float";	COMMENT = "";
	    Function "lineHeightType"___("") As "Integer";	COMMENT = "";
	    Function "nonBreakableLines"___("") As "Boolean";	COMMENT = "";
	    Function "pageBreakPolicy"___("") As "QTextBlockFormat::PageBreakFlags";	COMMENT = "";
	    Function "rightMargin"___("") As "Float";	COMMENT = "";
	    Sub "setAlignment"___("Alignment As Qt::Alignment");	COMMENT = "";
	    Sub "setBottomMargin"___("Margin As Float");	COMMENT = "";
	    Sub "setIndent"___("Indentation As Integer");	COMMENT = "";
	    Sub "setLeftMargin"___("Margin As Float");	COMMENT = "";
	    Sub "setLineHeight"___("Height As Float, HeightType As Integer");	COMMENT = "";
	    Sub "setNonBreakableLines"___("B As Boolean");	COMMENT = "";
	    Sub "setPageBreakPolicy"___("Policy As QTextBlockFormat::PageBreakFlags");	COMMENT = "";
	    Sub "setRightMargin"___("Margin As Float");	COMMENT = "";
	    //Sub "setTabPositions"___("Tabs As List");	COMMENT = "";
	    Sub "setTextIndent"___("Indent As Float");	COMMENT = "";
	    Sub "setTopMargin"___("Margin As Float");	COMMENT = "";
	    //Function "tabPositions"___("") As "List";	COMMENT = "";
	    Function "textIndent"___("") As "Float";	COMMENT = "";
	    Function "topMargin"___("") As "Float";	COMMENT = "";
  
    End_Class

    

    Class "QTextCharFormat" SuperClass "QTextFormat"
 
	    Function "anchorHref"___("") As "String";	COMMENT = "";
	    Function "anchorNames"___("") As "QStringList";	COMMENT = "";
	    Function "font"___("") As "QFont";	COMMENT = "";
	    Function "fontCapitalization"___("") As "QFont::Capitalization";	COMMENT = "";
	    Function "fontFamily"___("") As "String";	COMMENT = "";
	    Function "fontFixedPitch"___("") As "Boolean";	COMMENT = "";
	    Function "fontHintingPreference"___("") As "QFont::HintingPreference";	COMMENT = "";
	    Function "fontItalic"___("") As "Boolean";	COMMENT = "";
	    Function "fontLetterSpacing"___("") As "Float";	COMMENT = "";
	    Function "fontOverline"___("") As "Boolean";	COMMENT = "";
	    Function "fontPointSize"___("") As "Float";	COMMENT = "";
	    Function "fontStrikeOut"___("") As "Boolean";	COMMENT = "";
	    Function "fontStyleHint"___("") As "QFont::StyleHint";	COMMENT = "";
	    Function "fontStyleStrategy"___("") As "QFont::StyleStrategy";	COMMENT = "";
	    Function "fontUnderline"___("") As "Boolean";	COMMENT = "";
	    Function "fontWeight"___("") As "Integer";	COMMENT = "";
	    Function "fontWordSpacing"___("") As "Float";	COMMENT = "";
	    Function "isAnchor"___("") As "Boolean";	COMMENT = "";
	    Function "isValid"___("") As "Boolean";	COMMENT = "";
	    Sub "setAnchor"___("Anchor As Boolean");	COMMENT = "";
	    Sub "setAnchorHref"___("Value As String");	COMMENT = "";
	    Sub "setAnchorNames"___("Names As QStringList");	COMMENT = "";
	    Sub "setFont"___("Font As QFont");	COMMENT = "";
	    Sub "setFontCapitalization"___("Capitalization As QFont::Capitalization");	COMMENT = "";
	    Sub "setFontFamily"___("Family As String");	COMMENT = "";
	    Sub "setFontFixedPitch"___("FixedPitch As Boolean");	COMMENT = "";
	    Sub "setFontHintingPreference"___("HintingPreference As QFont::HintingPreference");	COMMENT = "";
	    Sub "setFontItalic"___("Italic As Boolean");	COMMENT = "";
	    Sub "setFontLetterSpacing"___("Spacing As Float");	COMMENT = "";
	    Sub "setFontOverline"___("Overline As Boolean");	COMMENT = "";
	    Sub "setFontPointSize"___("Size As Float");	COMMENT = "";
	    Sub "setFontStrikeOut"___("StrikeOut As Boolean");	COMMENT = "";
	    Sub "setFontStyleHint"___("Hint As QFont::StyleHint, Strategy As QFont::StyleStrategy");	COMMENT = "";
	    Sub "setFontStyleStrategy"___("Strategy As QFont::StyleStrategy");	COMMENT = "";
	    Sub "setFontUnderline"___("UnderLine As Boolean");	COMMENT = "";
	    Sub "setFontWeight"___("Weight As Integer");	COMMENT = "";
	    Sub "setFontWordSpacing"___("Spacing As Float");	COMMENT = "";
	    Sub "setTextOutline"___("Pen As QPen");	COMMENT = "";
	    Sub "setToolTip"___("Text As String");	COMMENT = "";
	    Sub "setUnderlineColor"___("Color As QColor");	COMMENT = "";
	    Sub "setUnderlineStyle"___("Style As QTextCharFormat::UnderlineStyle");	COMMENT = "";
	    Sub "setVerticalAlignment"___("Alignment As QTextCharFormat::VerticalAlignment");	COMMENT = "";
	    Function "textOutline"___("") As "QPen";	COMMENT = "";
	    Function "toolTip"___("") As "String";	COMMENT = "";
	    Function "underlineColor"___("") As "QColor";	COMMENT = "";
	    Function "underlineStyle"___("") As "QTextCharFormat::UnderlineStyle";	COMMENT = "";
	    Function "verticalAlignment"___("") As "QTextCharFormat::VerticalAlignment";	COMMENT = "";

    End_Class

    

    Class "QItemSelectionModel" SuperClass "QObject"

	    Function "columnIntersectsSelection"___("Column As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	    Function "currentIndex"___("") As "QModelIndex";	COMMENT = "";
	    Function "hasSelection"___("") As "Boolean";	COMMENT = "";
	    Function "isColumnSelected"___("Column As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	    Function "isRowSelected"___("Row As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	    Function "isSelected"___("Index As QModelIndex") As "Boolean";	COMMENT = "";
	    Function "model"___("") As "QAbstractItemModel";	COMMENT = "";
	    //Function "rowIntersectsSelection"___("Row As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	    //Function "selectedColumns"___("Row As Integer") As "QModelIndexList";	COMMENT = "";
	    //Function "selectedIndexes"___("") As "QModelIndexList";	COMMENT = "";
	    //Function "selectedRows"___("Column As Integer") As "QModelIndexList";	COMMENT = "";
	   // Function "selection"___("") As "QItemSelection";	COMMENT = "";

	    Slot "clear"___("");	COMMENT = "";
	    Slot "clearSelection"___("");	COMMENT = "";
	    Slot "reset"___("");	COMMENT = "";
	    Slot "select"___("Index As QModelIndex, Command As QItemSelectionModel::SelectionFlags");	COMMENT = "";
	    //Slot "select"___("Selection As QItemSelection, Command As QItemSelectionModel::SelectionFlags");	COMMENT = "";
	    Slot "setCurrentIndex"___("Index As QModelIndex, Command As QItemSelectionModel::SelectionFlags");	COMMENT = "";

	    Signal "currentChanged"___("Current As QModelIndex, Previous As QModelIndex") Declare "void currentChanged(const QModelIndex & current, const QModelIndex & previous)"	COMMENT = "";
	    Signal "currentColumnChanged"___("Current As QModelIndex, Previous As QModelIndex") Declare "void currentColumnChanged(const QModelIndex & current, const QModelIndex & previous)"	COMMENT = "";
	    Signal "currentRowChanged"___("Current As QModelIndex, Previous As QModelIndex") Declare "void currentRowChanged(const QModelIndex & current, const QModelIndex & previous)"	COMMENT = "";
	    Signal "selectionChanged"___("Selected As QItemSelection, Deselected As QItemSelection") Declare "void selectionChanged(const QItemSelection & selected, const QItemSelection & deselected)"	COMMENT = "";
  
    End_Class

    

    Class "QGraphicsSceneEvent" SuperClass "QEvent"
  	  
      Function "widget"___("") As "QWidget";	COMMENT = "";

    End_Class

    

    Class "QHelpEvent" SuperClass "QEvent"

      Function "globalPos"___("") As "QPoint";	COMMENT = "";
	    Function "globalX"___("") As "Integer";	COMMENT = "";
	    Function "globalY"___("") As "Integer";	COMMENT = "";
	    Function "pos"___("") As "QPoint";	COMMENT = "";
	    Function "x"___("") As "Integer";	COMMENT = "";
	    Function "y"___("") As "Integer";	COMMENT = "";

    End_Class
     
    

    Class "QMoveEvent" SuperClass "QEvent"
  
	    Function "oldPos"___("") As "QPoint ";	COMMENT = "";
	    Function "pos"___("") As "QPoint";	COMMENT = "";

    End_Class

    

    Class "QInputMethodEvent" SuperClass "QEvent"
  
	    //Function "attributes"___("") As "List";	COMMENT = "";
	    Function "commitString"___("") As "String";	COMMENT = "";
	    Function "preeditString"___("") As "String";	COMMENT = "";
	    Function "replacementLength"___("") As "Integer";	COMMENT = "";
	    Function "replacementStart"___("") As "Integer";	COMMENT = "";
	    Sub "setCommitString"___("CommitString As String, ReplaceFrom As Integer, ReplaceLength As Integer");	COMMENT = "";


    End_Class

    

    Class "QInputEvent" SuperClass "QEvent"
  
	    Function "modifiers"___("") As "Qt::KeyboardModifiers";	COMMENT = "";

    End_Class

    

    Class "QIconDragEvent" SuperClass "QEvent"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QHideEvent" SuperClass "QEvent"
  
    End_Class

    

    Class "QHoverEvent" SuperClass "QEvent"

	    Function "oldPos"___("") As "QPoint";	COMMENT = "";
	    Function "pos"___("") As "QPoint";	COMMENT = "";
  
    End_Class

    

    Class "QPaintEvent" SuperClass "QEvent"
	
      Function "rect"___("") As "QRect";	COMMENT = "";
	    Function "region"___("") As "QRegion";	COMMENT = "";
  
    End_Class

    

    Class "QFocusEvent" SuperClass "QEvent"

      Function "gotFocus"___("") As "Boolean";	COMMENT = "";
	    Function "lostFocus"___("") As "Boolean";	COMMENT = "";
	    Function "reason"___("") As "Qt::FocusReason";	COMMENT = "";

    End_Class

    

    Class "QCloseEvent" SuperClass "QEvent"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QFileOpenEvent" SuperClass "QEvent"
  
	    Function "file"___("") As "String";	COMMENT = "";
	   // Function "openFile"___("File As QFile, Flags As QIODevice::OpenMode") As "Boolean";	COMMENT = "";
	    Function "url"___("") As "QUrl";	COMMENT = "";

    End_Class

    

    Class "QDynamicPropertyChangeEvent" SuperClass "QEvent"
  	
      Function "propertyName"___("") As "QByteArray";	COMMENT = "";

    End_Class

    

    Class "QDragLeaveEvent" SuperClass "QEvent"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QDropEvent" SuperClass "QEvent"
  
	    Sub "acceptProposedAction"___("");	COMMENT = "";
	    Function "dropAction"___("") As "Qt::DropAction";	COMMENT = "";
	    Function "keyboardModifiers"___("") As "Qt::KeyboardModifiers";	COMMENT = "";
	    Function "mimeData"___("") As "QMimeData";	COMMENT = "";
	    Function "mouseButtons"___("") As "Qt::MouseButtons";	COMMENT = "";
	    Function "pos"___("") As "QPoint";	COMMENT = "";
	    Function "possibleActions"___("") As "Qt::DropActions";	COMMENT = "";
	    Function "proposedAction"___("") As "Qt::DropAction";	COMMENT = "";
	    Sub "setDropAction"___("Action As Qt::DropAction");	COMMENT = "";
	    Function "source"___("") As "QWidget";	COMMENT = "";

    End_Class

    

    Class "QPainter"

      Sub      "DrawLine"___("X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer");   COMMENT = "";

    End_Class

    

    Class "QPushButton" SuperClass "QAbstractButton"
  
      Property "Menu" As "QMenu";    COMMENT = "";
      Property "AutoDefault" As "Boolean";    COMMENT = "";
      Property "Default" As "Boolean";    COMMENT = "";
      Property "Flat" As "Boolean";    COMMENT = "";

    End_Class

    

    Class "QRadioButton" SuperClass "QAbstractButton"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QCommandLinkButton" SuperClass "QPushButton"

      Property "Description" As "String";    COMMENT = "";
  
    End_Class

    

    Class "QDialog" SuperClass "QWidget"

      Sub      "Accept"___("");   COMMENT = "";
      Sub      "Reject"___("");   COMMENT = "";

    End_Class

    

    Class "QListWidget" SuperClass "QListView"
  
      Function "Length"___("") As "Integer";   COMMENT = "";
      Sub      "RemoveAll"___("");   COMMENT = "";
      Function "Selected"___("") As "Integer";   COMMENT = "";
      Function "SelectedText"___("") As "String";   COMMENT = "";
      Sub      "Sort"___("Descending As Boolean");   COMMENT = "";
      Sub      "Append"___("Text As String");   COMMENT = "";
      Sub      "Remove"___("Index As Integer");   COMMENT = "";
      Sub      "Select"___("Index As Integer");   COMMENT = "";
      Sub      "SelectText"___("Text As String");   COMMENT = "";
      Function "Text"___("Index As Integer") As "String";   COMMENT = "";
      Function "Data"___("Index As Integer") As "id";   COMMENT = "";
      Function "Icon"___("Index As Integer") As "QIcon";   COMMENT = "";
      Function "CheckState"___("Index As Integer") As "Integer";   COMMENT = "";
      Function "Flags"___("Index As Integer") As "Integer";   COMMENT = "";
      Function "IsHidden"___("Index As Integer") As "Boolean";   COMMENT = "";
      Function "IsSelected"___("Index As Integer") As "Boolean";   COMMENT = "";
      Function "StatusTip"___("Index As Integer") As "String";   COMMENT = "";
      Function "WhatsThis"___("Index As Integer") As "String";   COMMENT = "";
      Function "ToolTip"___("Index As Integer") As "String";   COMMENT = "";
      Function "TextAlignment"___("Index As Integer") As "Integer";   COMMENT = "";
      Sub      "SetText"___("Index As Integer, Text As String");   COMMENT = "";
      Sub      "SetIcon"___("Index As Integer, Icon As QIcon");   COMMENT = "";
      Sub      "SetData"___("Index As Integer, id");   COMMENT = "";
      Sub      "SetCheckState"___("Index As Integer, CheckState As Integer");   COMMENT = "";
      Sub      "SetFlags"___("Index As Integer, Flag As Integer");   COMMENT = "";
      Sub      "SetHidden"___("Index As Integer, IsHidden As Boolean");   COMMENT = "";
      Sub      "SetSelected"___("Index As Integer, IsSelected As Boolean");   COMMENT = "";
      Sub      "SetStatusTip"___("Index As Integer, StatusTip As String");   COMMENT = "";
      Sub      "SetWhatsThis"___("Index As Integer, WhatsThis As String");   COMMENT = "";
      Sub      "SetToolTip"___("Index As Integer, ToolTip As String");   COMMENT = "";
      Sub      "SetTextAlignment"___("Index As Integer, TextAlignment As Integer");   COMMENT = "";
      Sub      "Insert"___("Index As Integer, Text As String");   COMMENT = "";
      Sub      "Append2"___("Icon As QIcon, Text As String");   COMMENT = "";
      Sub      "Insert2"___("Index As Integer, Icon As QIcon, Text As String");   COMMENT = "";

      Signal "currentRowChanged"___("Index As Integer") Declare "void currentRowChanged(int Index)"   COMMENT = "";

    End_Class

    

    Class "QTreeWidget" SuperClass "QTreeView"
  
      Function "ColumnCount"___("") As "Integer";   COMMENT = "";
      Function "CurrentColumn"___("") As "Integer";   COMMENT = "";
      Function "CurrentItem"___("") As "Integer";   COMMENT = "";
      Function "HeaderItem"___("") As "Integer";   COMMENT = "";
      Function "InvisibleRootItem"___("") As "Integer";   COMMENT = "";
      Function "SelectedItems"___("") As "List";   COMMENT = "";
      Function "SortColumn"___("") As "Integer";   COMMENT = "";
      Function "TopLevelItemCount"___("") As "Integer";   COMMENT = "";
      Function "CollapseAll"___("") As "Boolean";   COMMENT = "";
      Function "ExpandAll"___("") As "Boolean";   COMMENT = "";
      Function "SelectAll"___("") As "Boolean";   COMMENT = "";
      Sub      "ScrollToBottom"___("");   COMMENT = "";
      Sub      "ScrollToTop"___("");   COMMENT = "";
      Function "AppendChild"___("Text As String") As "Integer";   COMMENT = "";
      Function "ChildCount"___("ItemId As Integer") As "Integer";   COMMENT = "";
      Function "IsExpanded"___("ItemId As Integer") As "Boolean";   COMMENT = "";
      Function "IsHidden"___("ItemId As Integer") As "Boolean";   COMMENT = "";
      Function "ColumnCount2"___("ItemId As Integer") As "Integer";   COMMENT = "";
      Function "Append"___("Text As String") As "Integer";   COMMENT = "";
      Function "IndexOfTopLevelItem"___("ItemId As Integer") As "Integer";   COMMENT = "";
      Sub      "SetColumnCount"___("Count As Integer");   COMMENT = "";
      Sub      "SetCurrentItem"___("ItemId As Integer");   COMMENT = "";
      Sub      "SetHeaderLabel"___("Text As String");   COMMENT = "";
      Sub      "RemoveTopLevelItem"___("Index As Integer");   COMMENT = "";
      Function "TopLevelItem"___("Index As Integer") As "Integer";   COMMENT = "";
      Function "IsColumnHidden"___("Column As Integer") As "Boolean";   COMMENT = "";
      Function "ColumnWidth"___("Column As Integer") As "Integer";   COMMENT = "";
      Sub      "ShowColumn"___("Column As Integer");   COMMENT = "";
      Sub      "CollapseItem"___("ItemId As Integer");   COMMENT = "";
      Sub      "ExpandItem"___("ItemId As Integer");   COMMENT = "";
      Sub      "ScrollToItem"___("ItemId As Integer");   COMMENT = "";
      Function "Flags"___("ItemId As Integer") As "Integer";   COMMENT = "";
      Function "AppendChild2"___("Icon As QIcon, Text As String") As "Integer";   COMMENT = "";
      Function "AppendChildToId"___("ItemId As Integer, Text As String") As "Integer";   COMMENT = "";

      Function "Child"___("ItemId As Integer, Index As Integer") As "Integer";   COMMENT = "";
      Function "CheckState"___("ItemId As Integer, Column As Integer") As "Integer";   COMMENT = "";
      Function "Data"___("ItemId As Integer, Column As Integer") As "id";   COMMENT = "";
      Sub      "SetFlags"___("ItemId As Integer, Flags As Integer");   COMMENT = "";
      Function "Text"___("ItemId As Integer, Column As Integer") As "String";   COMMENT = "";
      Function "Icon"___("ItemId As Integer, Column As Integer") As "QIcon";   COMMENT = "";
      Function "IndexOfChild"___("ItemId As Integer, ChildItemId As Integer") As "Integer";   COMMENT = "";
      Sub      "SetDisabled"___("ItemId As Integer, IsDisabled As Boolean");   COMMENT = "";
      Sub      "SetExpanded"___("ItemId As Integer, IsExpanded As Boolean");   COMMENT = "";
      Sub      "SetHidden"___("ItemId As Integer, IsHidden As Boolean");   COMMENT = "";
      Sub      "SetSelected"___("ItemId As Integer, IsSelected As Boolean");   COMMENT = "";
      Function "StatusTip"___("ItemId As Integer, Column As Integer") As "String";   COMMENT = "";
      Function "WhatsThis"___("ItemId As Integer, Column As Integer") As "String";   COMMENT = "";
      Function "ToolTip"___("ItemId As Integer, Column As Integer") As "String";   COMMENT = "";
      Sub      "RemoveChild"___("ItemId As Integer, Index As Integer");   COMMENT = "";
      Function "TextAlignment"___("ItemId As Integer, Column As Integer") As "Integer";   COMMENT = "";
      Function "Append2"___("Icon As QIcon, Text As String") As "Integer";   COMMENT = "";
      Function "Insert2"___("Index As Integer, Text As String") As "Integer";   COMMENT = "";
      Function "ItemAt"___("X As Integer, Y As Integer") As "Integer";   COMMENT = "";
      Sub      "SetCurrentItem2"___("ItemId As Integer, Column As Integer");   COMMENT = "";
      Sub      "SetHeaderLabel2"___("Column As Integer, Text As String");   COMMENT = "";
      Sub      "SortItems"___("Column As Integer, Descending As Boolean");   COMMENT = "";
      Sub      "SetColumnHidden"___("Column As Integer, IsColumnHidden As Boolean");   COMMENT = "";
      Sub      "SetColumnWidth"___("Column As Integer, Width As Integer");   COMMENT = "";
      Sub      "ClosePersistentEditor"___("ItemId As Integer, Column As Integer");   COMMENT = "";
      Sub      "OpenPersistentEditor"___("ItemId As Integer, Column As Integer");   COMMENT = "";
      Sub      "EditItem"___("ItemId As Integer, Column As Integer");   COMMENT = "";

      Function "AppendChildToId2"___("ItemId As Integer, Icon As QIcon, Text As String") As "Integer";   COMMENT = "";
      Sub      "SetCheckState"___("ItemId As Integer, Column As Integer, CheckState As Integer");   COMMENT = "";
      Sub      "SetText"___("ItemId As Integer, Column As Integer, Text As String");   COMMENT = "";
      Sub      "SetIcon"___("ItemId As Integer, Column As Integer, Icon As QIcon");   COMMENT = "";
      Function "InsertChild"___("ItemId As Integer, Index As Integer, Text As String") As "Integer";   COMMENT = "";
      Sub      "SetStatusTip"___("ItemId As Integer, Column As Integer, StatusTip As String");   COMMENT = "";
      Sub      "SetWhatsThis"___("ItemId As Integer, Column As Integer, WhatsThis As String");   COMMENT = "";
      Sub      "SetToolTip"___("ItemId As Integer, Column As Integer, ToolTip As String");   COMMENT = "";
      Sub      "SetTextAlignment"___("ItemId As Integer, Column As Integer, TextAlignment As Integer");   COMMENT = "";
      Function "Insert3"___("Index As Integer, Icon As QIcon, Text As String") As "Integer";   COMMENT = "";
      Function "InsertChild2"___("ItemId As Integer, Index As Integer, Icon As QIcon, Text As String") As "Integer";   COMMENT = "";

      Signal "selectionChanged"___("") Declare "void selectionChanged()"   COMMENT = "";
      Signal "currentItemChanged"___("CurrentItemId As Integer, PreviousItemId As Integer") Declare "void currentItemChanged(QTreeWidgetItem *CurrentItemId, QTreeWidgetItem *PreviousItemId)" Cast "Q7B_ID((qint64) CurrentItemId), Q7B_ID((qint64) PreviousItemId)"  COMMENT = "";
      Signal "itemActivated"___("ItemId As Integer, Column As Integer") Declare "void itemActivated(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemChanged"___("ItemId As Integer, Column As Integer") Declare "void itemChanged(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemClicked"___("ItemId As Integer, Column As Integer") Declare "void itemClicked(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemCollapsed"___("ItemId As Integer, Column As Integer") Declare "void itemCollapsed(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemDoubleClicked"___("ItemId As Integer, Column As Integer") Declare "void itemDoubleClicked(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemEntered"___("ItemId As Integer, Column As Integer") Declare "void itemEntered(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemExpanded"___("ItemId As Integer, Column As Integer") Declare "void itemExpanded(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemPressed"___("ItemId As Integer, Column As Integer") Declare "void itemPressed(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";
      Signal "itemActivated"___("ItemId As Integer, Column As Integer") Declare "void itemActivated(QTreeWidgetItem *ItemId, int Column)" Cast "Q7B_ID((qint64) ItemId), Q7B_ID(Column)"  COMMENT = "";

    End_Class

    

    Class "QComboBox" SuperClass "QWidget"
  
      Property "CurrentIndex" As "Integer";    COMMENT = "";

      Function "Length"___("") As "Integer";   COMMENT = "";
      Function "Text"___("") As "String";   COMMENT = "";
      Sub      "RemoveAll"___("");   COMMENT = "";
      Sub      "SetNoCompleter"___("");   COMMENT = "";
      Function "Object"___("Index As Integer") As "String";   COMMENT = "";
      Sub      "Append"___("Text As String");   COMMENT = "";
      Sub      "Append2"___("Icon As QIcon, Text As String");   COMMENT = "";

      Signal "activated"___("Text As String") Declare "void activated(const QString & Text)"   COMMENT = "";

    End_Class            

    

    Class "QAbstractButton" SuperClass "QWidget"
  
      Property "Text" As "String";    COMMENT = "";
      Property "Caption" As "String";    COMMENT = "";
      Property "Icon" As "QIcon";    COMMENT = "";
      Property "Checked" As "Boolean";    COMMENT = "";
      Property "Checkable" As "Boolean";    COMMENT = "";
      Property "Key" As "String";    COMMENT = "";

      Signal "clicked"___("Checked As Boolean") Declare "void clicked(bool checked = false)"   COMMENT = "";
      Signal "toggled"___("Checked As Boolean") Declare "void toggled(bool checked = false)"   COMMENT = "";

    End_Class

    

    Class "QButtonGroup" SuperClass "QObject"
  
      Property "Exclusive" As "Boolean";    COMMENT = "";

      Sub      "AddButton"___("theButton As QAbstractButton");   COMMENT = "";

      Signal "buttonClicked"___("theButton As QAbstractButton") Declare "void buttonClicked(QAbstractButton *theButton)"   COMMENT = "";
      Signal "buttonPressed"___("theButton As QAbstractButton") Declare "void buttonPressed(QAbstractButton *theButton)"   COMMENT = "";
      Signal "buttonReleased"___("theButton As QAbstractButton") Declare "void buttonReleased(QAbstractButton *theButton)"   COMMENT = "";

    End_Class

    

    Class "QIntValidator" SuperClass "QValidator"
  
      Function "bottom"___("") As "Integer";   COMMENT = "";
      Function "top"___("") As "Integer";   COMMENT = "";

      Sub      "setBottom"___("v As Integer");   COMMENT = "";
      Sub      "setTop"___("v As Integer");   COMMENT = "";
      Sub      "setRange"___("bottom As Integer, top As Integer");   COMMENT = "";

    End_Class    

    
  
    Class "QTimeEdit" SuperClass "QDateTimeEdit"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------
  
    Class "QAbstractPrintDialog" SuperClass "QDialog"
  
    End_Class    

    
  
    Class "QPrintDialog" SuperClass "QAbstractPrintDialog"
  
      Function "options"___("") As "QAbstractPrintDialog::PrintDialogOption";   COMMENT = "";
      Function "printer"___("") As "QPrinter";   COMMENT = "";

      Sub      "setOption"___("option As QAbstractPrintDialog::PrintDialogOption, on As Boolean");   COMMENT = "";
      Function "testOption"___("option As QAbstractPrintDialog::PrintDialogOption") As "Boolean";   COMMENT = "";

    End_Class    

    

    Class "QToolButton" SuperClass "QAbstractButton"
  
      Property "Menu" As "QMenu";    COMMENT = "";

    End_Class

    

    Class "QSystemTrayIcon" //SuperClass "QObject"  // needed for include statement
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QKeySequence" //SuperClass "QObject"  

	    Function "count"___("") As "Integer";	COMMENT = "";
	    Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	    Function "matches"___("Other As QKeySequence") As "QKeySequence::SequenceMatch";	COMMENT = "";
	    Sub "swap"___("Other As QKeySequence");	COMMENT = "";
	    Function "toString"___("Format As QKeySequence::SequenceFormat") As "String";	COMMENT = "";
  
    End_Class

    

    Class "QPrintPreviewDialog" SuperClass "QDialog"

	  //  Sub "open"___("Printer As QPrinter, Parent As QWidget, Flags As Qt::WindowFlags");	COMMENT = "";
	    Function "printer"___("") As "QPrinter";	COMMENT = "";

	    Signal "paintRequested"___("Printer As QPrinter") Declare "void paintRequested(QPrinter * printer)"	COMMENT = "";

    End_Class

    

    Class "QSize" //SuperClass "QObject"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    
    Class "QListQStringList" //SuperClass "QObject"
  
	    Function "count"___("") As "Integer";	COMMENT = "";
	    Function "at"___("Index As Integer") As "QStringList";	COMMENT = "";
	    Sub "append"___("l As QStringList");	COMMENT = "";

    End_Class

    

    Class "QRect" //SuperClass "QObject"
  
	    Sub "adjust"___("Dx1 As Integer, Dy1 As Integer, Dx2 As Integer, Dy2 As Integer");	COMMENT = "";
	    Function "adjusted"___("Dx1 As Integer, Dy1 As Integer, Dx2 As Integer, Dy2 As Integer") As "QRect";	COMMENT = "";
	    Function "bottom"___("") As "Integer";	COMMENT = "";
	    Function "bottomLeft"___("") As "QPoint";	COMMENT = "";
	    Function "bottomRight"___("") As "QPoint";	COMMENT = "";
	    Function "center"___("") As "QPoint";	COMMENT = "";
	    Function "contains"___("Point As QPoint, Proper As Boolean") As "Boolean";	COMMENT = "";
	    Function "contains"___("X As Integer, Y As Integer, Proper As Boolean") As "Boolean";	COMMENT = "";
	    Function "contains"___("X As Integer, Y As Integer") As "Boolean";	COMMENT = "";
	    Function "contains"___("Rectangle As QRect, Proper As Boolean") As "Boolean";	COMMENT = "";
	    //Sub "getCoords"___("X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer");	COMMENT = "";
	    //Sub "getRect"___("X As Integer, Y As Integer, Width As Integer, Height As Integer");	COMMENT = "";
	    Function "height"___("") As "Integer";	COMMENT = "";
	    Function "intersected"___("Rectangle As QRect") As "QRect";	COMMENT = "";
	    Function "intersects"___("Rectangle As QRect") As "Boolean";	COMMENT = "";
	    Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	    Function "isNull"___("") As "Boolean";	COMMENT = "";
	    Function "isValid"___("") As "Boolean";	COMMENT = "";
	    Function "left"___("") As "Integer";	COMMENT = "";
	    Sub "moveBottom"___("Y As Integer");	COMMENT = "";
	    Sub "moveBottomLeft"___("Position As QPoint");	COMMENT = "";
	    Sub "moveBottomRight"___("Position As QPoint");	COMMENT = "";
	    Sub "moveCenter"___("Position As QPoint");	COMMENT = "";
	    Sub "moveLeft"___("X As Integer");	COMMENT = "";
	    Sub "moveRight"___("X As Integer");	COMMENT = "";
	    Sub "moveTo"___("X As Integer, Y As Integer");	COMMENT = "";
	    Sub "moveTo"___("Position As QPoint");	COMMENT = "";
	    Sub "moveTop"___("Y As Integer");	COMMENT = "";
	    Sub "moveTopLeft"___("Position As QPoint");	COMMENT = "";
	    Sub "moveTopRight"___("Position As QPoint");	COMMENT = "";
	    Function "normalized"___("") As "QRect";	COMMENT = "";
	    Function "right"___("") As "Integer";	COMMENT = "";
	    Sub "setBottom"___("Y As Integer");	COMMENT = "";
	    Sub "setBottomLeft"___("Position As QPoint");	COMMENT = "";
	    Sub "setBottomRight"___("Position As QPoint");	COMMENT = "";
	    Sub "setCoords"___("X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer");	COMMENT = "";
	    Sub "setHeight"___("Height As Integer");	COMMENT = "";
	    Sub "setLeft"___("X As Integer");	COMMENT = "";
	    Sub "setRect"___("X As Integer, Y As Integer, Width As Integer, Height As Integer");	COMMENT = "";
	    Sub "setRight"___("X As Integer");	COMMENT = "";
	    Sub "setSize"___("Size As QSize");	COMMENT = "";
	    Sub "setTop"___("Y As Integer");	COMMENT = "";
	    Sub "setTopLeft"___("Position As QPoint");	COMMENT = "";
	    Sub "setTopRight"___("Position As QPoint");	COMMENT = "";
	    Sub "setWidth"___("Width As Integer");	COMMENT = "";
	    Sub "setX"___("X As Integer");	COMMENT = "";
	    Sub "setY"___("Y As Integer");	COMMENT = "";
	    Function "size"___("") As "QSize";	COMMENT = "";
	    Function "top"___("") As "Integer";	COMMENT = "";
	    Function "topLeft"___("") As "QPoint";	COMMENT = "";
	    Function "topRight"___("") As "QPoint";	COMMENT = "";
	    Sub "translate"___("Dx As Integer, Dy As Integer");	COMMENT = "";
	    Sub "translate"___("Offset As QPoint");	COMMENT = "";
	    Function "translated"___("Dx As Integer, Dy As Integer") As "QRect";	COMMENT = "";
	    Function "translated"___("Offset As QPoint") As "QRect";	COMMENT = "";
	    Function "united"___("Rectangle As QRect") As "QRect";	COMMENT = "";
	    Function "width"___("") As "Integer";	COMMENT = "";
	    Function "x"___("") As "Integer";	COMMENT = "";
	    Function "y"___("") As "Integer";	COMMENT = "";

    End_Class

    

    Class "QLayoutItem" //SuperClass "QObject"
  
    End_Class    

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QRgb" //SuperClass "QObject"
  
    End_Class
    
    

    Class "QMatrix" //SuperClass "QObject"
  
    End_Class

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QTransform" //SuperClass "QObject"
  
    End_Class

    

    Class "QByteArray" //SuperClass "QObject"
  
    End_Class
   
    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QTextBlock" //SuperClass "QObject"
  
    End_Class  
        
    

    Class "QPoint" //SuperClass "QObject"
  
	    Function "isNull"___("") As "Boolean";	COMMENT = "";
	    Function "manhattanLength"___("") As "Integer";	COMMENT = "";
	    Function "rx"___("") As "Integer";	COMMENT = "";
	    Function "ry"___("") As "Integer";	COMMENT = "";
	    Sub "setX"___("X As Integer");	COMMENT = "";
	    Sub "setY"___("Y As Integer");	COMMENT = "";
	    Function "x"___("") As "Integer";	COMMENT = "";
	    Function "y"___("") As "Integer";	COMMENT = "";

    End_Class  

    

    Class "QPalette" //SuperClass "QObject"
  
    End_Class  

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QEvent" //SuperClass "QObject"  

	    Property "accepted" As "Boolean";	COMMENT = "";

	    Sub "accept"___("");	COMMENT = "";
	    Sub "ignore"___("");	COMMENT = "";
	    Function "isAccepted"___("") As "Boolean";	COMMENT = "";
	    Sub "setAccepted"___("Accepted As Boolean");	COMMENT = "";
	    Function "spontaneous"___("") As "Boolean";	COMMENT = "";
	    Function "type"___("") As "QEvent::Type";	COMMENT = "";	

    End_Class  

    
    
    Class "QAccessibleEvent" SuperClass "QEvent"

	    Function "child"___("") As "Integer";	COMMENT = "";
	    Sub "setValue"___("Text As String");	COMMENT = "";
	    Function "value"___("") As "String";	COMMENT = "";

    End_Class        

    

    Class "QActionEvent" SuperClass "QEvent"
	
      Function "action"___("") As "QAction";	COMMENT = "";
	    Function "before"___("") As "QAction";	COMMENT = "";
  
    End_Class  

    

    Class "QChildEvent" SuperClass "QEvent"
	
	    Function "added"___("") As "Boolean";	COMMENT = "";
	    Function "child"___("") As "QObject";	COMMENT = "";
	    Function "polished"___("") As "Boolean";	COMMENT = "";
	    Function "removed"___("") As "Boolean";	COMMENT = "";
      
    End_Class  

    

    Class "QInputEvent" SuperClass "QEvent"
  
    End_Class  

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QContextMenuEvent" SuperClass "QInputEvent"
  
    End_Class  
     
    

    Class "QMargins" //SuperClass "QObject"
  
    End_Class          

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QTextOption" //SuperClass "QObject"
  
    End_Class  

    

    Class "QTextFormat" //SuperClass "QObject"
  
    End_Class  
     
    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QSizeF" //SuperClass "QObject"
  
    End_Class  
    
    

    Class "QPrinter" // SuperClass "QObject"
  
    End_Class  

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QAbstractTextDocumentLayout" SuperClass "QObject"
  
    End_Class  

    

    Class "QNetworkRequest" //SuperClass "QObject"
  
    End_Class  

    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QFileInfoList" //SuperClass "QObject"
  
    End_Class  

    

    Class "QAbstractItemModel" //SuperClass "QObject"
  
    End_Class  
   
    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QPolygon" //SuperClass "QVector<QPoint>"
  
	    Function "boundingRect"___("") As "QRect";	COMMENT = "";
	    Function "containsPoint"___("Point As QPoint, FillRule As Qt::FillRule") As "Boolean";	COMMENT = "";
	    Function "intersected"___("R As QPolygon") As "QPolygon";	COMMENT = "";
	    Function "point"___("Index As Integer") As "QPoint";	COMMENT = "";
	    Sub "putPoints"___("Index As Integer, NPoints As Integer, FromPolygon As QPolygon, FromIndex As Integer");	COMMENT = "";
	    Sub "setPoint"___("Index As Integer, X As Integer, Y As Integer");	COMMENT = "";
	    Sub "setPoint"___("Index As Integer, Point As QPoint");	COMMENT = "";
	    //Function "subtracted"___("") As "QPolygon";	COMMENT = "";
	    Sub "swap"___("Other As QPolygon");	COMMENT = "";
	    Sub "translate"___("Dx As Integer, Dy As Integer");	COMMENT = "";
	    Sub "translate"___("Offset As QPoint");	COMMENT = "";
	    Function "translated"___("Dx As Integer, Dy As Integer") As "QPolygon";	COMMENT = "";
	    Function "translated"___("Offset As Integer") As "QPolygon";	COMMENT = "QPolygon";
	    Function "united"___("R As QPolygon") As "QPolygon";	COMMENT = "";

    End_Class  
   
    

    Class "QTextDocumentFragment" //SuperClass "QObject"
 
      //Function "isEmpty"___("Encoding As QByteArray") As "Boolean";	COMMENT = "";
	    Function "toHtml"___("") As "String";	COMMENT = "";
	    Function "toHtml"___("") As "String";	COMMENT = "";
	    Function "toPlainText"___("") As "String";	COMMENT = "";

    End_Class  

    

    Class "QTextFrameFormat" //SuperClass "QObject"
  
    End_Class  
   
    // ----------------------------------------------------------------------------------------------------------------------------

    Class "QPen" //SuperClass "QObject"
  
    End_Class  
   
    
    
      
     

    

    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************

    

    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************
    
    // ***************************************************************************************************************************************************************
    

//--------------------------------------

Class "QLayout" SuperClass "QLayoutItem"
	
	Property "sizeConstraint" As "QLayout::SizeConstraint";	COMMENT = "";
	Property "spacing" As "Integer";	COMMENT = "";

	Function "activate"___("") As "Boolean";	COMMENT = "";
	Sub "addItem"___("Item As QLayoutItem");	COMMENT = "";
	Sub "addWidget"___("W As QWidget");	COMMENT = "";
	//Sub "getContentsMargins"___("Left As Integer, Top As Integer, Right As Integer, Bottom As Integer");	COMMENT = "";
	Function "contentsRect"___("") As "QRect";	COMMENT = "";
	Function "indexOf"___("Widget As QWidget") As "Integer";	COMMENT = "";
	Function "isEnabled"___("") As "Boolean";	COMMENT = "";
	Function "itemAt"___("Index As Integer") As "QLayoutItem";	COMMENT = "";
	Function "menuBar"___("") As "QWidget";	COMMENT = "";
	Function "parentWidget"___("") As "QWidget";	COMMENT = "";
	Sub "removeItem"___("Item As QLayoutItem");	COMMENT = "";
	Sub "removeWidget"___("Widget As QWidget");	COMMENT = "";
	//Function "setAlignment"___("W As QWidget, Alignment As Qt::Alignment") As "Boolean";	COMMENT = "";
	//Sub "setAlignment"___("Alignment As Qt::Alignment");	COMMENT = "";
//	Function "setAlignment2"___("L As QLayout, Alignment As Qt::Alignment") As "Boolean";	COMMENT = "";
	Sub "setContentsMargins"___("Left As Integer, Top As Integer, Right As Integer, Bottom As Integer");	COMMENT = "";
	Sub "setEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setMenuBar"___("Widget As QWidget");	COMMENT = "";
	Sub "setSizeConstraint"___("Constraint As QLayout::SizeConstraint");	COMMENT = "";
	Sub "setSpacing"___("Spacing As Integer");	COMMENT = "";
	Function "sizeConstraint"___("") As "QLayout::SizeConstraint";	COMMENT = "";
	Function "spacing"___("") As "Integer";	COMMENT = "";
	Sub "update"___("");	COMMENT = "";

End_Class



Class "QFrame" SuperClass "QWidget"

	Property "frameRect" As "QRect";	COMMENT = "";
	Property "frameShadow" As "QFrame.Shadow";	COMMENT = "";
	Property "frameShape" As "QFrame.Shape";	COMMENT = "";
	Property "frameWidth" As "Integer";	COMMENT = "";
	Property "lineWidth" As "Integer";	COMMENT = "";
	Property "midLineWidth" As "Integer";	COMMENT = "";

	Function "frameStyle"___("") As "Integer";	COMMENT = "";
	Sub "setFrameStyle"___("Style As Integer");	COMMENT = "";

End_Class



Class "QAbstractScrollArea" SuperClass "QFrame"
	
	Property "horizontalScrollBarPolicy" As "Qt::ScrollBarPolicy";	COMMENT = "";
	Property "verticalScrollBarPolicy" As "Qt::ScrollBarPolicy";	COMMENT = "";

	//Sub "addScrollBarWidget"___("Widget As QWidget, Alignment As Qt::Alignment");	COMMENT = "";
	Function "cornerWidget"___("") As "QWidget";	COMMENT = "";
	Function "horizontalScrollBar"___("") As "QScrollBar";	COMMENT = "";
	Function "horizontalScrollBarPolicy"___("") As "Qt::ScrollBarPolicy";	COMMENT = "";
	Function "maximumViewportSize"___("") As "QSize";	COMMENT = "";
	Sub "setCornerWidget"___("Widget As QWidget");	COMMENT = "";
	Sub "setHorizontalScrollBar"___("ScrollBar As QScrollBar");	COMMENT = "";
	Sub "setHorizontalScrollBarPolicy"___("Policy As Qt::ScrollBarPolicy");	COMMENT = "";
	Sub "setVerticalScrollBar"___("ScrollBar As QScrollBar");	COMMENT = "";
	Sub "setVerticalScrollBarPolicy"___("Policy As Qt::ScrollBarPolicy");	COMMENT = "";
	Sub "setViewport"___("Widget As QWidget");	COMMENT = "";
	Function "verticalScrollBar"___("") As "QScrollBar";	COMMENT = "";
	Function "verticalScrollBarPolicy"___("") As "Qt::ScrollBarPolicy";	COMMENT = "";
	Function "viewport"___("") As "QWidget";	COMMENT = "";

End_Class



Class "QPainter"

	Function "background"___("") As "QBrush";	COMMENT = "";
	Function "backgroundMode"___("") As "Qt::BGMode";	COMMENT = "";
	Function "begin"___("Device As QWidget") As "Boolean";	COMMENT = "";
	Sub "beginNativePainting"___("");	COMMENT = "";
	Function "boundingRect"___("Rectangle As QRect, Flags As Integer, Text As String") As "QRect";	COMMENT = "";
	Function "brush"___("") As "QBrush";	COMMENT = "";
	Function "brushOrigin"___("") As "QPoint";	COMMENT = "";
	//Function "clipPath"___("") As "QPainterPath";	COMMENT = "";
	Function "clipRegion"___("") As "QRegion";	COMMENT = "";
	Function "combinedTransform"___("") As "QTransform";	COMMENT = "";
	Function "compositionMode"___("") As "QPainter::CompositionMode";	COMMENT = "";
	//Function "device"___("") As "QWidget";	COMMENT = "";
	Function "deviceTransform"___("") As "QTransform";	COMMENT = "";
	Sub "drawArc"___("Rectangle As QRect, StartAngle As Integer, SpanAngle As Integer");	COMMENT = "";
	Sub "drawChord"___("Rectangle As QRect, StartAngle As Integer, SpanAngle As Integer");	COMMENT = "";
	Sub "drawConvexPolygon"___("Points As QPolygon");	COMMENT = "";
	Sub "drawEllipse"___("Rectangle As QRect");	COMMENT = "";
	Sub "drawEllipse2"___("Center As QPoint, Rx As Integer, Ry As Integer");	COMMENT = "";
	Sub "drawImage"___("Target As QRect, Image As QImage, Source As QRect, Flags As Qt::ImageConversionFlags");	COMMENT = "";
	Sub "drawImage2"___("Point As QPoint, Image As QImage");	COMMENT = "";
	Sub "drawImage"___("Rectangle As QRect, Image As QImage");	COMMENT = "";
	Sub "drawLine"___("Line As QLine");	COMMENT = "";
	Sub "drawLine2"___("P1 As QPoint, P2 As QPoint");	COMMENT = "";
	//Sub "drawPath"___("Path As QPainterPath");	COMMENT = "";
	Sub "drawPicture"___("X As Integer, Y As Integer, Picture As QPicture");	COMMENT = "";
	Sub "drawPicture2"___("Point As QPoint, Picture As QPicture");	COMMENT = "";
	Sub "drawPie"___("Rectangle As QRect, StartAngle As Integer, SpanAngle As Integer");	COMMENT = "";
	Sub "drawPixmap"___("X As Integer, Y As Integer, Pixmap As QPixmap");	COMMENT = "";
	Sub "drawPixmap2"___("Target As QRect, Pixmap As QPixmap, Source As QRect");	COMMENT = "";	
	Sub "drawPixmap3"___("Point As QPoint, Pixmap As QPixmap, Source As QRect");	COMMENT = "";
	Sub "drawPixmap4"___("Rectangle As QRect, Pixmap As QPixmap");	COMMENT = "";
	Sub "drawPoint"___("X As Integer, Y As Integer");	COMMENT = "";
	Sub "drawPoint2"___("Position As QPoint");	COMMENT = "";
	Sub "drawPoints"___("Points As QPolygon");	COMMENT = "";
	Sub "drawPolygon"___("Polygon As QPolygon, FillRule As Qt::FillRule");	COMMENT = "";
	Sub "drawPolyline"___("Points As QPolygon");	COMMENT = "";
	Sub "drawRect"___("Rectangle As QRect");	COMMENT = "";
	Sub "drawRoundedRect"___("Rectangle As QRect, XRadius As Float, YRadius As Float, Mode As Qt::SizeMode");	COMMENT = "";
	//Sub "drawStaticText"___("TopLeftPosition As QPoint, StaticText As QStaticText");	COMMENT = "";
	//Sub "drawStaticText"___("Left As Integer, Top As Integer, StaticText As QStaticText");	COMMENT = "";
	Sub "drawText"___("X As Integer, Y As Integer, Text As String");	COMMENT = "";
	Sub "drawText2"___("Position As QPoint, Text As String");	COMMENT = "";
	//Sub "drawText3"___("Rectangle As QRect, Flags As Integer, Text As String, BoundingRect As QRect");	COMMENT = "";
	Sub "drawTiledPixmap"___("Rectangle As QRect, Pixmap As QPixmap, Position As QPoint");	COMMENT = "";
	Function "end"___("") As "Boolean";	COMMENT = "";
	Sub "endNativePainting"___("");	COMMENT = "";
	Sub "eraseRect"___("Rectangle As QRect");	COMMENT = "";
	//Sub "fillPath"___("Path As QPainterPath, Brush As QBrush");	COMMENT = "";
	Sub "fillRect"___("Rectangle As QRect, Style As Qt::BrushStyle");	COMMENT = "";
	Sub "fillRect2"___("Rectangle As QRect, Brush As QBrush");	COMMENT = "";
	Sub "fillRect3"___("Rectangle As QRect, Color As QColor");	COMMENT = "";
	Sub "fillRect4"___("Rectangle As QRect, Color As Qt::GlobalColor");	COMMENT = "";
	Function "font"___("") As "QFont";	COMMENT = "";
	Function "fontInfo"___("") As "QFontInfo";	COMMENT = "";
	Function "fontMetrics"___("") As "QFontMetrics";	COMMENT = "";
	Function "hasClipping"___("") As "Boolean";	COMMENT = "";
	Sub "initFrom"___("Widget As QWidget");	COMMENT = "";
	Function "isActive"___("") As "Boolean";	COMMENT = "";
	Function "layoutDirection"___("") As "Qt::LayoutDirection";	COMMENT = "";
	Function "opacity"___("") As "Float";	COMMENT = "";
	Function "paintEngine"___("") As "QPaintEngine";	COMMENT = "";
	Function "pen"___("") As "QPen";	COMMENT = "";
	Function "renderHints"___("") As "QPainter::RenderHints";	COMMENT = "";
	Sub "resetTransform"___("");	COMMENT = "";
	Sub "restore"___("");	COMMENT = "";
	Sub "rotate"___("Angle As Float");	COMMENT = "";
	Sub "save"___("");	COMMENT = "";
	Sub "scale"___("Sx As Float, Sy As Float");	COMMENT = "";
	Sub "setBackground"___("Brush As QBrush");	COMMENT = "";
	Sub "setBackgroundMode"___("Mode As Qt::BGMode");	COMMENT = "";
	Sub "setBrush"___("Brush As QBrush");	COMMENT = "";
	Sub "setBrush2"___("Style As Qt::BrushStyle");	COMMENT = "";
	Sub "setBrushOrigin"___("X As Integer, Y As Integer");	COMMENT = "";
	Sub "setBrushOrigin2"___("Position As QPoint");	COMMENT = "";
	//Sub "setClipPath"___("Path As QPainterPath, Operation As Qt::ClipOperation");	COMMENT = "";
	Sub "setClipRect"___("Rectangle As QRect, Operation As Qt::ClipOperation");	COMMENT = "";
	Sub "setClipRegion"___("Region As QRegion, Operation As Qt::ClipOperation");	COMMENT = "";
	Sub "setClipping"___("Enable As Boolean");	COMMENT = "";
	Sub "setCompositionMode"___("Mode As QPainter::CompositionMode");	COMMENT = "";
	Sub "setFont"___("Font As QFont");	COMMENT = "";
	Sub "setLayoutDirection"___("Direction As Qt::LayoutDirection");	COMMENT = "";
	Sub "setOpacity"___("Opacity As Float");	COMMENT = "";
	Sub "setPen"___("Pen As QPen");	COMMENT = "";
	Sub "setPen2"___("Color As QColor");	COMMENT = "";
	Sub "setPen3"___("Style As Qt::PenStyle");	COMMENT = "";
	Sub "setRenderHint"___("Hint As QPainter::RenderHint");	COMMENT = "";
	Sub "setRenderHints"___("Hints As QPainter::RenderHints");	COMMENT = "";
	Sub "setTransform"___("Transform As QTransform, Combine As Boolean");	COMMENT = "";
	Sub "setViewTransformEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setViewport"___("Rectangle As QRect");	COMMENT = "";
	Sub "setWindow"___("Rectangle As QRect");	COMMENT = "";
	Sub "setWorldMatrixEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setWorldTransform"___("Matrix As QTransform, Combine As Boolean");	COMMENT = "";
	//Sub "strokePath"___("Path As QPainterPath, Pen As QPen");	COMMENT = "";
	Function "testRenderHint"___("Hint As QPainter::RenderHint") As "Boolean";	COMMENT = "";
	Function "transform"___("") As "QTransform";	COMMENT = "";
	Sub "translate"___("Dx As Integer, Dy As Integer");	COMMENT = "";
	Sub "translate2"___("Offset As QPoint");	COMMENT = "";
	Function "viewTransformEnabled"___("") As "Boolean";	COMMENT = "";
	Function "viewport"___("") As "QRect";	COMMENT = "";
	Function "window"___("") As "QRect";	COMMENT = "";
	Function "worldMatrixEnabled"___("") As "Boolean";	COMMENT = "";
	Function "worldTransform"___("") As "QTransform";	COMMENT = "";

End_Class



Class "QLine"

	Function "p1"___("") As "QPoint";	COMMENT = "";
	Function "p2"___("") As "QPoint";	COMMENT = "";
	Function "x1"___("") As "Integer";	COMMENT = "";
	Function "x2"___("") As "Integer";	COMMENT = "";
	Function "y1"___("") As "Integer";	COMMENT = "";
	Function "y2"___("") As "Integer";	COMMENT = "";
	Function "dx"___("") As "Integer";	COMMENT = "";
	Function "dy"___("") As "Integer";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Sub "setP1"___("P1 As QPoint");	COMMENT = "";
	Sub "setP2"___("P2 As QPoint");	COMMENT = "";
	Sub "setLine"___("X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer");	COMMENT = "";
	Sub "setPoints"___("P1 As QPoint, P2 As QPoint");	COMMENT = "";
	Sub "translate"___("Dx As Integer, Dy As Integer");	COMMENT = "";
	Sub "translate2"___("Offset As QPoint");	COMMENT = "";
	Function "translated"___("Dx As Integer, Dy As Integer") As "QLine";	COMMENT = "";
	Function "translated2"___("Offset As QPoint") As "QLine";	COMMENT = "";

End_Class



Class "QSize"

	Function "boundedTo"___("OtherSize As QSize") As "QSize";	COMMENT = "";
	Function "expandedTo"___("OtherSize As QSize") As "QSize";	COMMENT = "";
	Function "height"___("") As "Integer";	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "rheight"___("") As "Integer";	COMMENT = "";
	Function "rwidth"___("") As "Integer";	COMMENT = "";
	Sub "scale"___("Width As Integer, Height As Integer, Mode As Qt::AspectRatioMode");	COMMENT = "";
	Sub "scale2"___("Size As QSize, Mode As Qt::AspectRatioMode");	COMMENT = "";
	Sub "setHeight"___("Height As Integer");	COMMENT = "";
	Sub "setWidth"___("Width As Integer");	COMMENT = "";
	Sub "transpose"___("");	COMMENT = "";
	Function "width"___("") As "Integer";	COMMENT = "";

End_Class



Class "QRegion"

	Function "boundingRect"___("") As "QRect";	COMMENT = "";
	Function "contains"___("P As QPoint") As "Boolean";	COMMENT = "";
	Function "contains"___("R As QRect") As "Boolean";	COMMENT = "";
	Function "intersected"___("R As QRegion") As "QRegion";	COMMENT = "";
	Function "intersected2"___("Rect As QRect") As "QRegion";	COMMENT = "";
	Function "intersects"___("Region As QRegion") As "Boolean";	COMMENT = "";
	Function "intersects2"___("Rect As QRect") As "Boolean";	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "rectCount"___("") As "Integer";	COMMENT = "";
	Function "subtracted"___("R As QRegion") As "QRegion";	COMMENT = "";
	Sub "swap"___("Other As QRegion");	COMMENT = "";
	Sub "translate"___("Dx As Integer, Dy As Integer");	COMMENT = "";
	Sub "translate2"___("Point As QPoint");	COMMENT = "";
	Function "translated"___("Dx As Integer, Dy As Integer") As "QRegion";	COMMENT = "";
	Function "translated2"___("Point As QPoint") As "QRegion";	COMMENT = "";
	Function "united"___("R As QRegion") As "QRegion";	COMMENT = "";
	Function "united2"___("Rect As QRect") As "QRegion";	COMMENT = "";
	Function "xored"___("R As QRegion") As "QRegion";	COMMENT = "";

End_Class



Class "QDrag" SuperClass "QObject"

	Function "exec"___("SupportedActions As Qt::DropActions") As "Qt::DropAction";	COMMENT = "";
	Function "exec2"___("SupportedActions As Qt::DropActions, DefaultDropAction As Qt::DropAction") As "Qt::DropAction";	COMMENT = "";
	Function "hotSpot"___("") As "QPoint";	COMMENT = "";
	Function "mimeData"___("") As "QMimeData";	COMMENT = "";
	Function "pixmap"___("") As "QPixmap";	COMMENT = "";
	Sub "setDragCursor"___("Cursor As QPixmap, Action As Qt::DropAction");	COMMENT = "";
	Sub "setHotSpot"___("Hotspot As QPoint");	COMMENT = "";
	Sub "setMimeData"___("Data As QMimeData");	COMMENT = "";
	Sub "setPixmap"___("Pixmap As QPixmap");	COMMENT = "";	
	Function "source"___("") As "QWidget";	COMMENT = "";
	Function "target"___("") As "QWidget";	COMMENT = "";

	Signal "actionChanged"___("Action As Qt::DropAction") Declare "void actionChanged(Qt::DropAction action)"	COMMENT = "";
	Signal "targetChanged"___("NewTarget As QWidget") Declare "void targetChanged(QWidget * newTarget)"	COMMENT = "";

End_Class



Class "QFontMetrics"

	Function "ascent"___("") As "Integer";	COMMENT = "";
	Function "averageCharWidth"___("") As "Integer";	COMMENT = "";
	Function "boundingRect"___("Text As String") As "QRect";	COMMENT = "";
	Function "descent"___("") As "Integer";	COMMENT = "";
	Function "elidedText"___("Text As String, Mode As Qt::TextElideMode, Width As Integer, Flags As Integer") As "String";	COMMENT = "";
	Function "height"___("") As "Integer";	COMMENT = "";
	Function "inFont"___("Ch As String") As "Boolean";	COMMENT = "";
	Function "leading"___("") As "Integer";	COMMENT = "";
	Function "leftBearing"___("Ch As String") As "Integer";	COMMENT = "";
	Function "lineSpacing"___("") As "Integer";	COMMENT = "";
	Function "lineWidth"___("") As "Integer";	COMMENT = "";
	Function "maxWidth"___("") As "Integer";	COMMENT = "";
	Function "minLeftBearing"___("") As "Integer";	COMMENT = "";
	Function "minRightBearing"___("") As "Integer";	COMMENT = "";
	Function "overlinePos"___("") As "Integer";	COMMENT = "";
	Function "rightBearing"___("Ch As String") As "Integer";	COMMENT = "";
	Function "strikeOutPos"___("") As "Integer";	COMMENT = "";
	Function "tightBoundingRect"___("Text As String") As "QRect";	COMMENT = "";
	Function "underlinePos"___("") As "Integer";	COMMENT = "";
	Function "width"___("Text As String, Len As Integer") As "Integer";	COMMENT = "";
	Function "width2"___("Ch As String") As "Integer";	COMMENT = "";
	Function "xHeight"___("") As "Integer";	COMMENT = "";

End_Class



Class "QFtp" SuperClass "QObject"

	Function "bytesAvailable"___("") As "Integer";	COMMENT = "";
	Function "cd"___("Dir As String") As "Integer";	COMMENT = "";
	Sub "clearPendingCommands"___("");	COMMENT = "";
	Function "close"___("") As "Integer";	COMMENT = "";
	Function "connectToHost"___("Host As String, Port As Integer") As "Integer";	COMMENT = "";
	Function "currentCommand"___("") As "QFtp::Command";	COMMENT = "";
	Function "currentDevice"___("") As "QIODevice";	COMMENT = "";
	Function "currentId"___("") As "Integer";	COMMENT = "";
	Function "error"___("") As "QFtp::Error";	COMMENT = "";
	Function "errorString"___("") As "String";	COMMENT = "";
//	Function "get"___("File As String, Dev As QIODevice, Type As  QFtp::TransferType") As "Integer";	COMMENT = "";
	Function "hasPendingCommands"___("") As "Boolean";	COMMENT = "";
	Function "list"___("Dir As String") As "Integer";	COMMENT = "";
	Function "login"___("User As String, Password As String") As "Integer";	COMMENT = "";
	Function "mkdir"___("Dir As String") As "Integer";	COMMENT = "";
	Function "put"___("Data As QByteArray, File As String, Type As QFtp::TransferType") As "Integer";	COMMENT = "";
//	Function "put2"___("Dev As QIODevice, File As String, Type As QFtp::TransferType") As "Integer";	COMMENT = "";
	Function "rawCommand"___("Command As String") As "Integer";	COMMENT = "";
	//Function "read"___("Data As String, MaxLen As Integer") As "Integer";	COMMENT = "";
	Function "readAll"___("") As "QByteArray";	COMMENT = "";
	Function "remove"___("File As QString") As "Integer";	COMMENT = "";
	Function "rename"___("OldName As String, NewName As String") As "Integer";	COMMENT = "";
	Function "rmdir"___("Dir As String") As "Integer";	COMMENT = "";
	Function "setProxy"___("Host As String, Port As Integer") As "Integer";	COMMENT = "";
	Function "setTransferMode"___("Mode As QFtp::TransferMode") As "Integer";	COMMENT = "";
	Function "state"___("") As "QFtp::State";	COMMENT = "";

	Slot "abort"___("");	COMMENT = "";

	Signal "commandFinished"___("Id As Integer, Error As Boolean") Declare "void commandFinished(int id, bool error)"	COMMENT = "";
	Signal "commandStarted"___("Id As Integer") Declare "void commandStarted(int id)"	COMMENT = "";
	Signal "dataTransferProgress"___("Done As Integer, Total As Integer") Declare "void dataTransferProgress(qint64 done, qint64 total)"	COMMENT = "";
	Signal "done"___("Error As Boolean") Declare "void done(bool error)"	COMMENT = "";
	Signal "listInfo"___("I As QUrlInfo") Declare "void listInfo(const QUrlInfo & i)"	COMMENT = "";
	Signal "rawCommandReply"___("RepyCode As Integer, Detail As String") Declare "void rawCommandReply(int replyCode, const QString & detail)"	COMMENT = "";
	Signal "readyRead"___("") Declare ""	COMMENT = "";
	Signal "stateChanged"___("State As Integer") Declare "void stateChanged(int state)"	COMMENT = "";

End_Class



Class "QHostAddress"

	Sub "clear"___("");	COMMENT = "";
	Function "isInSubnet"___("SubNet As QHostAddress, NetMask As Integer") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "protocol"___("") As "QAbstractSocket::NetworkLayerProtocol";	COMMENT = "";
	Function "scopeId"___("") As "String";	COMMENT = "";
	Sub "setAddress"___("Address As String");	COMMENT = "";
	Sub "setScopeId"___("Id As String");	COMMENT = "";
	Function "toString"___("") As "String";	COMMENT = "";

End_Class



Class "QLocalServer" SuperClass "QObject"

	Sub "close"___("");	COMMENT = "";
	Function "errorString"___("") As "String";	COMMENT = "";
	Function "fullServerName"___("") As "String";	COMMENT = "";
	Function "hasPendingConnections"___("") As "Boolean";	COMMENT = "";
	Function "isListening"___("") As "Boolean";	COMMENT = "";
	Function "listen"___("Name As String") As "Boolean";	COMMENT = "";
	Function "maxPendingConnections"___("") As "Integer";	COMMENT = "";
	Function "nextPendingConnection"___("") As "QLocalSocket";	COMMENT = "";
	Function "serverError"___("") As "QAbstractSocket::SocketError";	COMMENT = "";
	Function "serverName"___("") As "String";	COMMENT = "";
	Sub "setMaxPendingConnections"___("NumConnections As Integer");	COMMENT = "";
	Function "waitForNewConnection"___("MSec As Integer, TimedOut As Boolean") As "Boolean";	COMMENT = "";

End_Class



Class "QLocalSocket" SuperClass "QIODevice"

	Sub "abort"___("");	COMMENT = "";
	Sub "connectToServer"___("Name As String, OpenMode As QLocalSocket::OpenMode");	COMMENT = "";
	Sub "disconnectFromServer"___("");	COMMENT = "";
	Function "error"___("") As "QLocalSocket::LocalSocketError";	COMMENT = "";
	Function "flush"___("") As "Boolean";	COMMENT = "";
	Function "fullServerName"___("") As "String";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "readBufferSize"___("") As "Integer";	COMMENT = "";
	Function "serverName"___("") As "String";	COMMENT = "";
	Sub "setReadBufferSize"___("Size As Integer");	COMMENT = "";
	Function "setSocketDescriptor"___("SocketDescriptor As Integer, SocketState As QLocalSocket::LocalSocketState, OpenMode As QLocalSocket::OpenMode") As "Boolean";	COMMENT = "";
	Function "socketDescriptor"___("") As "Integer";	COMMENT = "";
	Function "state"___("") As "QLocalSocket::LocalSocketState";	COMMENT = "";
	Function "waitForConnected"___("MSecs As Integer") As "Boolean";	COMMENT = "";
	Function "waitForDisconnected"___("MSecs As Integer") As "Boolean";	COMMENT = "";

	Signal "connected"___("") Declare "void connected()"	COMMENT = "";
	Signal "disconnected"___("") Declare "void disconnected()"	COMMENT = "";
	Signal "error"___("SocketError As QLocalSocket::LocalSocketError") Declare "void error(QLocalSocket::LocalSocketError socketError)"	COMMENT = "";
	Signal "stateChanged"___("SocketState As QLocalSocket::LocalSocketState") Declare "void stateChanged(QLocalSocket::LocalSocketState socketState)"	COMMENT = "";

End_Class



Class "QNetworkSession" SuperClass "QObject"

	Function "activeTime"___("") As "Integer";	COMMENT = "";
	Function "bytesReceived"___("") As "Integer";	COMMENT = "";
	Function "bytesWritten"___("") As "Integer";	COMMENT = "";
	//Function "configuration"___("") As "QNetworkConfiguration";	COMMENT = "";
	Function "error"___("") As "QNetworkSession::SessionError";	COMMENT = "";
	Function "errorString"___("") As "String";	COMMENT = "";
	//Function "interface"___("") As "QNetworkInterface";	COMMENT = "";
	Function "isOpen"___("") As "Boolean";	COMMENT = "";
	Function "sessionProperty"___("Key As String") As "QVariant";	COMMENT = "";
	Sub "setSessionProperty"___("Key As String, Value As QVariant");	COMMENT = "";
	Function "state"___("") As "QNetworkSession::State";	COMMENT = "";
	Function "waitForOpened"___("MSecs As Integer") As "Boolean";	COMMENT = "";

	Slot "accept"___("");	COMMENT = "";
	Slot "close"___("");	COMMENT = "";
	Slot "ignore"___("");	COMMENT = "";
	Slot "migrate"___("");	COMMENT = "";
	Slot "open"___("");	COMMENT = "";
	Slot "reject"___("");	COMMENT = "";
	Slot "stop"___("");	COMMENT = "";

	Signal "closed"___("") Declare "void closed()"	COMMENT = "";
	Signal "error"___("Error As QNetworkSession::SessionError") Declare "void error(QNetworkSession::SessionError error)"	COMMENT = "";
	Signal "newConfigurationActivated"___("") Declare "void newConfigurationActivated()"	COMMENT = "";
	Signal "opened"___("") Declare "void opened()"	COMMENT = "";
	Signal "preferredConfigurationChanged"___("Config As QNetworkConfiguration, IsSeamless As Boolean") Declare "void preferredConfigurationChanged(const QNetworkConfiguration & config, bool isSeamless)"	COMMENT = "";
	Signal "stateChanged"___("State As QNetworkSession::State") Declare "void stateChanged(QNetworkSession::State state)"	COMMENT = "";

End_Class



Class "QResource"

	Function "fileName"___("") As "String";	COMMENT = "";
	Function "isCompressed"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "locale"___("") As "QLocale";	COMMENT = "";
	Sub "setFileName"___("File As String");	COMMENT = "";
	Sub "setLocale"___("Locale As QLocale");	COMMENT = "";
	Function "size"___("") As "Integer";	COMMENT = "";

End_Class



Class "QRubberBand" SuperClass "QWidget"

	Sub "move"___("X As Integer, Y As Integer");	COMMENT = "";
	Sub "move2"___("P As QPoint");	COMMENT = "";
	Sub "resize"___("Width As Integer, Height As Integer");	COMMENT = "";
	Sub "resize2"___("Size As QSize");	COMMENT = "";
	Sub "setGeometry"___("X As Integer, Y As Integer, Width As Integer, Height As Integer");	COMMENT = "";
	Function "shape"___("") As "QRubberBand::Shape";	COMMENT = "";

End_Class



Class "QSystemLocale"

	Function "fallbackLocale"___("") As "QLocale";	COMMENT = "";
	Function "query"___("Type As QSystemLocale::QueryType, in As QVariant") As "QVariant";	COMMENT = "";

End_Class



Class "QTimeLine" SuperClass "QObject"

	Property "currentTime" As "Integer";	COMMENT = "";
	Property "curveShape" As "QTimeLine::CurveShape";	COMMENT = "";
	Property "direction" As "QTimeLine::Direction";	COMMENT = "";
	Property "duration" As "Integer";	COMMENT = "";
	Property "loopCount" As "Integer";	COMMENT = "";
	Property "updateInterval" As "Integer";	COMMENT = "";

	Function "currentFrame"___("") As "Integer";	COMMENT = "";
	Function "currentTime"___("") As "Integer";	COMMENT = "";
	Function "currentValue"___("") As "Float";	COMMENT = "";
	Function "curveShape"___("") As "QTimeLine::CurveShape";	COMMENT = "";
	Function "direction"___("") As "QTimeLine::Direction";	COMMENT = "";
	Function "duration"___("") As "Integer";	COMMENT = "";
	Function "endFrame"___("") As "Integer";	COMMENT = "";
	Function "frameForTime"___("Msec As Integer") As "Integer";	COMMENT = "";
	Function "loopCount"___("") As "Integer";	COMMENT = "";
	Sub "setCurveShape"___("Shape As QTimeLine::CurveShape");	COMMENT = "";
	Sub "setDirection"___("Direction As QTimeLine::Direction");	COMMENT = "";
	Sub "setDuration"___("Duration As Integer");	COMMENT = "";
	Sub "setEndFrame"___("Frame As Integer");	COMMENT = "";
	Sub "setFrameRange"___("StartFrame As Integer, EndFrame As Integer");	COMMENT = "";
	Sub "setLoopCount"___("Count As Integer");	COMMENT = "";
	Sub "setStartFrame"___("Frame As Integer");	COMMENT = "";
	Sub "setUpdateInterval"___("Interval As Integer");	COMMENT = "";
	Function "startFrame"___("") As "Integer";	COMMENT = "";
	Function "state"___("") As "QTimeLine::State";	COMMENT = "";
	Function "updateInterval"___("") As "Integer";	COMMENT = "";
	Function "valueForTime"___("Msec As Integer") As "Float";	COMMENT = "";

End_Class



Class "QSessionManager" SuperClass "QObject"

	Function "allowsErrorInteraction"___("") As "Boolean";	COMMENT = "";
	Function "allowsInteraction"___("") As "Boolean";	COMMENT = "";
	Sub "cancel"___("");	COMMENT = "";
	Function "discardCommand"___("") As "QStringList";	COMMENT = "";
	Function "isPhase2"___("") As "Boolean";	COMMENT = "";
	Sub "release"___("");	COMMENT = "";
	Sub "requestPhase2"___("");	COMMENT = "";
	Function "restartCommand"___("") As "QStringList";	COMMENT = "";
	Function "restartHint"___("") As "QSessionManager::RestartHint";	COMMENT = "";
	Function "sessionId"___("") As "String";	COMMENT = "";
	Function "sessionKey"___("") As "String";	COMMENT = "";
	Sub "setDiscardCommand"___("List As QStringList");	COMMENT = "";
	Sub "setManagerProperty"___("Name As String, Value As QStringList");	COMMENT = "";
	Sub "setManagerProperty"___("Name As String, Value As String");	COMMENT = "";
	Sub "setRestartCommand"___("Command As QStringList");	COMMENT = "";
	Sub "setRestartHint"___("Hint As QSessionManager::RestartHint");	COMMENT = "";

End_Class



Class "QBrush"

	Function "color"___("") As "QColor";	COMMENT = "";
	Function "gradient"___("") As "QGradient";	COMMENT = "";
	Function "isOpaque"___("") As "Boolean";	COMMENT = "";
	Function "matrix"___("") As "QMatrix";	COMMENT = "";
	Sub "setColor"___("Color As QColor");	COMMENT = "";
	Sub "setColor2"___("Color As Qt::GlobalColor");	COMMENT = "";
	Sub "setMatrix"___("Matrix As QMatrix");	COMMENT = "";
	Sub "setStyle"___("Style As Qt::BrushStyle");	COMMENT = "";
	Sub "setTexture"___("Pixmap As QPixmap");	COMMENT = "";
	Sub "setTextureImage"___("Image As QImage");	COMMENT = "";
	Sub "setTransform"___("Matrix As QTransform");	COMMENT = "";
	Function "style"___("") As "Qt::BrushStyle";	COMMENT = "";
	Sub "swap"___("Other As QBrush");	COMMENT = "";
	Function "texture"___("") As "QPixmap";	COMMENT = "";
	Function "textureImage"___("") As "QImage";	COMMENT = "";
	Function "transform"___("") As "QTransform";	COMMENT = "";

End_Class



Class "QClipboard" SuperClass "QObject"  // :-)

	Sub "clear"___("Mode As QClipboard::Mode");	COMMENT = "";
	Function "image"___("Mode As QClipboard::Mode") As "QImage";	COMMENT = "";
	Function "mimeData"___("Mode As QClipboard::Mode") As "QMimeData";	COMMENT = "";
	Function "ownsClipboard"___("") As "Boolean";	COMMENT = "";
	Function "ownsFindBuffer"___("") As "Boolean";	COMMENT = "";
	Function "ownsSelection"___("") As "Boolean";	COMMENT = "";
	Function "pixmap"___("Mode As QClipboard::Mode") As "QPixmap";	COMMENT = "";
	Sub "setImage"___("Image As QImage, Mode As QClipboard::Mode");	COMMENT = "";
	Sub "setMimeData"___("Src As QMimeData, Mode As QClipboard::Mode");	COMMENT = "";
	Sub "setPixmap"___("Pixmap As QPixmap, QClipboard::Mode");	COMMENT = "";
	Sub "setText"___("Text As String, QClipboard::Mode");	COMMENT = "";
	Function "supportsFindBuffer"___("") As "Boolean";	COMMENT = "";
	//Function "supportsFindBuffer"___("") As "Boolean";	COMMENT = "";
	Function "text"___("Mode As QClipboard::Mode") As "String";	COMMENT = "";
	Function "text2"___("SubType As String, Mode As QClipboard::Mode") As "String";	COMMENT = "";

	Signal "changed"___("Mode As QClipboard::Mode") Declare "void changed(QClipboard::Mode mode)"	COMMENT = "";
	Signal "dataChanged"___("") Declare "void dataChanged()"	COMMENT = "";
	Signal "findBufferChanged"___("") Declare "void findBufferChanged()"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";

End_Class



Class "QSizeGrip" SuperClass "QWidget"

	Sub "setVisible"___("Visible As Boolean");	COMMENT = "";
	Function "sizeHint"___("") As "QSize";	COMMENT = "";

End_Class
	


Class "QSizePolicy"

	Function "controlType"___("") As "ControlType";	COMMENT = "";
	Function "expandingDirections"___("") As "Qt::Orientations";	COMMENT = "";
	Function "hasHeightForWidth"___("") As "Boolean";	COMMENT = "";
	Function "hasWidthForHeight"___("") As "Boolean";	COMMENT = "";
	Function "horizontalPolicy"___("") As "QSizePolicy::Policy";	COMMENT = "";
	Function "horizontalStretch"___("") As "Integer";	COMMENT = "";
	Sub "setControlType"___("Type As QSizePolicy::ControlType");	COMMENT = "";
	Sub "setHeightForWidth"___("Dependent As Boolean");	COMMENT = "";
	Sub "setHorizontalPolicy"___("Policy As QSizePolicy::Policy");	COMMENT = "";
	Sub "setHorizontalStretch"___("StretchFactor As Integer");	COMMENT = "";
	Sub "setVerticalPolicy"___("Policy As QSizePolicy::Policy");	COMMENT = "";
	Sub "setVerticalStretch"___("StretchFactor As Integer");	COMMENT = "";
	Sub "setWidthForHeight"___("Dependent As Boolean");	COMMENT = "";
	Sub "transpose"___("");	COMMENT = "";
	Function "verticalPolicy"___("") As "Policy As QSizePolicy::Policy";	COMMENT = "";
	Function "verticalStretch"___("") As "Integer";	COMMENT = "";

End_Class



Class "QBitmap" SuperClass "QPixmap"

	Sub "clear"___("");	COMMENT = "";
	Sub "swap"___("Other As QBitmap");	COMMENT = "";
	Function "transformed"___("Matrix As QTransform") As "QBitmap";	COMMENT = "";

End_Class



Class "QPen"

	Function "brush"___("") As "QBrush";	COMMENT = "";
	Function "capStyle"___("") As "Qt::PenCapStyle";	COMMENT = "";
	Function "color"___("") As "QColor";	COMMENT = "";
	Function "dashOffset"___("") As "Float";	COMMENT = "";
	Function "isCosmetic"___("") As "Boolean";	COMMENT = "";
	Function "isSolid"___("") As "Boolean";	COMMENT = "";
	Function "joinStyle"___("") As "Qt::PenJoinStyle";	COMMENT = "";
	Function "miterLimit"___("") As "Float";	COMMENT = "";
	Sub "setBrush"___("Brush As QBrush");	COMMENT = "";
	Sub "setCapStyle"___("Style As Qt::PenCapStyle");	COMMENT = "";
	Sub "setColor"___("Color As QColor");	COMMENT = "";
	Sub "setCosmetic"___("Cosmetic As Boolean");	COMMENT = "";
	Sub "setDashOffset"___("Offset As Float");	COMMENT = "";
	Sub "setJoinStyle"___("Style As Qt::PenJoinStyle");	COMMENT = "";
	Sub "setMiterLimit"___("Limit As Float");	COMMENT = "";
	Sub "setStyle"___("Style As Qt::PenStyle");	COMMENT = "";
	Sub "setWidth"___("Width As Integer");	COMMENT = "";
	Sub "setWidthF"___("Width As Float");	COMMENT = "";
	Function "style"___("") As "Qt::PenStyle";	COMMENT = "";
	Sub "swap"___("Other As QPen");	COMMENT = "";
	Function "width"___("") As "Integer";	COMMENT = "";
	Function "widthF"___("") As "Float";	COMMENT = "";

End_Class



Class "QStackedLayout" SuperClass "QLayout"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentIndex" As "Integer";	COMMENT = "";
	Property "stackingMode" As "QStackedLayout::StackingMode";	COMMENT = "";

	Function "addWidget"___("Widget As QWidget") As "Integer";	COMMENT = "";
	Function "currentIndex"___("") As "Integer";	COMMENT = "";
	Function "currentWidget"___("") As "QWidget";	COMMENT = "";
	Function "insertWidget"___("Index As Integer, Widget As QWidget") As "Integer";	COMMENT = "";
	Sub "setStackingMode"___("StackingMode As QStackedLayout::StackingMode");	COMMENT = "";
	Function "stackingMode"___("") As "QStackedLayout::StackingMode";	COMMENT = "";
	Function "widget"___("Index As Integer") As "QWidget";	COMMENT = "";

End_Class



Class "QFontDatabase"

	Function "bold"___("Family As String, Style As String") As "Boolean";	COMMENT = "";
	Function "families"___("WritingSystem As QFontDatabase::WritingSystem") As "QStringList";	COMMENT = "";
	Function "font"___("Family As String, Style As String, PointSize As Integer") As "QFont";	COMMENT = "";
	Function "isBitmapScalable"___("Family As String, Style As String") As "Boolean";	COMMENT = "";
	Function "isFixedPitch"___("Family As String, Style As String") As "Boolean";	COMMENT = "";
	Function "isScalable"___("Family As String, Style As String") As "Boolean";	COMMENT = "";
	Function "isSmoothlyScalable"___("Family As String, Style As String") As "Boolean";	COMMENT = "";
	Function "italic"___("Family As String, Style As String") As "Boolean";	COMMENT = "Boolean";
	//Function "pointSizes"___("Family As String, Style As String") As "List";	COMMENT = "";
	//Function "smoothSizes"___("Family As String, Style As String") As "List";	COMMENT = "";
	Function "styleString"___("Font As QFont") As "String";	COMMENT = "";
	Function "styleString2"___("FontInfo As QFontInfo") As "String";	COMMENT = "";
	Function "styles"___("Family As String") As "QStringList";	COMMENT = "";
	Function "weight"___("Family As String, Style As String") As "Integer";	COMMENT = "";
	//Function "writingSystems"___("") As "List";	COMMENT = "";
	//Function "writingSystems2"___("Family As String") As "List";	COMMENT = "";

End_Class



Class "QFontInfo"

	Function "bold"___("") As "Boolean";	COMMENT = "";
	Function "exactMatch"___("") As "Boolean";	COMMENT = "";
	Function "family"___("") As "String";	COMMENT = "";
	Function "fixedPitch"___("") As "Boolean";	COMMENT = "";
	Function "italic"___("") As "Boolean";	COMMENT = "";
	Function "pixelSize"___("") As "Integer";	COMMENT = "";
	Function "pointSize"___("") As "Integer";	COMMENT = "";
	Function "pointSizeF"___("") As "Float";	COMMENT = "";
	Function "rawMode"___("") As "Boolean";	COMMENT = "";
	Function "style"___("") As "QFont::Style";	COMMENT = "";
	Function "styleHint"___("") As "QFont::StyleHint";	COMMENT = "";
	Function "styleName"___("") As "String";	COMMENT = "";
	Function "weight"___("") As "Integer";	COMMENT = "";

End_Class



Class "QSound" SuperClass "QObject"

	Function "fileName"___("") As "String";	COMMENT = "";
	Function "isFinished"___("") As "Boolean";	COMMENT = "";
	Function "loops"___("") As "Integer";	COMMENT = "";
	Function "loopsRemaining"___("") As "Integer";	COMMENT = "";
	Sub "setLoops"___("Number As Integer");	COMMENT = "";

	Slot "play"___("");	COMMENT = "";
	Slot "stop"___("");	COMMENT = "";

End_Class



Class "QMimeData" SuperClass "QObject"

	Sub "clear"___("");	COMMENT = "";
	Function "colorData"___("") As "QVariant";	COMMENT = "";
	Function "data"___("MimeType As String") As "QByteArray";	COMMENT = "";
	Function "formats"___("") As "QStringList";	COMMENT = "";
	Function "hasColor"___("") As "Boolean";	COMMENT = "";
	Function "hasFormat"___("MimeType As String") As "Boolean";	COMMENT = "";
	Function "hasHtml"___("") As "Boolean";	COMMENT = "";
	Function "hasImage"___("") As "Boolean";	COMMENT = "";
	Function "hasText"___("") As "Boolean";	COMMENT = "";
	Function "hasUrls"___("") As "Boolean";	COMMENT = "";
	Function "hasHtml"___("") As "String";	COMMENT = "";
	Function "imageData"___("") As "QVariant";	COMMENT = "";
	Sub "removeFormat"___("MimeType As String");	COMMENT = "";
	Sub "setColorData"___("Color As QVariant");	COMMENT = "";
	Sub "setData"___("MimeType As String, Data As QByteArray");	COMMENT = "";
	Sub "setHtml"___("Html As String");	COMMENT = "";
	Sub "setImageData"___("Image As QVariant");	COMMENT = "";
	Sub "setText"___("Text As String");	COMMENT = "";
	//Sub "setUrls"___("Urls As List");	COMMENT = "";
	Function "text"___("") As "String";	COMMENT = "";
	//Function "urls"___("") As "List";	COMMENT = "";

End_Class



Class "QIcon"

	Function "actualSize"___("Size As QSize, Mode As QIcon::Mode") As "QSize";	COMMENT = "";
	Sub "addFile"___("FileName As String, Size As QSize, Mode As QIcon::Mode, State As QIcon::State");	COMMENT = "";
	Sub "addPixmap"___("Pixmap As QPixmap, Mode As QIcon::Mode, State As QIcon::State");	COMMENT = "";
	//Function "availableSizes"___("Mode As QIcon::Mode, State As QIcon::State") As "List";	COMMENT = "";
	Function "cacheKey"___("") As "Integer";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "name"___("") As "String";	COMMENT = "";
	Sub "paint"___("Painter As QPainter, X As Integer, Y As Integer, W As Integer, H As Integer, Alignment As Qt::Alignment, Mode As QIcon::Mode, State As QIcon::State");	COMMENT = "";
	Function "pixmap"___("X As Integer, Y As Integer, Mode As QIcon::Mode, State As QIcon::State") As "QPixmap";	COMMENT = "";
	Function "pixmap2"___("Size As QSize, Mode As QIcon::Mode, State As QIcon::State") As "QPixmap";	COMMENT = "";
	Function "pixmap3"___("Extent As Integer, Mode As QIcon::Mode, State As QIcon::State") As "QPixmap";	COMMENT = "";
	Sub "swap"___("Other As QIcon");	COMMENT = "";

End_Class



Class "QAbstractItemView" SuperClass "QAbstractScrollArea"

	Property "alternatingRowColors" As "Boolean";	COMMENT = "";
	Property "autoScroll" As "Boolean";	COMMENT = "";
	Property "autoScrollMargin" As "Integer";	COMMENT = "";
	Property "defaultDropAction" As "Qt::DropAction";	COMMENT = "";
	Property "dragDropMode" As "QAbstractItemView::DragDropMode";	COMMENT = "";
	Property "dragDropOverwriteMode" As "Boolean";	COMMENT = "";
	Property "dragEnabled" As "Boolean";	COMMENT = "";
	Property "editTriggers" As "QAbstractItemView::EditTriggers";	COMMENT = "";
	Property "horizontalScrollMode" As "QAbstractItemView::ScrollMode";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "selectionBehavior" As "QAbstractItemView::SelectionBehavior";	COMMENT = "";
	Property "selectionMode" As "QAbstractItemView::SelectionMode";	COMMENT = "";
	Property "showDropIndicator" As "Boolean";	COMMENT = "";
	Property "tabKeyNavigation" As "Boolean";	COMMENT = "";
	Property "textElideMode" As "Qt::TextElideMode";	COMMENT = "";
	Property "verticalScrollMode" As "QAbstractItemView::ScrollMode";	COMMENT = "";
	
	Function "alternatingRowColors"___("") As "Boolean"	COMMENT = "";
	Function "autoScrollMargin"___("") As "Integer";	COMMENT = "";
	Sub "closePersistentEditor"___("Index As QModelIndex");	COMMENT = "";
	Function "currentIndex"___("") As "QModelIndex";	COMMENT = "";
	Function "defaultDropAction"___("") As "Qt::DropAction";	COMMENT = "";
	Function "dragDropMode"___("") As "QAbstractItemView::DragDropMode";	COMMENT = "";
	Function "dragDropOverwriteMode"___("") As "Boolean";	COMMENT = "";
	Function "dragEnabled"___("") As "Boolean";	COMMENT = "";
	Function "editTriggers"___("") As "QAbstractItemView::EditTriggers";	COMMENT = "";
	Function "hasAutoScroll"___("") As "Boolean";	COMMENT = "";
	Function "horizontalScrollMode"___("") As "QAbstractItemView::ScrollMode";	COMMENT = "";
	Function "iconSize"___("") As "QSize";	COMMENT = "";
	Function "indexAt "___("Point As QPoint") As "QModelIndex";	COMMENT = "";
	Function "indexWidget "___("Index As QModelIndex") As "QWidget";	COMMENT = "";
	Sub "keyboardSearch"___("Search As String");	COMMENT = "";
	Function "model"___("") As "QAbstractItemModel";	COMMENT = "";
	Sub "openPersistentEditor"___("Index As QModelIndex");	COMMENT = "";
	Function "rootIndex"___("") As "QModelIndex";	COMMENT = "";
	Sub "scrollTo"___("Index As QModelIndex, Hint As QAbstractItemView::ScrollHint");	COMMENT = "";
	Function "selectionBehavior"___("") As "QAbstractItemView::SelectionBehavior";	COMMENT = "";
	Function "selectionMode"___("") As "QAbstractItemView::SelectionMode";	COMMENT = "";
	Function "selectionModel"___("") As "QItemSelectionModel";	COMMENT = "";
	Sub "setAlternatingRowColors"___("Enable As Boolean");	COMMENT = "";
	Sub "setAutoScroll"___("Enable As Boolean");	COMMENT = "";
	Sub "setAutoScrollMargin"___("Margin As Integer");	COMMENT = "";
	Sub "setDefaultDropAction"___("DropAction As Qt::DropAction");	COMMENT = "";
	Sub "setDragDropMode"___("Behavior As QAbstractItemView::DragDropMode");	COMMENT = "";
	Sub "setDragDropOverwriteMode"___("Overwrite As Boolean");	COMMENT = "";
	Sub "setDragEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setDropIndicatorShown"___("Enable As Boolean");	COMMENT = "";
	Sub "setEditTriggers"___("Triggers As QAbstractItemView::EditTriggers");	COMMENT = "";
	Sub "setHorizontalScrollMode"___("Mode As QAbstractItemView::ScrollMode");	COMMENT = "";
	Sub "setIconSize"___("Size As QSize");	COMMENT = "";
	Sub "setIndexWidget"___("Index As QModelIndex, Widget As QWidget");	COMMENT = "";
	Sub "setModel"___("Model As QAbstractItemModel");	COMMENT = "";
	Sub "setSelectionBehavior"___("Behavior As QAbstractItemView::SelectionBehavior");	COMMENT = "";
	Sub "setSelectionMode"___("Mode As QAbstractItemView::SelectionMode");	COMMENT = "";
	Sub "setSelectionModel"___("SelectionModel As QItemSelectionModel");	COMMENT = "";
	Sub "setTabKeyNavigation"___("Enable As Boolean");	COMMENT = "";
	Sub "setTextElideMode"___("Mode As  Qt::TextElideMode");	COMMENT = "";
	Sub "setVerticalScrollMode"___("Mode As QAbstractItemView::ScrollMode");	COMMENT = "";
	Function "showDropIndicator"___("") As "Boolean";	COMMENT = "";
	Function "sizeHintForColumn"___("Column As Integer") As "Integer";	COMMENT = "";
	Function "sizeHintForIndex"___("Index As QModelIndex") As "QSize";	COMMENT = "";
	Function "sizeHintForRow"___("Row As Integer") As "Integer";	COMMENT = "";
	Function "tabKeyNavigation"___("") As "Boolean";	COMMENT = "";
	Function "textElideMode"___("") As "Qt::TextElideMode";	COMMENT = "";
	Function "verticalScrollMode"___("") As "QAbstractItemView::ScrollMode";	COMMENT = "";
	Function "visualRect"___("Index As QModelIndex") As "QRect";	COMMENT = "";

	Slot "clearSelection"___("");	COMMENT = "";
	Slot "edit"___("Index As QModelIndex");	COMMENT = "";
	Slot "reset"___("");	COMMENT = "";
	Slot "scrollToBottom"___("");	COMMENT = "";
	Slot "scrollToTop"___("");	COMMENT = "";
	Slot "selectAll"___("");	COMMENT = "";
	Slot "setCurrentIndex"___("Index As QModelIndex");	COMMENT = "";
	Slot "setRootIndex"___("Index As QModelIndex");	COMMENT = "";
	Slot "update"___("Index As QModelIndex");	COMMENT = "";

	Signal "activated"___("Index As QModelIndex") Declare "void activated(const QModelIndex & index)"	COMMENT = "";
	Signal "clicked"___("Index As QModelIndex") Declare "void clicked(const QModelIndex & index)"	COMMENT = "";
	Signal "doubleClicked"___("Index As QModelIndex") Declare "void doubleClicked(const QModelIndex & index)"	COMMENT = "";
	Signal "entered"___("Index As QModelIndex") Declare "void entered(const QModelIndex & index)"	COMMENT = "";
	Signal "pressed"___("Index As QModelIndex") Declare "void pressed(const QModelIndex & index)"	COMMENT = "";
	Signal "viewportEntered"___("") Declare "void viewportEntered()"	COMMENT = "";

End_Class



Class "QAbstractItemModel" SuperClass "QObject"

	Function "buddy"___("Index As QModelIndex") As "QModelIndex";	COMMENT = "";
	Function "canFetchMore"___("Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "columnCount"___("Parent As QModelIndex") As "Integer";	COMMENT = "";
	Function "data"___("Index As QModelIndex, Role As Integer") As "QVariant";	COMMENT = "";
//	Function "dropMimeData"___("Data As QMimeData, Action As Qt::DropAction, Row As Integer, Column As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Sub "fetchMore"___("Parent As QModelIndex");	COMMENT = "";
	Function "flags"___("Index As QModelIndex") As "Qt::ItemFlags";	COMMENT = "";
	Function "hasChildren"___("Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "hasIndex"___("Row As Integer, Column As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "headerData"___("Section As Integer, Orientation As Qt::Orientation, Role As Integer") As "QVariant";	COMMENT = "";
	Function "index"___("Row As Integer, Column As Integer, Parent As QModelIndex") As "QModelIndex";	COMMENT = "";
	Function "insertColumn"___("Column As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "insertColumns"___("Column As Integer, Count As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "removeRow"___("Row As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "removeRows"___("Row As Integer, Count As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "rowCount"___("Parent As QModelIndex") As "Integer";	COMMENT = "";
	//Function "setData"___("Index As QModelIndex, Value As QVariant, Role As Qt::EditRole") As "Boolean";	COMMENT = "";
	//Function "setHeaderData"___("Section As Integer, Orientation As Qt::Orientation, Value As QVariant, Role As Qt::EditRole") As "Boolean";	COMMENT = "";
	Sub "setSupportedDragActions"___("Actions As Qt::DropActions");	COMMENT = "";
	Function "sibling"___("Row As Integer, Column As Integer, Index As QModelIndex") As "QModelIndex";	COMMENT = "";
	Sub "sort"___("Column As Integer, Order As Qt::SortOrder");	COMMENT = "";
	Function "span"___("Index As QModelIndex") As "QSize";	COMMENT = "";
	Function "supportedDragActions"___("") As "Qt::DropActions";	COMMENT = "";

	Slot "revert"___("");	COMMENT = "";
	Slot "submit"___("");	COMMENT = "";

	Signal "columnsAboutToBeInserted"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void columnsAboutToBeInserted(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "columnsAboutToBeMoved"___("SourceParent As QModelIndex, SourceStart As Integer, SourceEnd As Integer, DestinationParent As QModelIndex, DestinationColumn As Integer") Declare "void columnsAboutToBeMoved(const QModelIndex & sourceParent, int sourceStart, int sourceEnd, const QModelIndex & destinationParent, int destinationColumn)"	COMMENT = "";
	Signal "columnsAboutToBeRemoved"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void columnsAboutToBeRemoved(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "columnsInserted"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void columnsInserted(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "columnsMoved"___("SourceParent As QModelIndex, SourceStart As Integer, SourceEnd As Integer, DestinationParent As QModelIndex, DestinationColumn As Integer") Declare "void columnsMoved(const QModelIndex & sourceParent, int sourceStart, int sourceEnd, const QModelIndex & destinationParent, int destinationColumn)"	COMMENT = "";
	Signal "columnsRemoved"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void columnsRemoved(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "dataChanged"___("TopLeft As QModelIndex, BottomRight As QModelIndex") Declare "void dataChanged(const QModelIndex & topLeft, const QModelIndex & bottomRight)"	COMMENT = "";
	Signal "headerDataChanged"___("Orientation As Qt::Orientation, First As Integer, Last As Integer") Declare "void headerDataChanged(Qt::Orientation orientation, int first, int last)"	COMMENT = "";
	Signal "layoutAboutToBeChanged"___("") Declare "void layoutAboutToBeChanged()"	COMMENT = "";
	Signal "layoutChanged"___("") Declare "void layoutChanged()"	COMMENT = "";
	Signal "modelAboutToBeReset"___("") Declare "void modelAboutToBeReset()"	COMMENT = "";
	Signal "modelReset"___("") Declare "void modelReset()"	COMMENT = "";
	Signal "rowsAboutToBeInserted"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void rowsAboutToBeInserted(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "rowsAboutToBeMoved"___("SourceParent As QModelIndex, SourceStart As Integer, SourceEnd As Integer, DestinationParent As QModelIndex, DestinationRow As Integer") Declare "void rowsAboutToBeMoved(const QModelIndex & sourceParent, int sourceStart, int sourceEnd, const QModelIndex & destinationParent, int destinationRow)"	COMMENT = "";
	Signal "rowsAboutToBeRemoved"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void rowsAboutToBeRemoved(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "rowsInserted"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void rowsInserted(const QModelIndex & parent, int start, int end)"	COMMENT = "";
	Signal "rowsMoved"___("SourceParent As QModelIndex, SourceStart As Integer, SourceEnd As Integer, DestinationParent As QModelIndex, DestinationRow As Integer") Declare "void rowsMoved(const QModelIndex & sourceParent, int sourceStart, int sourceEnd, const QModelIndex & destinationParent, int destinationRow)"	COMMENT = "";
	Signal "rowsRemoved"___("Parent As QModelIndex, Start As Integer, End As Integer") Declare "void rowsRemoved(const QModelIndex & parent, int start, int end)"	COMMENT = "";

End_Class



Class "QTextCursor"

	Function "anchor"___("") As "Integer";	COMMENT = "";
	Function "atBlockEnd"___("") As "Boolean";	COMMENT = "";
	Function "atBlockStart"___("") As "Boolean";	COMMENT = "";
	Function "atEnd"___("") As "Boolean";	COMMENT = "";
	Function "atStart"___("") As "Boolean";	COMMENT = "";
	Sub "beginEditBlock"___("");	COMMENT = "";
	Function "block"___("") As "QTextBlock";	COMMENT = "";
	Function "blockCharFormat"___("") As "QTextCharFormat";	COMMENT = "";
	Function "blockFormat"___("") As "QTextBlockFormat";	COMMENT = "";
	Function "blockNumber"___("") As "Integer";	COMMENT = "";
	Function "charFormat"___("") As "QTextCharFormat";	COMMENT = "";
	Sub "clearSelection"___("");	COMMENT = "";
	Function "columnNumber"___("") As "Integer";	COMMENT = "";
	Function "createList"___("Format As QTextListFormat") As "QTextList";	COMMENT = "";
	Function "createList2"___("Style As QTextListFormat::Style") As "QTextList";	COMMENT = "";
	Function "currentFrame"___("") As "QTextFrame";	COMMENT = "";
	Function "currentList"___("") As "QTextList";	COMMENT = "";
	Function "currentTable"___("") As "QTextTable";	COMMENT = "";
	Sub "deleteChar"___("");	COMMENT = "";
	Sub "deletePreviousChar"___("");	COMMENT = "";
	Function "document"___("") As "QTextDocument";	COMMENT = "";
	Sub "endEditBlock"___("");	COMMENT = "";
	Function "hasComplexSelection"___("") As "Boolean";	COMMENT = "";
	Function "hasSelection"___("") As "Boolean";	COMMENT = "";
	Sub "insertBlock"___("");	COMMENT = "";
	Sub "insertBlock2"___("Format As QTextBlockFormat");	COMMENT = "";
	Sub "insertBlock3"___("Format As QTextBlockFormat, CharFormat As QTextCharFormat");	COMMENT = "";
	Sub "insertFragment"___("Fragment As QTextDocumentFragment");	COMMENT = "";
	Function "insertFrame"___("Format As QTextFrameFormat") As "QTextFrame";	COMMENT = "";
	Sub "insertHtml"___("Html As String");	COMMENT = "";
	Sub "insertImage"___("Name As String");	COMMENT = "";
	Sub "insertImage2"___("Image As QImage, Name As String");	COMMENT = "";
	Function "insertList"___("Format As QTextListFormat") As "QTextList";	COMMENT = "";
	Function "insertList2"___("Style As QTextListFormat::Style") As "QTextList";	COMMENT = "";
	Function "insertTable"___("Rows As Integer, Columns As Integer, Format As QTextCharFormat") As "QTextTable";	COMMENT = "";
	Function "insertTable2"___("Rows As Integer, Columns As Integer") As "QTextTable";	COMMENT = "";
	Sub "insertText"___("Text As String");	COMMENT = "";
	//Sub "insertText2"___("Text As String, Format As QTextFrameFormat");	COMMENT = "";
	Function "isCopyOf"___("Other As QTextCursor") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Sub "joinPreviousEditBlock"___("");	COMMENT = "";
	Function "keepPositionOnInsert"___("") As "Boolean";	COMMENT = "";
	Sub "mergeBlockCharFormat"___("Modifier As QTextCharFormat");	COMMENT = "";
	Sub "mergeBlockFormat"___("Modifier As QTextBlockFormat");	COMMENT = "";
	Sub "mergeCharFormat"___("Modifier As QTextCharFormat");	COMMENT = "";
	Function "movePosition"___("Operation As QTextCursor::MoveOperation, Move As QTextCursor::MoveMode") As "Boolean";	COMMENT = "";
	Function "position"___("") As "Integer";	COMMENT = "";
	Function "positionInBlock"___("") As "Integer";	COMMENT = "";
	Sub "removeSelectedText"___("");	COMMENT = "";
	Sub "select"___("Selection As QTextCursor::SelectionType");	COMMENT = "";
	//Sub "selectedTableCells"___("FirstRow As Integer, NumRows As Integer, FirstColumn As Integer, NumColumns As Integer");	COMMENT = "";
	Function "selectedText"___("") As "String";	COMMENT = "";
	Function "selection"___("") As "QTextDocumentFragment";	COMMENT = "";
	Function "selectionEnd"___("") As "Integer";	COMMENT = "";
	Function "selectionStart"___("") As "Integer";	COMMENT = "";
	Sub "setBlockCharFormat"___("Format As QTextCharFormat");	COMMENT = "";
	Sub "setBlockFormat"___("Format As QTextBlockFormat");	COMMENT = "";
	Sub "setCharFormat"___("Format As QTextCharFormat");	COMMENT = "";
	Sub "setKeepPositionOnInsert"___("B As Boolean");	COMMENT = "";
	Sub "setPosition"___("Pos As Integer, M As QTextCursor::MoveMode");	COMMENT = "";
	Sub "setVerticalMovementX"___("X As Integer");	COMMENT = "";
	Sub "setVisualNavigation"___("B As Boolean");	COMMENT = "";
	Function "verticalMovementX"___("") As "Integer";	COMMENT = "";
	Function "visualNavigation"___("") As "Boolean";	COMMENT = "";

End_Class



Class "QVariant" //SuperClass "QDBusVariant"

  Function "fromBoolean"___("v As Boolean") As "QVariant";	COMMENT = "";
  Function "fromInteger"___("v As Integer") As "QVariant";	COMMENT = "";
  Function "fromFloat"___("v As Float") As "QVariant";	COMMENT = "";
  Function "fromString"___("v As String") As "QVariant";	COMMENT = "";
  Function "fromQStringList"___("v As QStringList") As "QVariant";	COMMENT = "";
  Function "fromDateTime"___("v As DateTime") As "QVariant";	COMMENT = "";

	Function "canConvert"___("T As QVariant::Type") As "Boolean";	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";
	Function "convert"___("T As QVariant::Type") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Sub "swap"___("Other As QVariant");	COMMENT = "";
	Function "toBitArray"___("") As "QBitArray";	COMMENT = "";
	Function "toBool"___("") As "Boolean";	COMMENT = "";
	Function "toByteArray"___("") As "QByteArray";	COMMENT = "";
	Function "toChar"___("") As "QChar";	COMMENT = "";
	Function "toDate"___("") As "QDate";	COMMENT = "";
	Function "toDateTime"___("") As "QDateTime";	COMMENT = "";
	Function "toDouble"___("Ok As Boolean") As "Float";	COMMENT = "";
	Function "toInt"___("Ok As Boolean") As "Integer";	COMMENT = "";
	Function "toLine"___("") As "QLine";	COMMENT = "";
	Function "toLineF"___("") As "QLineF";	COMMENT = "";
	Function "toList"___("") As "List";	COMMENT = "";
	Function "toLocale"___("") As "QLocale";	COMMENT = "";
	Function "toPoint"___("") As "QPoint";	COMMENT = "";
	Function "toPointF"___("") As "QPointF";	COMMENT = "";
	Function "toRect"___("") As "QRect";	COMMENT = "";
	Function "toRectF"___("") As "QRectF";	COMMENT = "";
	Function "toRegExp"___("") As "QRegExp";	COMMENT = "";
	Function "toSize"___("") As "QSize";	COMMENT = "";
	Function "toSizeF"___("") As "QSizeF";	COMMENT = "";
	Function "toString"___("") As "String";	COMMENT = "";
	Function "toStringList"___("") As "QStringList";	COMMENT = "";
	Function "toTime"___("") As "QTime";	COMMENT = "";
	Function "toUrl"___("") As "QUrl";	COMMENT = "";
	Function "type"___("") As "QVariant::Type";	COMMENT = "";

End_Class



Class "QModelIndex"

	Function "child"___("Row As Integer, Column As Integer") As "QModelIndex";	COMMENT = "";
	Function "data"___("Role As Qt::DisplayRole") As "QVariant";	COMMENT = "";
	Function "flags"___("") As "Qt::ItemFlags";	COMMENT = "";
	Function "internalId"___("") As "Integer";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "model"___("") As "QAbstractItemModel";	COMMENT = "";
	Function "parent"___("") As "QModelIndex";	COMMENT = "";
	Function "row"___("") As "Integer";	COMMENT = "";
	Function "sibling"___("Row As Integer, Column As Integer") As "QModelIndex";	COMMENT = "";

End_Class



Class "QPrintPreviewWidget" SuperClass "QWidget"

	Function "currentPage"___("") As "Integer";	COMMENT = "";
	Function "orientation"___("") As "QPrinter::Orientation";	COMMENT = "";
	Function "pageCount"___("") As "Integer";	COMMENT = "";
	Function "viewMode"___("") As "QPrintPreviewWidget::ViewMode";	COMMENT = "";
	Function "zoomFactor"___("") As "Float";	COMMENT = "";
	Function "zoomMode"___("") As "QPrintPreviewWidget::ZoomMode";	COMMENT = "";

	Slot "fitInView"___("");	COMMENT = "";
	Slot "fitToWidth"___("");	COMMENT = "";
	Slot "print"___("");	COMMENT = "";
	Slot "setAllPagesViewMode"___("");	COMMENT = "";
	Slot "setCurrentPage"___("Page As Integer");	COMMENT = "";
	Slot "setFacingPagesViewMode"___("");	COMMENT = "";
	Slot "setLandscapeOrientation"___("");	COMMENT = "";
	Slot "setOrientation"___("Orientation As QPrinter::Orientation");	COMMENT = "";
	Slot "setPortraitOrientation"___("");	COMMENT = "";
	Slot "setSinglePageViewMode"___("");	COMMENT = "";
	Slot "setViewMode"___("Mode As QPrintPreviewWidget::ViewMode");	COMMENT = "";
	Slot "setZoomFactor"___("Factor As Float");	COMMENT = "";
	Slot "setZoomMode"___("ZoomMode As QPrintPreviewWidget::ZoomMode");	COMMENT = "";
	Slot "updatePreview"___("");	COMMENT = "";
	Slot "zoomIn"___("Factor As Float");	COMMENT = "";
	Slot "zoomOut"___("Factor As Float");	COMMENT = "";

End_Class



Class "QAction" SuperClass "QObject"
	
	Property "autoRepeat" As "Boolean";	COMMENT = "";
	Property "checkable" As "Boolean";	COMMENT = "";
	Property "checked" As "Boolean";	COMMENT = "";
	Property "enabled" As "Boolean";	COMMENT = "";
	Property "font" As "QFont";	COMMENT = "";
	Property "icon" As "QIcon";	COMMENT = "";
	Property "iconText" As "String";	COMMENT = "";
	Property "iconVisibleInMenu" As "Boolean";	COMMENT = "";
	Property "menuRole" As "QAction::MenuRole";	COMMENT = "";
	Property "priority" As "QAction::Priority";	COMMENT = "";
	Property "shortcut" As "QKeySequence";	COMMENT = "";
	Property "shortcutContext" As "Qt::ShortcutContext";	COMMENT = "";
	Property "softKeyRole" As "QAction::SoftKeyRole";	COMMENT = "";
	Property "statusTip" As "String";	COMMENT = "";
	Property "text" As "String";	COMMENT = "";
	Property "toolTip" As "String";	COMMENT = "";
	Property "visible" As "Boolean";	COMMENT = "";
	Property "whatsThis" As "String";	COMMENT = "";

	Sub "activate"___("Event As QAction::ActionEvent");	COMMENT = "";
	Function "autoRepeat"___("") As "Boolean";	COMMENT = "";
	Function "data"___("") As "QVariant";	COMMENT = "";
	Function "font"___("") As "QFont";	COMMENT = "";
	Function "icon"___("") As "QIcon";	COMMENT = "";
	Function "iconText"___("") As "String";	COMMENT = "";
	Function "isCheckable"___("") As "Boolean";	COMMENT = "";
	Function "isChecked"___("") As "Boolean";	COMMENT = "";
	Function "isEnabled"___("") As "Boolean";	COMMENT = "";
	Function "isIconVisibleInMenu"___("") As "Boolean";	COMMENT = "";
	Function "isSeparator"___("") As "Boolean";	COMMENT = "";
	Function "isVisible"___("") As "Boolean";	COMMENT = "";
	Function "menu"___("") As "QMenu";	COMMENT = "";
	Function "menuRole"___("") As "QAction::MenuRole";	COMMENT = "";
	Function "parentWidget"___("") As "QWidget";	COMMENT = "";
	Function "priority"___("") As "QAction::Priority";	COMMENT = "";
	Sub "setAutoRepeat"___("Enable As Boolean");	COMMENT = "";
	Sub "setCheckable"___("Checkable As Boolean");	COMMENT = "";
	Sub "setData"___("UserData As QVariant");	COMMENT = "";
	Sub "setFont"___("Font As QFont");	COMMENT = "";
	Sub "setIcon"___("Icon As QIcon");	COMMENT = "";
	Sub "setIconText"___("Text As String");	COMMENT = "";
	Sub "setIconVisibleInMenu"___("Visible As Boolean");	COMMENT = "";
	Sub "setMenu"___("Menu As QMenu");	COMMENT = "";
	Sub "setMenuRole"___("MenuRole As QAction::MenuRole");	COMMENT = "";
	Sub "setPriority"___("Priority As QAction::Priority");	COMMENT = "";
	Sub "setSeparator"___("B As Boolean");	COMMENT = "";
	Sub "setShortcut"___("Shorcut As QKeySequence");	COMMENT = "";
	Sub "setShortcutContext"___("Context As Qt::ShortcutContext");	COMMENT = "";
	Sub "setSoftKeyRole"___("SoftKeyRole As QAction::SoftKeyRole");	COMMENT = "";
	Sub "setStatusTip"___("StatusTip As String");	COMMENT = "";
	Sub "setText"___("Text As String");	COMMENT = "";
	Sub "setToolTip"___("Tip As String");	COMMENT = "";
	Sub "setWhatsThis"___("What As String");	COMMENT = "";
	Function "shortcut"___("") As "QKeySequence";	COMMENT = "";
	Function "shortcutContext"___("") As "Qt::ShortcutContext";	COMMENT = "";
	Function "showStatusText"___("") As "Boolean";	COMMENT = "";
	Function "softKeyRole"___("") As "QAction::SoftKeyRole";	COMMENT = "";
	Function "statusTip"___("") As "String";	COMMENT = "";
	Function "text"___("") As "String";	COMMENT = "";
	Function "toolTip"___("") As "String";	COMMENT = "";
	Function "whatsThis"___("") As "String";	COMMENT = "";

	Slot "hover"___("");	COMMENT = "";
	Slot "setChecked"___("b As Boolean");	COMMENT = "";
	Slot "setDisabled"___("b As Boolean");	COMMENT = "";
	Slot "setEnabled"___("b As Boolean");	COMMENT = "";
	Slot "setVisible"___("b As Boolean");	COMMENT = "";
	Slot "toggle"___("");	COMMENT = "";
	Slot "trigger"___("");	COMMENT = "";
	
	Signal "changed"___("");	COMMENT = "";
	Signal "hovered"___("");	COMMENT = "";
	Signal "toggled"___("Checked As Boolean");	COMMENT = "";
	Signal "triggered"___("Checked As Boolean");	COMMENT = "";

End_Class



Class "QUrl"
	
	Sub "addEncodedQueryItem"___("Key As QByteArray, Value As QByteArray");	COMMENT = "";
	Sub "addQueryItem"___("Key As QByteArray, Value As QByteArray");	COMMENT = "";
	//Function "allEncodedQueryItemValues"___("Key As QByteArray, Value As QByteArray") As "List";	COMMENT = "";
	Function "allQueryItemValues"___("Key As QByteArray") As "QStringList";	COMMENT = "";
	Function "authority"___("") As "String";	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";
	Function "encodedFragment"___("") As "QByteArray";	COMMENT = "";
	Function "encodedHost"___("") As "QByteArray";	COMMENT = "";
	Function "encodedPassword"___("") As "QByteArray";	COMMENT = "";
	Function "encodedPath"___("") As "QByteArray";	COMMENT = "";
	Function "encodedQuery"___("") As "QByteArray";	COMMENT = "";
	Function "encodedQueryItemValue"___("Key As QByteArray") As "QByteArray";	COMMENT = "";
	Function "encodedUserName"___("") As "QByteArray";	COMMENT = "";
	Function "errorString"___("") As "String";	COMMENT = "";
	Function "fragment"___("") As "String";	COMMENT = "";
	Function "hasEncodedQueryItem"___("Key As QByteArray") As "Boolean";	COMMENT = "";
	Function "hasFragment"___("") As "Boolean";	COMMENT = "";
	Function "hasQuery"___("") As "Boolean";	COMMENT = "";
	Function "hasQueryItem"___("Key As String") As "Boolean";	COMMENT = "";
	Function "host"___("") As "String";	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "isLocalFile"___("") As "Boolean";	COMMENT = "";
	Function "isParentOf"___("ChildUrl As QUrl") As "Boolean";	COMMENT = "";
	Function "isRelative"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "password"___("") As "String";	COMMENT = "";
	Function "path"___("") As "String";	COMMENT = "";
	Function "port"___("") As "Integer";	COMMENT = "";
	Function "queryItemValue"___("Key As String") As "String";	COMMENT = "";
	Function "queryPairDelimiter"___("") As "String";	COMMENT = "";
	Function "queryValueDelimiter"___("") As "String";	COMMENT = "";
	Sub "removeAllEncodedQueryItems"___("Key As QByteArray");	COMMENT = "";
	Sub "removeAllQueryItems"___("Key As String");	COMMENT = "";
	Sub "removeEncodedQueryItem "___("Key As QByteArray");	COMMENT = "";
	Sub "removeQueryItem"___("Key As String");	COMMENT = "";
	Function "resolved"___("Relative As QUrl") As "QUrl";	COMMENT = "";
	Function "scheme"___("") As "String";	COMMENT = "";
	Sub "setAuthority"___("Authority As String");	COMMENT = "";
	Sub "setEncodedHost"___("Host As QByteArray");	COMMENT = "";
	Sub "setEncodedPassword"___("Password As QByteArray");	COMMENT = "";
	Sub "setEncodedPath"___("Path As QByteArray");	COMMENT = "";
	Sub "setEncodedQuery"___("Query As QByteArray");	COMMENT = "";
	//Sub "setEncodedUrl"___("EncodedUrl As QByteArray ");	COMMENT = "";
	Sub "setEncodedUserName"___("UserName As QByteArray");	COMMENT = "";
	Sub "setHost"___("Host As String");	COMMENT = "";
	Sub "setPassword"___("Password As String");	COMMENT = "";
	Sub "setPath"___("Path As String");	COMMENT = "";
	Sub "setPort"___("Port As Integer");	COMMENT = "";
	Sub "setQueryDelimiters"___("ValueDelimiter As String, PairDelimeter As String");	COMMENT = "";
	Sub "setScheme"___("Scheme As String");	COMMENT = "";
	Sub "setUrl"___("Url As String");	COMMENT = "";
	Sub "setUserInfo"___("UserInfo As String");	COMMENT = "";
	Sub "setUserName"___("UserName As String");	COMMENT = "";
	Sub "swap"___("Other As QUrl");	COMMENT = "";
	Function "toEncoded"___("Option As QUrl::FormattingOptions") As "QByteArray";	COMMENT = "";
	Function "toLocalFile"___("") As "String";	COMMENT = "";
	Function "toString"___("Option As QUrl::FormattingOptions") As "String";	COMMENT = "";
	Function "topLevelDomain"___("") As "String";	COMMENT = "";
	Function "userInfo"___("") As "String";	COMMENT = "";
	Function "userName"___("") As "String";	COMMENT = "";

  
  Function "fromLocalFile"___("localFile As String") As "QUrl";	COMMENT = "";

End_Class



Class "QUrlInfo"
	
	Function "group"___("") As "String";	COMMENT = "";
	Function "isDir"___("") As "Boolean";	COMMENT = "";
	Function "isExecutable"___("") As "Boolean";	COMMENT = "";
	Function "isFile"___("") As "Boolean";	COMMENT = "";
	Function "isReadable"___("") As "Boolean";	COMMENT = "";
	Function "isSymLink"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "isWritable"___("") As "Boolean";	COMMENT = "";
	Function "lastModified"___("") As "QDateTime";	COMMENT = "";
	Function "lastRead"___("") As "QDateTime";	COMMENT = "";
	Function "name"___("") As "String";	COMMENT = "";
	Function "owner"___("") As "String";	COMMENT = "";
	Function "permissions"___("") As "Integer";	COMMENT = "";
	Sub "setDir"___("B As Boolean");	COMMENT = "";
	Sub "setFile"___("B As Boolean");	COMMENT = "";
	Sub "setGroup"___("S As String");	COMMENT = "";
	Sub "setLastModified"___("Dt As QDateTime");	COMMENT = "";
	Sub "setLastRead"___("Dt As QDateTime");	COMMENT = "";
	Sub "setName"___("Name As String");	COMMENT = "";
	Sub "setOwner"___("S As String");	COMMENT = "";
	Sub "setPermissions"___("P As Integer");	COMMENT = "";
	Sub "setReadable"___("B As Boolean");	COMMENT = "";
	Sub "setSize"___("Size As Integer");	COMMENT = "";
	Sub "setSymLink"___("B As Boolean");	COMMENT = "";
	Sub "setWritable"___("B As Boolean");	COMMENT = "";
	Function "size"___("") As "Integer";	COMMENT = "";

End_Class



Class "QCompleter" SuperClass "QObject"

	Property "caseSensitivity" As "Qt::CaseSensitivity";	COMMENT = "";
	Property "completionColumn" As "Integer";	COMMENT = "";
	Property "completionMode" As "QCompleter::CompletionMode";	COMMENT = "";
	Property "completionPrefix" As "String";	COMMENT = "";
	Property "completionRole" As "Integer";	COMMENT = "";
	Property "maxVisibleItems" As "Integer";	COMMENT = "";
	Property "modelSorting" As "QCompleter::ModelSorting";	COMMENT = "";
	Property "wrapAround" As "Boolean";	COMMENT = "";

	Function "caseSensitivity"___("") As "Qt::CaseSensitivity";	COMMENT = "";
	Function "completionColumn"___("") As "Integer";	COMMENT = "";
	Function "completionCount"___("") As "Integer";	COMMENT = "";
	Function "completionMode"___("") As "QCompleter::CompletionMode";	COMMENT = "";
	Function "completionPrefix"___("") As "String";	COMMENT = "";
	Function "completionRole"___("") As "String";	COMMENT = "";
	Function "currentCompletion"___("") As "String";	COMMENT = "";
	Function "currentIndex"___("") As "QModelIndex";	COMMENT = "";
	Function "currentRow"___("") As "Integer";	COMMENT = "";
	Function "maxVisibleItems"___("") As "Integer";	COMMENT = "";
	Function "modelSorting"___("") As "QCompleter::ModelSorting";	COMMENT = "";
	Function "popup"___("") As "QAbstractItemView";	COMMENT = "";
	Sub "setCaseSensitivity"___("CaseSensitivity As Qt::CaseSensitivity");	COMMENT = "";
	Sub "setCompletionColumn"___("Column As Integer");	COMMENT = "";
	Sub "setCompletionMode"___("Mode As QCompleter::CompletionMode");	COMMENT = "";
	Sub "setCompletionRole"___("Role As Integer");	COMMENT = "";
	Function "setCurrentRow"___("Row As Integer") As "Boolean";	COMMENT = "";
	Sub "setMaxVisibleItems"___("MaxItems As Integer");	COMMENT = "";
	Sub "setModel"___("Model As QAbstractItemModel");	COMMENT = "";
	Sub "setModelSorting"___("Sorting As QCompleter::ModelSorting");	COMMENT = "";
	Sub "setPopup"___("Popup As QAbstractItemView");	COMMENT = "";
	Sub "setWidget"___("Widget As QWidget");	COMMENT = "";
	Function "widget"___("") As "Boolean";	COMMENT = "";
	Function "wrapAround"___("") As "Boolean";	COMMENT = "";

	Slot "complete"___("Rect As QRect");	COMMENT = "";
	Slot "setCompletionPrefix"___("Prefix As String");	COMMENT = "";
	Slot "setWrapAround"___("Wrap As Boolean");	COMMENT = "";

	Signal "activated"___("Text As String") Declare "void activated(const QString & text)"	COMMENT = "";
	Signal "activated2"___("Index As QModelIndex") Declare "void activated(const QModelIndex & index)"	COMMENT = "";
	Signal "highlighted"___("Text As String") Declare "void highlighted(const QString & text)"	COMMENT = "";
	Signal "highlighted2"___("Index As QModelIndex") Declare "void highlighted(const QModelIndex & index)"	COMMENT = "";

End_Class	



Class "QCoreApplication" SuperClass "QObject"

	Property "applicationName" As "String";	COMMENT = "";
	Property "applicationVersion" As "String";	COMMENT = "";
	Property "organizationDomain" As "String";	COMMENT = "";
	Property "organizationName" As "String";	COMMENT = "";

	Function "setEventFilter"___("Filter As QCoreApplication::EventFilter") As "QCoreApplication::EventFilter";	COMMENT = "";
	
	Slot "quit"___("");	COMMENT = "";

	Signal "aboutToQuit"___("") Declare "void aboutToQuit()"	COMMENT = "";

End_Class



Class "QCursor"

	Function "bitmap"___("") As "QBitmap";	COMMENT = "";
	Function "hotSpot"___("") As "QPoint";	COMMENT = "";
	Function "mask"___("") As "QBitmap";	COMMENT = "";
	Function "pixmap"___("") As "QPixmap";	COMMENT = "";
	Sub "setShape"___("Shape As Qt::CursorShape");	COMMENT = "";
	Function "shape"___("") As "Qt::CursorShape";	COMMENT = "";

End_Class



Class "QApplication" SuperClass "QCoreApplication"

	//Property "autoMaximizeThreshold" As "Integer";	COMMENT = "";
	//Property "autoSipEnabled" As "Boolean";	COMMENT = "";
	Property "cursorFlashTime" As "Integer";	COMMENT = "";
	Property "doubleClickInterval" As "Integer";	COMMENT = "";
	Property "globalStrut" As "QSize";	COMMENT = "";
	Property "keyboardInputInterval" As "Integer";	COMMENT = "";
	Property "layoutDirection" As "Qt::LayoutDirection";	COMMENT = "";
	Property "quitOnLastWindowClosed" As "Boolean";	COMMENT = "";
	Property "startDragDistance" As "Integer";	COMMENT = "";
	Property "startDragTime" As "Integer";	COMMENT = "";
	Property "styleSheet" As "String";	COMMENT = "";
	Property "wheelScrollLines" As "Integer";	COMMENT = "";
	Property "windowIcon" As "QIcon";	COMMENT = "";

	Function "inputContext"___("") As "QInputContext";	COMMENT = "";
	Function "isSessionRestored"___("") As "Boolean";	COMMENT = "";
	Function "sessionId"___("") As "String";	COMMENT = "";
	Function "sessionKey"___("") As "String";	COMMENT = "";
	//Sub "setInputContext"___("InputContext AS QInputContext");	COMMENT = "";
	Function "styleSheet"___("") As "String";	COMMENT = "";

	Slot "aboutQt"___("");	COMMENT = "";
	//Slot "autoMaximizeThreshold"___("") As "Integer"; 	COMMENT = "";
	//Slot "autoSipEnabled"___("") As "Boolean";	COMMENT = "";
	Slot "closeAllWindows"___("");	COMMENT = "";
	//Slot "setAutoMaximizeThreshold"___("Threshold As Integer");	COMMENT = "";
	//Slot "setAutoSipEnabled"___("Enabled As Boolean");	COMMENT = "";
	Slot "setStyleSheet"___("Sheet As String");	COMMENT = "";

	//Signal "aboutToReleaseGpuResources"___(""); Declare "void aboutToReleaseGpuResources()"	COMMENT = "";
	//Signal "aboutToUseGpuResources"___(""); Declare "void aboutToUseGpuResources()"	COMMENT = "";
	Signal "commitDataRequest"___(""); Declare "void commitDataRequest(QSessionManager & manager)"	COMMENT = "";
	Signal "focusChanged"___("OldOne As QWidget, NewOne As QWidget"); Declare "void focusChanged(QWidget * old, QWidget * now)"	COMMENT = "";
	Signal "fontDatabaseChanged"___(""); Declare "void fontDatabaseChanged()"	COMMENT = "";
	Signal "lastWindowClosed"___(""); Declare "void lastWindowClosed()"	COMMENT = "";
	Signal "saveStateRequest"___("Manager As QSessionManager"); Declare "void saveStateRequest(QSessionManager & manager)"	COMMENT = "";

End_Class



Class "QActionGroup" SuperClass "QObject"

	Property "enabled" As "Boolean";	COMMENT = "";
	Property "exclusive" As "Boolean";	COMMENT = "";
	Property "visible" As "Boolean";	COMMENT = "";

	Function "actions"___("") As "List";	COMMENT = "";
	Function "addAction"___("Action As QAction") As "QAction";	COMMENT = "";
	Function "addAction"___("Text As String") As "QAction";	COMMENT = "";
	Function "addAction"___("Icon As QIcon, Text As String") As "QAction";	COMMENT = "";
	Function "checkedAction"___("") As "QAction";	COMMENT = "";
	Function "isEnabled"___("") As "Boolean";	COMMENT = "";
	Function "isExclusive"___("") As "Boolean";	COMMENT = "";
	Function "isVisible"___("") As "Boolean";	COMMENT = "";
	Sub "removeAction"___("Action As QAction");	COMMENT = "";

	Slot "setDisabled"___("B As Boolean");	COMMENT = "";
	Slot "setEnabled"___("Enabled As Boolean");	COMMENT = "";
	Slot "setExclusive"___("E As Boolean");	COMMENT = "";
	Slot "setVisible"___("Visible As Boolean");	COMMENT = "";
	
	Signal "hovered"___("Action As QAction"); Declare "void hovered(QAction * action)"	COMMENT = "";
	Signal "triggered"___("Action As QAction"); Declare "void triggered(QAction * action)"	COMMENT = "";

End_Class



Class "QListView" SuperClass "QAbstractItemView"

	Property "batchSize" As "Integer";	COMMENT = "";	
	Property "flow" As "QListView::Flow";	COMMENT = "";
	Property "gridSize" As "QSize";	COMMENT = "";
	Property "isWrapping" As "Boolean";	COMMENT = "";
	Property "layoutMode" As "QListView::LayoutMode";	COMMENT = "";
	Property "modelColumn" As "Integer";	COMMENT = "";
	Property "movement" As "QListView::Movement";	COMMENT = "";
	Property "resizeMode" As "QListView::ResizeMode";	COMMENT = "";
	Property "selectionRectVisible" As "Boolean";	COMMENT = "";
	Property "spacing" As "Integer";	COMMENT = "";
	Property "uniformItemSizes" As "Boolean";	COMMENT = "";
	Property "viewMode" As "QListView::ViewMode";	COMMENT = "";
	Property "wordWrap" As "Boolean";	COMMENT = "";

	Function "batchSize"___("") As "Integer";	COMMENT = "";
	Sub "clearPropertyFlags"___("");	COMMENT = "";
	Function "flow"___("") As "QListView::Flow";	COMMENT = "";
	Function "gridSize"___("") As "QSize";	COMMENT = "";
	Function "isRowHidden"___("Row As Integer") As "Boolean";	COMMENT = "";
	Function "isSelectionRectVisible"___("") As "Boolean";	COMMENT = "";
	Function "isWrapping"___("") As "Boolean";	COMMENT = "";
	Function "layoutMode"___("") As "QListView::LayoutMode";	COMMENT = "";
	Function "modelColumn"___("") As "Integer";	COMMENT = "";
	Function "movement"___("") As "QListView::Movement";	COMMENT = "";
	Function "resizeMode"___("") As "QListView::ResizeMode";	COMMENT = "";

	Sub "setBatchSize"___("BatchSize As Integer");	COMMENT = "";
	Sub "setFlow"___("Flow As QListView::Flow");	COMMENT = "";
	Sub "setGridSize"___("Size As QSize");	COMMENT = "";
	Sub "setLayoutMode"___("Mode As QListView::LayoutMode");	COMMENT = "";
	Sub "setModelColumn"___("Column As Integer");	COMMENT = "";
	Sub "setMovement"___("Movement As QListView::Movement");	COMMENT = "";
	Sub "setResizeMode"___("Mode As QListView::ResizeMode");	COMMENT = "";
	Sub "setRowHidden"___("Row As Integer, Hide As Boolean");	COMMENT = "";
	Sub "setSelectionRectVisible"___("Show As Boolean");	COMMENT = "";
	Sub "setSpacing"___("Space As Integer");	COMMENT = "";
	Sub "setUniformItemSizes"___("Enable As Boolean");	COMMENT = "";
	Sub "setViewMode"___("Mode As QListView::ViewMode");	COMMENT = "";
	Sub "setWordWrap"___("On As Boolean");	COMMENT = "";
	Sub "setWrapping"___("Enable As Boolean");	COMMENT = "";
	Function "spacing"___("") As "Integer";	COMMENT = "";
	Function "uniformItemSizes"___("") As "Boolean";	COMMENT = "";
	Function "viewMode"___("") As "QListView::ViewMode";	COMMENT = "";
	Function "wordWrap"___("") As "Boolean";	COMMENT = "";

	//Signal "indexesMoved"___("Indexes As QModelIndexList"); Declare "void indexesMoved(const QModelIndexList & indexes)"	COMMENT = "";

End_Class



Class "QTreeView" SuperClass "QAbstractItemView"

	Property "allColumnsShowFocus" As "Boolean";	COMMENT = "";	
	Property "animated" As "Boolean";	COMMENT = "";	
	Property "autoExpandDelay" As "Integer";	COMMENT = "";	
	Property "expandsOnDoubleClick" As "Boolean";	COMMENT = "";	
	Property "headerHidden" As "Boolean";	COMMENT = "";	
	Property "indentation" As "Integer";	COMMENT = "";	
	Property "itemsExpandable" As "Boolean";	COMMENT = "";	
	Property "rootIsDecorated" As "Boolean";	COMMENT = "";	
	Property "sortingEnabled" As "Boolean";	COMMENT = "";	
	Property "uniformRowHeights" As "Boolean";	COMMENT = "";	
	Property "wordWrap" As "Boolean";	COMMENT = "";	

	Function "allColumnsShowFocus"___("") As "Boolean";	COMMENT = "";
	Function "autoExpandDelay"___("") As "Integer";	COMMENT = "";
	Function "columnAt"___("X As Integer") As "Integer";	COMMENT = "";
	Function "columnViewportPosition"___("Column As Integer") As "Integer";	COMMENT = "";
	Function "columnWidth"___("Column As Integer") As "Integer";	COMMENT = "";
	Function "expandsOnDoubleClick"___("") As "Boolean";	COMMENT = "";
	Function "header"___("") As "QHeaderView";	COMMENT = "";
	Function "indentation"___("") As "Integer";	COMMENT = "";
	Function "indexAbove"___("Index As QModelIndex") As "QModelIndex";	COMMENT = "";
	Function "indexBelow"___("Index As QModelIndex") As "QModelIndex";	COMMENT = "";
	Function "isAnimated"___("") As "Boolean";	COMMENT = "";
	Function "isColumnHidden"___("Column As Integer") As "Boolean";	COMMENT = "";
	Function "isExpanded"___("Index As QModelIndex") As "Boolean";	COMMENT = "";
	Function "isFirstColumnSpanned"___("Row As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "isHeaderHidden"___("") As "Boolean";	COMMENT = "";
	Function "isRowHidden"___("Row As Integer, Parent As QModelIndex") As "Boolean";	COMMENT = "";
	Function "isSortingEnabled"___("") As "Boolean";	COMMENT = "";
	Function "itemsExpandable"___("") As "Boolean";	COMMENT = "";
	Function "rootIsDecorated"___("") As "Boolean";	COMMENT = "";
	Sub "setAllColumnsShowFocus"___("Enable As Boolean");	COMMENT = "";
	Sub "setAnimated"___("Enable As Boolean");	COMMENT = "";
	Sub "setAutoExpandDelay"___("Delay As Integer");	COMMENT = "";
	Sub "setColumnHidden"___("Column As Integer, Hide As Boolean");	COMMENT = "";
	Sub "setColumnWidth"___("Column As Integer, Width As Integer");	COMMENT = "";
	Sub "setExpanded"___("Index As QModelIndex, Expanded As Boolean");	COMMENT = "";
	Sub "setExpandsOnDoubleClick"___("Enable As Boolean");	COMMENT = "";
	Sub "setFirstColumnSpanned"___("Row As Integer, Parent As QModelIndex, Span As Boolean");	COMMENT = "";
	Sub "setHeader"___("Header As QHeaderView");	COMMENT = "";
	Sub "setHeaderHidden"___("Hide As Boolean");	COMMENT = "";
	Sub "setIndentation"___("I As Integer");	COMMENT = "";
	Sub "setItemsExpandable"___("Enable As Boolean");	COMMENT = "";
	Sub "setRootIsDecorated"___("Show As Boolean");	COMMENT = "";
	Sub "setRowHidden"___("Row As Integer, Parent As QModelIndex, Hide As Boolean");	COMMENT = "";
	Sub "setSortingEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setUniformRowHeights"___("Uniform As Boolean");	COMMENT = "";
	Sub "setWordWrap"___("On As Boolean");	COMMENT = "";
	Sub "sortByColumn"___("Column As Integer, Order As Qt::SortOrder");	COMMENT = "";
	Function "uniformRowHeights"___("") As "Boolean";	COMMENT = "";
	Function "wordWrap"___("") As "Boolean";	COMMENT = "";

	Slot "collapse"___("Index As QModelIndex");	COMMENT = "";
	Slot "collapseAll"___("");	COMMENT = "";
	Slot "expand"___("Index As QModelIndex");	COMMENT = "";
	Slot "expandAll"___("");	COMMENT = "";
	Slot "expandToDepth"___("Depth As Integer");	COMMENT = "";
	Slot "hideColumn"___("Column As Integer");	COMMENT = "";
	Slot "resizeColumnToContents"___("Column As Integer");	COMMENT = "";
	Slot "showColumn"___("Column As Integer");	COMMENT = "";

	Signal "collapsed"___("Index As QModelIndex"); Declare "void collapsed(const QModelIndex & index)"	COMMENT = "";
	Signal "expanded"___("Index As QModelIndex"); Declare "void expanded(const QModelIndex & index)"	COMMENT = "";

End_Class



Class "QHeaderView" SuperClass "QAbstractItemView"

	Property "cascadingSectionResizes" As "Boolean";	COMMENT = "";	
	Property "defaultAlignment" As "Qt::Alignment";	COMMENT = "";	
	Property "defaultSectionSize" As "Integer";	COMMENT = "";	
	Property "highlightSections" As "Boolean";	COMMENT = "";	
	Property "minimumSectionSize" As "Integer";	COMMENT = "";	
	Property "showSortIndicator" As "Boolean";	COMMENT = "";	
	Property "stretchLastSection" As "Boolean";	COMMENT = "";
	
	Function "cascadingSectionResizes"___("") As "Boolean";	COMMENT = "";
	Function "count"___("") As "Integer";	COMMENT = "";
	Function "defaultAlignment"___("") As "Qt::Alignment";	COMMENT = "";
	Function "defaultSectionSize"___("") As "Integer";	COMMENT = "";
	Function "hiddenSectionCount"___("") As "Integer";	COMMENT = "";
	Sub "hideSection"___("LogicalIndex As Integer");	COMMENT = "";
	Function "highlightSections"___("") As "Boolean";	COMMENT = "";
	Function "isClickable"___("") As "Boolean";	COMMENT = "";
	Function "isMovable"___("") As "Boolean";	COMMENT = "";
	Function "isSectionHidden"___("LogicalIndex As Integer") As "Boolean";	COMMENT = "";
	Function "isSortIndicatorShown"___("") As "Boolean";	COMMENT = "";
	Function "length"___("") As "Integer";	COMMENT = "";
	Function "logicalIndex"___("VisualIndex As Integer") As "Integer";	COMMENT = "";
	Function "logicalIndexAt"___("Position As Integer") As "Integer";	COMMENT = "";
	Function "logicalIndexAt"___("X As Integer, Y As Integer") As "Integer";	COMMENT = "";
	Function "minimumSectionSize"___("") As "Integer";	COMMENT = "";
	Sub "moveSection"___("From As Integer, To As Integer");	COMMENT = "";
	Function "offset"___("") As "Integer";	COMMENT = "";
	Function "orientation"___("") As "Qt::Orientation";	COMMENT = "";
	Function "resizeMode"___("LogicalIndex As Integer") As "QHeaderView::ResizeMode";	COMMENT = "";
	Sub "resizeSection"___("LogicalIndex As Integer, Size As Integer");	COMMENT = "";
	Sub "resizeSections"___("Mode As QHeaderView::ResizeMode");	COMMENT = "";
	Function "restoreState"___("State As QByteArray") As "Boolean";	COMMENT = "";
	Function "saveState"___("") As "QByteArray";	COMMENT = "";
	Function "sectionPosition"___("LogicalIndex As Integer") As "Integer";	COMMENT = "";
	Function "sectionSize"___("LogicalIndex As Integer") As "Integer";	COMMENT = "";
	Function "sectionSizeHint"___("LogicalIndex As Integer") As "Integer";	COMMENT = "";
	Function "sectionViewportPosition"___("LogicalIndex As Integer") As "Integer";	COMMENT = "";
	Function "sectionsHidden"___("") As "Boolean";	COMMENT = "";
	Function "sectionsMoved"___("") As "Boolean";	COMMENT = "";
	Sub "setCascadingSectionResizes"___("Enable As Boolean");	COMMENT = "";
	Sub "setClickable"___("Clickable As Boolean");	COMMENT = "";
	Sub "setDefaultAlignment"___("Alignment As Qt::Alignment");	COMMENT = "";
	Sub "setDefaultSectionSize"___("Size As Integer");	COMMENT = "";
	Sub "setHighlightSections"___("HighLight As Boolean");	COMMENT = "";
	Sub "setMinimumSectionSize"___("Size As Integer");	COMMENT = "";
	Sub "setMovable"___("Movable As Boolean");	COMMENT = "";
	Sub "setResizeMode"___("Mode As QHeaderView::ResizeMode");	COMMENT = "";
	Sub "setResizeMode"___("LogicalIndex As Integer, Mode As QHeaderView::ResizeMode");	COMMENT = "";
	Sub "setSectionHidden"___("LogicalIndex As Integer, Hide As Boolean");	COMMENT = "";
	Sub "setSortIndicator"___("LogicalIndex As Integer, Order As Qt::SortOrder");	COMMENT = "";
	Sub "setSortIndicatorShown"___("Show As Boolean");	COMMENT = "";
	Sub "setStretchLastSection"___("Stretch As Boolean");	COMMENT = "";
	Sub "showSection"___("LogicalIndex As Integer");	COMMENT = "";
	Function "sortIndicatorOrder"___("") As "Qt::SortOrder";	COMMENT = "";
	Function "sortIndicatorSection"___("") As "Integer";	COMMENT = "";
	Function "stretchLastSection"___("") As "Boolean";	COMMENT = "";
	Function "stretchSectionCount"___("") As "Integer";	COMMENT = "";
	Sub "swapSections"___("First As Integer, Second As Integer");	COMMENT = "";
	Function "visualIndex"___("LogicalIndex As Integer") As "Integer";	COMMENT = "";
	Function "visualIndexAt"___("Position As Integer") As "Integer";	COMMENT = "";

	Slot "headerDataChanged"___("Orientation As Qt::Orientation, LogicalFirst As Integer, LogicalLast As Integer");	COMMENT = "";
	Slot "setOffset"___("Offset As Integer");	COMMENT = "";
	Slot "setOffsetToLastSection"___("");	COMMENT = "";
	Slot "setOffsetToSectionPosition"___("VisualIndex As Integer");	COMMENT = "";

	Signal "geometriesChanged"___(""); Declare "void geometriesChanged()"	COMMENT = "";
	Signal "sectionAutoResize"___("LogicalIndex As Integer, Mode As QHeaderView::ResizeMode"); Declare "void sectionAutoResize(int logicalIndex, QHeaderView::ResizeMode mode)"	COMMENT = "";
	Signal "sectionClicked"___("LogicalIndex As Integer"); Declare "void sectionClicked(int logicalIndex)"	COMMENT = "";
	Signal "sectionCountChanged"___("OldCount As Integer, NewCount As Integer"); Declare "void sectionCountChanged(int oldCount, int newCount)"	COMMENT = "";
	Signal "sectionDoubleClicked"___("LogicalIndex As Integer"); Declare "void sectionDoubleClicked(int logicalIndex)"	COMMENT = "";
	Signal "sectionEntered"___("LogicalIndex As Integer"); Declare "void sectionEntered(int logicalIndex)"	COMMENT = "";
	Signal "sectionHandleDoubleClicked"___("LogicalIndex As Integer"); Declare "void sectionHandleDoubleClicked(int logicalIndex)"	COMMENT = "";
	Signal "sectionMoved"___("LogicalIndex As Integer, OldVisualIndex As Integer, NewVisualIndex As Integer"); Declare "void sectionMoved(int logicalIndex, int oldVisualIndex, int newVisualIndex)"	COMMENT = "";
	Signal "sectionPressed"___("LogicalIndex As Integer"); Declare "void sectionPressed(int logicalIndex)"	COMMENT = "";
	Signal "sectionResized"___("LogicalIndex As Integer, OldSize As Integer, NewSize As Integer"); Declare "void sectionResized(int logicalIndex, int oldSize, int newSize)"	COMMENT = "";
	Signal "sortIndicatorChanged"___("LogicalIndex As Integer, Order As Qt::SortOrder"); Declare "void sortIndicatorChanged(int logicalIndex, Qt::SortOrder order)"	COMMENT = "";

End_Class



Class "QTableView" SuperClass "QAbstractItemView"

	Property "cornerButtonEnabled" As "Boolean";	COMMENT = "";
	Property "gridStyle" As "Qt::PenStyle";	COMMENT = "";
	Property "showGrid" As "Boolean";	COMMENT = "";
	Property "sortingEnabled" As "Boolean";	COMMENT = "";
	Property "wordWrap" As "Boolean";	COMMENT = "";

	Sub "clearSpans"___("");	COMMENT = "";
	Function "columnAt"___("X As Integer") As "Integer";	COMMENT = "";
	Function "columnSpan"___("Row As Integer, Column As Integer") As "Integer";	COMMENT = "";
	Function "columnViewportPosition"___("Column As Integer") As "Integer";	COMMENT = "";
	Function "columnWidth"___("Column As Integer") As "Integer";	COMMENT = "";
	Function "gridStyle"___("") As "Qt::PenStyle";	COMMENT = "";
	Function "horizontalHeader"___("") As "QHeaderView";	COMMENT = "";
	Function "isColumnHidden"___("Column As Integer") As "Boolean";	COMMENT = "";
	Function "isCornerButtonEnabled"___("") As "Boolean";	COMMENT = "";
	Function "isRowHidden"___("Row As Integer") As "Boolean";	COMMENT = "";
	Function "isSortingEnabled"___("") As "Boolean";	COMMENT = "";
	Function "rowAt"___("Y As Integer") As "Integer";	COMMENT = "";
	Function "rowHeight"___("Row As Integer") As "Integer";	COMMENT = "";
	Function "rowSpan"___("Row As Integer, Column As Integer") As "Integer";	COMMENT = "";
	Function "rowViewportPosition"___("Row As Integer") As "Integer";	COMMENT = "";
	Sub "setColumnHidden"___("Column As Integer, Hide As Boolean");	COMMENT = "";
	Sub "setColumnWidth"___("Column As Integer, Width As Integer");	COMMENT = "";
	Sub "setCornerButtonEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setGridStyle"___("Style As Qt::PenStyle");	COMMENT = "";
	Sub "setHorizontalHeader"___("Header As QHeaderView");	COMMENT = "";
	Sub "setRowHeight"___("Row As Integer, Height As Integer");	COMMENT = "";
	Sub "setRowHidden"___("Row As Integer, Hide As Boolean");	COMMENT = "";
	Sub "setSortingEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setSpan"___("Row As Integer, Column As Integer, RowSpanCount As Integer, ColumnSpanCount As Integer");	COMMENT = "";
	Sub "setVerticalHeader"___("Header As QHeaderView");	COMMENT = "";
	Sub "setWordWrap"___("On As Boolean");	COMMENT = "";
	Function "showGrid"___("") As "Boolean";	COMMENT = "";
	Sub "sortByColumn"___("Column As Integer, Order As Qt::SortOrder");	COMMENT = "";
	Function "verticalHeader"___("") As "QHeaderView";	COMMENT = "";
	Function "wordWrap"___("") As "Boolean";	COMMENT = "";

	Slot "hideColumn"___("Column As Integer");	COMMENT = "";
	Slot "hideRow"___("Row As Integer");	COMMENT = "";
	Slot "resizeColumnToContents"___("Column As Integer");	COMMENT = "";
	Slot "resizeColumnsToContents"___("");	COMMENT = "";
	Slot "resizeRowToContents"___("Row As Integer");	COMMENT = "";
	Slot "resizeRowsToContents"___("");	COMMENT = "";
	Slot "selectColumn"___("Column As Integer");	COMMENT = "";
	Slot "selectRow"___("Row As Integer");	COMMENT = "";
	Slot "setShowGrid"___("Show As Boolean");	COMMENT = "";
	Slot "showColumn"___("Column As Integer");	COMMENT = "";
	Slot "showRow"___("Row As Integer");	COMMENT = "";

End_Class



Class "QInputDialog" SuperClass "QDialog"

	Property "cancelButtonText" As "String";	COMMENT = "";
	Property "comboBoxEditable" As "Boolean";	COMMENT = "";
	Property "comboBoxItems" As "QStringList";	COMMENT = "";
	Property "doubleDecimals" As "Integer";	COMMENT = "";
	Property "doubleMaximum" As "Float";	COMMENT = "";
	Property "doubleMinimum" As "Float";	COMMENT = "";
	Property "doubleValue" As "Integer";	COMMENT = "";
	Property "inputMode" As "QInputDialog::InputMode";	COMMENT = "";
	Property "intMaximum" As "Integer";	COMMENT = "";
	Property "intMinimum" As "Integer";	COMMENT = "";
	Property "intStep" As "Integer";	COMMENT = "";
	Property "intValue" As "Integer";	COMMENT = "";
	Property "labelText" As "String";	COMMENT = "";
	Property "okButtonText" As "String";	COMMENT = "";
	Property "options" As "QInputDialog::InputDialogOptions";	COMMENT = "";
	Property "textEchoMode" As "QLineEdit::EchoMode";	COMMENT = "";
	Property "textValue" As "String";	COMMENT = "";

	Function "cancelButtonText"___("") As "String";	COMMENT = "";
	Function "comboBoxItems"___("") As "QStringList";	COMMENT = "";
	Function "doubleDecimals"___("") As "Integer";	COMMENT = "";
	Function "doubleMaximum"___("") As "Float";	COMMENT = "";
	Function "doubleMinimum"___("") As "Float";	COMMENT = "";
	Function "doubleValue"___("") As "Float";	COMMENT = "";
	Function "inputMode"___("") As "QInputDialog::InputMode";	COMMENT = "";
	Function "intMaximum"___("") As "Integer";	COMMENT = "";
	Function "intMinimum"___("") As "Integer";	COMMENT = "";
	Function "intStep"___("") As "Integer";	COMMENT = "";
	Function "intValue"___("") As "Integer";	COMMENT = "";
	Function "isComboBoxEditable"___("") As "Boolean";	COMMENT = "";
	Function "labelText"___("") As "String";	COMMENT = "";
	Function "okButtonText"___("") As "String";	COMMENT = "";
	Function "options"___("") As "QInputDialog::InputDialogOptions";	COMMENT = "";

	Sub "setCancelButtonText"___("Text As String");	COMMENT = "";
	Sub "setComboBoxEditable"___("Editable As Boolean");	COMMENT = "";
	Sub "setComboBoxItems"___("Items As QStringList");	COMMENT = "";
	Sub "setDoubleDecimals"___("Decimals As Integer");	COMMENT = "";
	Sub "setDoubleMaximum"___("Max As Float");	COMMENT = "";
	Sub "setDoubleMinimum"___("Min As Float");	COMMENT = "";
	Sub "setDoubleValue"___("Value As Float");	COMMENT = "";
	Sub "setInputMode"___("InputMode As QInputDialog::InputMode");	COMMENT = "";
	Sub "setIntMaximum"___("Max As Integer");	COMMENT = "";
	Sub "setIntMinimum"___("Min As Integer");	COMMENT = "";
	Sub "setIntStep"___("Step As Integer");	COMMENT = "";
	Sub "setIntValue"___("Value As Integer");	COMMENT = "";
	Sub "setLabelText"___("Text As String");	COMMENT = "";
	Sub "setOkButtonText"___("Text As String");	COMMENT = "";
	Sub "setOption"___("Option As QInputDialog::InputDialogOption, On As Boolean");	COMMENT = "";
	Sub "setTextEchoMode"___("Mode As QLineEdit::EchoMode");	COMMENT = "";
	Sub "setTextValue"___("Text As String");	COMMENT = "";
	Function "textEchoMode"___("") As "QLineEdit::EchoMode";	COMMENT = "";
	Function "textValue"___("") As "String";	COMMENT = "";

	Signal "doubleValueChanged"___("Value As Double") Declare "void doubleValueChanged(double value)"	COMMENT = "";
	Signal "doubleValueSelected"___("Value As Double") Declare "void doubleValueSelected(double value)"	COMMENT = "";
	Signal "intValueChanged"___("Value As Integer") Declare "void intValueChanged(int value)"	COMMENT = "";
	Signal "intValueSelected"___("Value As Integer") Declare "void intValueSelected(int value)"	COMMENT = "";
	Signal "textValueChanged"___("Text As String") Declare "void textValueChanged(const QString & text)"	COMMENT = "";
	Signal "textValueSelected"___("Text As String") Declare "void textValueSelected(const QString & text)"	COMMENT = "";

End_Class



Class "QColumnView" SuperClass "QAbstractItemView"

	Property "resizeGripsVisible" As "Boolean";	COMMENT = "";

	//Function "columnWidths"___("") As "List";	COMMENT = "";
	Function "previewWidget"___("") As "QWidget";	COMMENT = "";
	Function "resizeGripsVisible"___("") As "Boolean";	COMMENT = "";
	//Sub "setColumnWidths"___("Widths As List");	COMMENT = "";
	Sub "setPreviewWidget"___("Widget As QWidget");	COMMENT = "";
	Sub "setResizeGripsVisible"___("Visible As Boolean");	COMMENT = "";

	Signal "updatePreviewWidget"___("Index As QModelIndex") Declare "void updatePreviewWidget(const QModelIndex & index)"	COMMENT = "";

End_Class



Class "QValidator" SuperClass "QObject"

	Sub "fixup"___("Input As String");	COMMENT = "";
	Function "locale"___("") As "QLocale";	COMMENT = "";
	Sub "setLocale"___("Locale As QLocale");	COMMENT = "";
	Function "validate"___("Input As String, Pos As Integer") As "QValidator::State";	COMMENT = "";

End_Class



Class "QRegExpValidator" SuperClass "QValidator"

	Property "regExp" As "QRegExp";	COMMENT = "";

	Function "regExp"___("") As "QRegExp";	COMMENT = "";
	Sub "setRegExp"___("Rx As QRegExp");	COMMENT = "";

End_Class



Class "QFont"

	Function "bold"___("") As "Boolean";	COMMENT = "";
	Function "defaultFamily"___("") As "String";	COMMENT = "";
	Function "exactMatch"___("") As "Boolean";	COMMENT = "";
	Function "family"___("") As "String";	COMMENT = "";
	Function "fixedPitch"___("") As "Boolean";	COMMENT = "";
	Function "fromString"___("Descrip As String") As "Boolean";	COMMENT = "";
	Function "italic"___("") As "Boolean";	COMMENT = "";
	Function "lastResortFamily"___("") As "String";	COMMENT = "";
	Function "lastResortFont"___("") As "String";	COMMENT = "";
	Function "letterSpacing"___("") As "Float";	COMMENT = "";
	Function "letterSpacingType"___("") As "QFont::SpacingType";	COMMENT = "";
	Function "overline"___("") As "Boolean";	COMMENT = "";
	Function "pixelSize"___("") As "Integer";	COMMENT = "";
	Function "pointSize"___("") As "Integer";	COMMENT = "";
	Function "pointSizeF"___("") As "Float";	COMMENT = "";
	Function "resolve"___("Other As QFont") As "QFont";	COMMENT = "";
	Sub "setBold"___("Enable As Boolean");	COMMENT = "";
	Sub "setCapitalization"___("Caps As QFont::Capitalization");	COMMENT = "";
	Sub "setFamily"___("Family As String");	COMMENT = "";
	Sub "setFixedPitch"___("Enable As Boolean");	COMMENT = "";
	Sub "setItalic"___("Enable As Boolean");	COMMENT = "";
	Sub "setLetterSpacing"___("Type As QFont::SpacingType, Spacing As Float");	COMMENT = "";
	Sub "setOverline"___("Enable As Boolean");	COMMENT = "";
	Sub "setPixelSize"___("PixelSize As Integer");	COMMENT = "";
	Sub "setPointSize"___("PointSize As Integer");	COMMENT = "";
	Sub "setPointSizeF"___("PointSize As Float");	COMMENT = "";
	Sub "setStretch"___("Factor As Integer");	COMMENT = "";
	Sub "setStrikeOut"___("Enable As Boolean");	COMMENT = "";
	Sub "setStyle"___("Style As QFont::Style");	COMMENT = "";
	Sub "setStyleStrategy"___("S As QFont::StyleStrategy");	COMMENT = "";
	Sub "setUnderline"___("Enable As Boolean");	COMMENT = "";
	Sub "setWeight"___("Weight As Integer");	COMMENT = "";
	Sub "setWordSpacing"___("Spacing As Float");	COMMENT = "";
	Function "stretch"___("") As "Integer";	COMMENT = "";
	Function "strikeOut"___("") As "Boolean";	COMMENT = "";
	Function "style"___("") As "QFont::Style";	COMMENT = "";
	Function "styleStrategy"___("") As "QFont::StyleStrategy";	COMMENT = "";
	Function "toString"___("") As "String";	COMMENT = "";
	Function "underline"___("") As "Boolean";	COMMENT = "";
	Function "weight"___("") As "Integer";	COMMENT = "";
	Function "wordSpacing"___("") As "Float";	COMMENT = "";

End_Class



Class "QColor"

	Function "alpha"___("") As "Integer";	COMMENT = "";
	Function "alphaF"___("") As "Float";	COMMENT = "";
	Function "black"___("") As "Integer";	COMMENT = "";
	Function "blackF"___("") As "Float";	COMMENT = "";
	Function "blue"___("") As "Integer";	COMMENT = "";
	Function "blueF"___("") As "Float";	COMMENT = "";
	Function "convertTo"___("ColorSpec As QColor::Spec") As "QColor";	COMMENT = "";
	Function "cyan"___("") As "Integer";	COMMENT = "";
	Function "cyanF"___("") As "Float";	COMMENT = "";
	Function "darker"___("Factor As Integer") As "QColor";	COMMENT = "";
	//Sub "getCmyk"___("C As Integer, M As Integer, Y As Integer, K As Integer, A As Integer");	COMMENT = "";
	//Sub "getCmykF"___("C As Float, M As Float, Y As Float, K As Float, A As Float");	COMMENT = "";
	//Sub "getHsl"___("H As Integer, S As Integer, L As Integer, A As Integer");	COMMENT = "";
	//Sub "getHslF"___("H As Float, S As Float, L As Float, A As Float");	COMMENT = "";
	//Sub "getHsv"___("H As Integer, S As Integer, V As Integer, A As Integer");	COMMENT = "";
	//Sub "getHsvF"___("H As Float, S As Float, V As Float, A As Float");	COMMENT = "";
	//Sub "getRgb"___("R As Integer, G As Integer, B As Integer, A As Integer");	COMMENT = "";
	//Sub "getRgbF"___("R As Float, G As Float, B As Float, A As Float");	COMMENT = "";
	Function "green"___("") As "Integer";	COMMENT = "";
	Function "greenF"___("") As "Float";	COMMENT = "";
	Function "hslHue"___("") As "Integer";	COMMENT = "";
	Function "hslHueF"___("") As "Float";	COMMENT = "";
	Function "hslSaturation"___("") As "Integer";	COMMENT = "";
	Function "hslSaturationF"___("") As "Float";	COMMENT = "";
	Function "hsvHue"___("") As "Integer";	COMMENT = "";
	Function "hsvHueF"___("") As "Float";	COMMENT = "";
	Function "hsvSaturation"___("") As "Integer";	COMMENT = "";
	Function "hsvSaturationF"___("") As "Float";	COMMENT = "";
	Function "hue"___("") As "Integer";	COMMENT = "";
	Function "hueF"___("") As "Float";	COMMENT = "";
	Function "lighter"___("Factor As Integer") As "QColor";	COMMENT = "";
	Function "lightness"___("") As "Integer";	COMMENT = "";
	Function "lightnessF"___("") As "Float";	COMMENT = "";
	Function "magenta"___("") As "Integer";	COMMENT = "";
	Function "magentaF"___("") As "Float";	COMMENT = "";
	Function "name"___("") As "String";	COMMENT = "";
	Function "red"___("") As "Integer";	COMMENT = "";
	Function "redF"___("") As "Float";	COMMENT = "";
	Function "rgb"___("") As "QRgb";	COMMENT = "";
	Function "rgba"___("") As "QRgb";	COMMENT = "";
	Function "saturation"___("") As "Integer";	COMMENT = "";
	Function "saturationF"___("") As "Float";	COMMENT = "";
	Sub"setAlpha"___("Alpha As Integer");	COMMENT = "";
	Sub "setAlphaF"___("Alpha As Float");	COMMENT = "";
	Sub "setBlue"___("Blue As Integer");	COMMENT = "";
	Sub "setBlueF"___("Blue As Float");	COMMENT = "";
	Sub "setCmyk"___("C As Integer, M As Integer, Y As Integer, K As Integer, A As Integer");	COMMENT = "";
	Sub "setCmykF"___("C As Float, M As Float, Y As Float, K As Float, A As Float");	COMMENT = "";
	Sub "setGreen"___("Green As Integer");	COMMENT = "";
	Sub "setGreenF"___("Green As Float");	COMMENT = "";
	Sub "setHsl"___("H As Integer, S As Integer, L As Integer, A As Integer");	COMMENT = "";
	Sub "setHslF"___("H As Float, S As Float, L As Float, A As Float");	COMMENT = "";
	Sub "setHsv"___("H As Integer, S As Integer, V As Integer, A As Integer");	COMMENT = "";
	Sub "setHsvF"___("H As Float, S As Float, V As Float, A As Float");	COMMENT = "";
	Sub "setNamedColor"___("Name As String");	COMMENT = "";
	Sub "setRed"___("Red As Integer");	COMMENT = "";
	Sub "setRedF"___("Red As Float");	COMMENT = "";
	Sub "setRgb"___("R As Integer, G As Integer, B As Integer, A As Integer");	COMMENT = "";
	Sub "setRgbF"___("R As Float, G As Float, B As Float, A As Float");	COMMENT = "";
	Function "spec"___("") As "QColor::Spec";	COMMENT = "";
	Function "toCmyk"___("") As "QColor";	COMMENT = "";
	Function "toHsl"___("") As "QColor";	COMMENT = "";
	Function "toHsv"___("") As "QColor";	COMMENT = "";
	Function "toRgb"___("") As "QColor";	COMMENT = "";
	Function "value"___("") As "Integer";	COMMENT = "";
	Function "valueF"___("") As "Float";	COMMENT = "";
	Function "yellow"___("") As "Integer";	COMMENT = "";
	Function "yellowF"___("") As "Float";	COMMENT = "";

End_Class



Class "QTableWidgetItem"

	Function "background"___("") As "QBrush";	COMMENT = "";
	Function "checkState"___("") As "Qt::CheckState";	COMMENT = "";
	Function "column"___("") As "Integer";	COMMENT = "";
	Function "flags"___("") As "Qt::ItemFlags";	COMMENT = "";
	Function "font"___("") As "QFont";	COMMENT = "";
	Function "foreground"___("") As "QBrush";	COMMENT = "";
	Function "icon"___("") As "QIcon";	COMMENT = "";
	Function "isSelected"___("") As "Boolean";	COMMENT = "";
	//Sub "read"___("In As QDataStream");	COMMENT = "";
	Function "row"___("") As "Integer";	COMMENT = "";
	Sub "setBackground"___("Brush As QBrush");	COMMENT = "";
	Sub "setCheckState"___("State As Qt::CheckState");	COMMENT = "";
	Sub "setFlags"___("Flags As Qt::ItemFlags");	COMMENT = "";
	Sub "setFont"___("Font As QFont");	COMMENT = "";
	Sub "setForeground"___("Brush As QBrush");	COMMENT = "";
	Sub "setIcon"___("Icon As QIcon");	COMMENT = "";
	Sub "setSelected"___("Select As Boolean");	COMMENT = "";
	Sub "setSizeHint"___("Size As QSize");	COMMENT = "";
	Sub "setStatusTip"___("StatusTip As String");	COMMENT = "";
	Sub "setText"___("Text As String");	COMMENT = "";
	Sub "setTextAlignment"___("Alignment As Integer");	COMMENT = "";
	Sub "setToolTip"___("ToolTip As String");	COMMENT = "";
	Sub "setWhatsThis"___("WhatsThis As String");	COMMENT = "";
	Function "sizeHint"___("") As "QSize";	COMMENT = "";
	Function "statusTip"___("") As "String";	COMMENT = "";
	Function "tableWidget"___("") As "QTableWidget";	COMMENT = "";
	Function "text"___("") As "String";	COMMENT = "";
	Function "textAlignment"___("") As "Integer";	COMMENT = "";
	Function "toolTip"___("") As "String";	COMMENT = "";
	Function "type"___("") As "Integer";	COMMENT = "";
	Function "whatsThis"___("") As "String";	COMMENT = "";
	//Sub "write"___("Out As QDataStream");	COMMENT = "";

End_Class  



Class "QFontComboBox" SuperClass "QComboBox"

	//Property "currentFont" As "QFont";	COMMENT = "";
	//Property "fontFilters" As "QFontComboBox::FontFilters";	COMMENT = "";
	Property "writingSystem" As "QFontDatabase::WritingSystem";	COMMENT = "";

	Function "currentFont"___("") As "QFont";	COMMENT = "";
	Function "fontFilters"___("") As "QFontComboBox::FontFilters";	COMMENT = "";
	Sub "setFontFilters"___("Filters As QFontComboBox::FontFilters");	COMMENT = "";

	Slot "setCurrentFont"___("Font As QFont");	COMMENT = "";

	Signal "currentFontChanged"___("Font As QFont") Declare "void currentFontChanged(const QFont & font)"	COMMENT = "";

End_Class  



Class "QAbstractSpinBox" SuperClass "QWidget"

	Property "accelerated" As "Boolean";	COMMENT = "";
	Property "acceptableInput" As "Boolean";	COMMENT = "";
	Property "alignment" As "Qt::Alignment";	COMMENT = "";
	Property "buttonSymbols" As "QAbstractSpinBox::ButtonSymbols";	COMMENT = "";

	Property "correctionMode" As "QAbstractSpinBox::CorrectionMode";	COMMENT = "";
	Property "frame" As "Boolean";	COMMENT = "";
	Property "keyboardTracking" As "Boolean";	COMMENT = "";
	Property "readOnly" As "Boolean";	COMMENT = "";
	Property "specialValueText" As "String";	COMMENT = "";
	Property "text" As "String";	COMMENT = "";
	Property "wrapping" As "Boolean";	COMMENT = "";

	Function "alignment"___("") As "Qt::Alignment";	COMMENT = "";
	Function "buttonSymbols"___("") As "QAbstractSpinBox::ButtonSymbols";	COMMENT = "";
	Function "correctionMode"___("") As "QAbstractSpinBox::CorrectionMode";	COMMENT = "";
	Function "hasAcceptableInput"___("") As "Boolean";	COMMENT = "";
	Function "hasFrame"___("") As "Boolean";	COMMENT = "";
	Sub "interpretText"___("");	COMMENT = "";
	Function "isAccelerated"___("") As "Boolean";	COMMENT = "";
	Function "isReadOnly"___("") As "Boolean";	COMMENT = "";
	Function "keyboardTracking"___("") As "Boolean";	COMMENT = "";
	Sub "setAccelerated"___("On As Boolean");	COMMENT = "";
	Sub "setAlignment"___("Flag As Qt::Alignment");	COMMENT = "";
	Sub "setButtonSymbols"___("Bs As QAbstractSpinBox::ButtonSymbols");	COMMENT = "";
	Sub "setCorrectionMode"___("Cm As QAbstractSpinBox::CorrectionMode");	COMMENT = "";
	Sub "setFrame"___("Frame As Boolean");	COMMENT = "";
	Sub "setKeyboardTracking"___("Kt As Boolean");	COMMENT = "";
	Sub "setReadOnly"___("R As Boolean");	COMMENT = "";
	Sub "setSpecialValueText"___("Txt As String");	COMMENT = "";
	Sub "setWrapping"___("W As Boolean");	COMMENT = "";
	Function "specialValueText"___("") As "String";	COMMENT = "";
	Function "text"___("") As "String";	COMMENT = "";
	Function "wrapping"___("") As "Boolean";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "selectAll"___("");	COMMENT = "";
	Slot "stepDown"___("");	COMMENT = "";
	Slot "stepUp"___("");	COMMENT = "";

	Signal "editingFinished"___("") Declare "void editingFinished()"	COMMENT = "";

End_Class  



Class "QRegExp"

	Function "cap"___("Nth As Integer") As "String";	COMMENT = "";
	Function "captureCount"___("") As "Integer";	COMMENT = "";
	Function "capturedTexts"___("") As "String";	COMMENT = "";
	Function "caseSensitivity"___("") As "Qt::CaseSensitivity";	COMMENT = "";
	Function "errorString"___("") As "String";	COMMENT = "";
	Function "exactMatch"___("Str As String") As "Boolean";	COMMENT = "";
	Function "indexIn"___("Str As String, Offset As Integer, CaretMode As QRegExp::CaretMode") As "Integer";	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "isMinimal"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "lastIndexIn"___("Str As String, Offset As Integer, CaretMode As QRegExp::CaretMode") As "Integer";	COMMENT = "";
	Function "matchedLength"___("") As "Integer";	COMMENT = "";
	Function "pattern"___("") As "String";	COMMENT = "";
	Function "patternSyntax"___("") As "QRegExp::PatternSyntax";	COMMENT = "";
	Function "pos"___("Nth As Integer") As "Integer";	COMMENT = "";
	Sub "setCaseSensitivity"___("Cs As Qt::CaseSensitivity");	COMMENT = "";
	Sub "setMinimal"___("Minimal As Boolean");	COMMENT = "";
	Sub "setPattern"___("Pattern As String");	COMMENT = "";
	Sub "setPatternSyntax"___("Syntax As QRegExp::PatternSyntax");	COMMENT = "";
	Sub "swap"___("Other As QRegExp");	COMMENT = "";

End_Class  



Class "QPixmap" //SuperClass "QPaintDevice"

	Function "cacheKey"___("") As "Integer";	COMMENT = "";
	Function "convertFromImage"___("Image As QImage, Flags As Qt::ImageConversionFlags") As "Boolean";	COMMENT = "";
	Function "copy"___("Rectangle As QRect") As "QPixmap";	COMMENT = "";
	Function "copy"___("X As Integer, Y As Integer, Width As Integer, Height As Integer") As "QPixmap";	COMMENT = "";
	Function "createMaskFromColor"___("MaskColor As QColor, Mode As Qt::MaskMode") As "QBitmap";	COMMENT = "";
	Function "createMaskFromColor2"___("MaskColor As QColor") As "QBitmap";	COMMENT = "";
	Function "depth"___("") As "Integer";	COMMENT = "";
	Sub "detach"___("");	COMMENT = "";
	Sub "fill"___("Color As QColor");	COMMENT = "";
	Sub "fill"___("Widget As QWidget, X As Integer, Y As Integer");	COMMENT = "";
	Function "hasAlpha"___("") As "Boolean";	COMMENT = "";
	Function "hasAlphaChannel"___("") As "Boolean";	COMMENT = "";
	Function "height"___("") As "Integer";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isQBitmap"___("") As "Boolean";	COMMENT = "";
	Function "load"___("FileName As String, Format As String, Flags As Qt::ImageConversionFlags") As "Boolean";	COMMENT = "";
	Function "loadFromData"___("Data As QByteArray, Format As String, Flags As Qt::ImageConversionFlags") As "Boolean";	COMMENT = "";
	Function "mask"___("") As "QBitmap";	COMMENT = "";
	Function "rect"___("") As "QRect";	COMMENT = "";
	Function "save"___("FileName As String, Format As String, Quality As Integer") As "Boolean";	COMMENT = "";
	Function "scaled"___("Width As Integer, Height As Integer, AspectRatioMode As Qt::AspectRatioMode, TransformMode As Qt::TransformationMode") As "QPixmap";	COMMENT = "";

	Function "scaledToHeight"___("Height As Integer, Mode As Qt::TransformationMode") As "QPixmap";	COMMENT = "";
	Function "scaledToWidth"___("Width As Integer, Mode As Qt::TransformationMode") As "QPixmap";	COMMENT = "";
	Sub "scroll"___("Dx As Integer, Dy As Integer, X As Integer, Y As Integer, Width As Integer, Height As Integer, Exposed As QRegion");	COMMENT = "";
	Sub "scroll2"___("Dx As Integer, Dy As Integer, Rect As QRect, Exposed As QRegion");	COMMENT = "";
	Sub "setMask"___("Mask As QBitmap");	COMMENT = "";
	Function "size"___("") As "QSize";	COMMENT = "";
	Sub "swap"___("Other As QPixmap");	COMMENT = "";
	Function "toImage"___("") As "QImage";	COMMENT = "";
	Function "toIcon"___("") As "QIcon";	COMMENT = "";
	Function "transformed"___("Transform As QTransform, Mode As Qt::TransformationMode") As "QPixmap";	COMMENT = "";
	Function "transformed2"___("Matrix As QMatrix, Mode As Qt::TransformationMode") As "QPixmap";	COMMENT = "";
	Function "width"___("") As "Integer";	COMMENT = "";

End_Class  



Class "QDialog" SuperClass "QWidget"

	Property "modal" As "Boolean";
	Property "sizeGripEnabled" As "Boolean";

	Function "isSizeGripEnabled"___("") As "Boolean";	COMMENT = "";
	Function "result"___("") As "Integer";	COMMENT = "";
	Sub "setModal"___("Modal As Boolean");	COMMENT = "";
	Sub "setResult"___("I As Integer");	COMMENT = "";
	Sub "setSizeGripEnabled"___("Enabled As Boolean");	COMMENT = "";

	Slot "accept"___("");	COMMENT = "";
	Slot "done"___("R As Integer");	COMMENT = "";
	Slot "exec"___("");	COMMENT = "";
	Slot "open"___("");	COMMENT = "";
	Slot "reject"___("");	COMMENT = "";

	Signal "accepted"___("") Declare "void accepted()"	COMMENT = "";
	Signal "finished"___("Result As Integer") Declare "void finished(int result)"	COMMENT = "";
	Signal "rejected"___("") Declare "void rejected()"	COMMENT = "";

End_Class  



Class "QDialogButtonBox" SuperClass "QWidget"

	Property "centerButtons" As "Boolean";	COMMENT = "";
	Property "orientation" As "Qt::Orientation";	COMMENT = "";
	Property "standardButtons" As "Qt::StandardButtons";	COMMENT = "";

	Sub "addButton"___("Button As QAbstractButton, Role As QDialogButtonBox::ButtonRole");	COMMENT = "";
	Function "addButton"___("Text As String, Role As QDialogButtonBox::ButtonRole") As "QPushButton";	COMMENT = "";
	Function "addButton2"___("Button As QDialogButtonBox::StandardButton") As "QPushButton";	COMMENT = "";
	Function "button"___("Which As QDialogButtonBox::StandardButton") As "QDialogButtonBox::ButtonRole";	COMMENT = "";
	Function "buttonRole"___("button As QAbstractButton") As "QDialogButtonBox::ButtonRole";	COMMENT = "";

	//Function "buttons"___("") As "List";	COMMENT = "";
	Function "centerButtons"___("") As "Boolean";	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";
	Function "orientation"___("") As "Qt::Orientation";	COMMENT = "";
	Sub "removeButton"___("Button As QAbstractButton");	COMMENT = "";
	Sub "setCenterButtons"___("Center As Boolean");	COMMENT = "";
	Sub "setOrientation"___("Orientation As Qt::Orientation");	COMMENT = "";
	Sub "setStandardButtons"___("Buttons As QDialogButtonBox::StandardButtons");	COMMENT = "";
	//Function "standardButton"___("") As "QDialogButtonBox::StandardButton";	COMMENT = "";
	Function "standardButtons"___("") As "QDialogButtonBox::StandardButtons";	COMMENT = "";

	Signal "accepted"___("") Declare "void accepted()"	COMMENT = "";
	Signal "clicked"___("Button As QAbstractButton") Declare "void clicked(QAbstractButton *button)"	COMMENT = "";
	Signal "helpRequested"___("") Declare "void helpRequested()"	COMMENT = "";
	Signal "rejected"___("") Declare "void rejected()"	COMMENT = "";

End_Class  



Class "QDir"

	Function "absoluteFilePath"___("FileName As String") As "String";	COMMENT = "";
	Function "absolutePath"___("") As "String";	COMMENT = "";
	Function "canonicalPath"___("") As "String";	COMMENT = "";
	Function "cd"___("DirName As String") As "Boolean";	COMMENT = "";
	Function "cdUp"___("") As "Boolean";	COMMENT = "";
	Function "count"___("") As "Integer";	COMMENT = "";	
	Function "dirName"___("") As "String";	COMMENT = "";
	Function "entryInfoList"___("NameFilters As QStringList, Filters As QDir::Filters, Sort As QDir::SortFlags") As "List";	COMMENT = "";
	Function "entryList"___("NameFilters As QStringList, Filters As QDir::Filters, Sort As QDir::SortFlags") As "QStringList";	COMMENT = "";
	Function "exists"___("FileName As String") As "Boolean";	COMMENT = "";
	Function "exists"___("") As "Boolean";	COMMENT = "";
	Function "filePath"___("FileName As String") As "String";	COMMENT = "";
	Function "filter"___("") As "QDir::Filters";	COMMENT = "";
	Function "isAbsolute"___("") As "Boolean";	COMMENT = "";
	Function "isReadable"___("") As "Boolean";	COMMENT = "";
	Function "isRelative"___("") As "Boolean";	COMMENT = "";
	Function "isRoot"___("") As "Boolean";	COMMENT = "";
	Function "makeAbsolute"___("") As "Boolean";	COMMENT = "";
	Function "mkdir"___("DirName As String") As "Boolean";	COMMENT = "";
	Function "mkpath"___("DirPath As String") As "Boolean";	COMMENT = "";
	Function "nameFilters"___("") As "QStringList";	COMMENT = "";
	Function "path"___("") As "String";	COMMENT = "";
	Sub "refresh"___("");	COMMENT = "";
	Function "relativeFilePath"___("FileName As String") As "String";	COMMENT = "";
	Function "remove"___("FileName As String") As "Boolean";	COMMENT = "";
	Function "rename"___("OldName As String, NewName As String") As "Boolean";	COMMENT = "";
	Function "rmdir"___("DirName As String") As "Boolean";	COMMENT = "";
	//Function "rmPath"___("DirPath As String") As "Boolean";	COMMENT = "";
	Sub "setFilter"___("Filters As QDir::Filters");	COMMENT = "";
	Sub "setNameFilters"___("NameFilters As QStringList");	COMMENT = "";
	Sub "setPath"___("Path As String");	COMMENT = "";
	Sub "setSorting"___("Sort As QDir::SortFlags");	COMMENT = "";
	Function "sorting"___("") As "QDir::SortFlags";	COMMENT = "";

End_Class  



Class "QTextBrowser" SuperClass "QTextEdit"

	Property "modified" As "Boolean";	COMMENT = "";
	Property "openExternalLinks" As "Boolean";	COMMENT = "";
	Property "openLinks" As "Boolean";	COMMENT = "";
	Property "readOnly" As "Boolean";	COMMENT = "";
	Property "searchPaths" As "QStringList";	COMMENT = "";
	Property "source" As "QUrl";	COMMENT = "";
	Property "undoRedoEnabled" As "Boolean";	COMMENT = "";

	Function "backwardHistoryCount"___("") As "Integer";	COMMENT = "";
	Sub "clearHistory"___("");	COMMENT = "";
	Function "forwardHistoryCount"___("") As "Integer";	COMMENT = "";
	Function "historyTitle"___("I As Integer") As "String";	COMMENT = "";
	Function "historyUrl"___("I As Integer") As "QUrl";	COMMENT = "";
	Function "isBackwardAvailable"___("") As "Boolean";	COMMENT = "";
	Function "isForwardAvailable"___("") As "Boolean";	COMMENT = "";
	Function "openExternalLinks"___("") As "Boolean";	COMMENT = "";
	Function "openLinks"___("") As "Boolean";	COMMENT = "";
	Function "searchPaths"___("") As "QStringList";	COMMENT = "";
	Sub "setOpenExternalLinks"___("Open As Boolean");	COMMENT = "";
	Sub "setOpenLinks"___("Open As Boolean");	COMMENT = "";
	Sub "setSearchPaths"___("Paths As QStringList");	COMMENT = "";
	Function "source"___("") As "QUrl";	COMMENT = "";

	Slot "backward"___("");	COMMENT = "";
	Slot "forward"___("");	COMMENT = "";
	Slot "home"___("");	COMMENT = "";
	Slot "reload"___("");	COMMENT = "";
	Slot "setSource"___("Name As QUrl");	COMMENT = "";

	Signal "anchorClicked"___("Link As QUrl") Declare "void anchorClicked(const QUrl & link)"	COMMENT = "";
	Signal "backwardAvailable"___("Available As Boolean") Declare "void backwardAvailable(bool available)"	COMMENT = "";
	Signal "forwardAvailable"___("Available As Boolean") Declare "void forwardAvailable(bool available)"	COMMENT = "";
	Signal "highlighted"___("Link As String") Declare "void highlighted(const QString & link)"	COMMENT = "";
	Signal "highlighted2"___("Link As QUrl") Declare "void highlighted(const QUrl & link)"	COMMENT = "";
	Signal "historyChanged"___("") Declare "void historyChanged()"	COMMENT = "";
	Signal "sourceChanged"___("Src As QUrl") Declare "void sourceChanged(const QUrl & src)"	COMMENT = "";

End_Class  



Class "QPicture" //SuperClass "QPaintDevice"

	Function "boundingRect"___("") As "QRect";	COMMENT = "";
	Function "data"___("") As "String";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "load"___("FileName As String, Format As String") As "Boolean";	COMMENT = "";
	Function "play"___("Painter As QPainter") As "Boolean";	COMMENT = "";
	Function "save"___("FileName As String, Format As String") As "Boolean";	COMMENT = "";
	Sub "setBoundingRect"___("R As QRect");	COMMENT = "";
	Sub "setData"___("Data As String, Size As Integer");	COMMENT = "";
	Function "size"___("") As "Integer";	COMMENT = "";
	Sub "swap"___("Other As QPicture");	COMMENT = "";

End_Class  



Class "QSplitterHandle" SuperClass "QWidget"
	
	Function "opaqueResize"___("") As "Boolean";	COMMENT = "";
	Function "orientation"___("") As "Qt::Orientation";	COMMENT = "";
	Sub "setOrientation"___("Orientation As Qt::Orientation");	COMMENT = "";
	Function "splitter"___("") As "QSplitter";	COMMENT = "";

End_Class  



Class "QPlainTextEdit" SuperClass "QAbstractScrollArea"

	Property "backgroundVisible" As "Boolean";	COMMENT = "";
	Property "blockCount" As "Integer";	COMMENT = "";
	Property "centerOnScroll" As "Boolean";	COMMENT = "";
	Property "cursorWidth" As "Integer";	COMMENT = "";
	Property "documentTitle" As "String";	COMMENT = "";
	Property "lineWrapMode" As "QPlainTextEdit::LineWrapMode";	COMMENT = "";
	Property "maximumBlockCount" As "Integer";	COMMENT = "";
	Property "overwriteMode" As "Boolean";	COMMENT = "";
	Property "plainText" As "String";	COMMENT = "";
	Property "readOnly" As "Boolean";	COMMENT = "";
	Property "tabChangesFocus" As "Boolean";	COMMENT = "";
	Property "tabStopWidth" As "Integer";	COMMENT = "";
	Property "textInteractionFlags" As "Qt::TextInteractionFlags";	COMMENT = "";
	Property "undoRedoEnabled" As "Boolean";	COMMENT = "";
	Property "wordWrapMode" As "QTextOption::WrapMode";	COMMENT = "";

	Function "anchorAt"___("Pos As QPoint") As "String";	COMMENT = "";
	Function "backgroundVisible"___("") As "Boolean";	COMMENT = "";
	Function "blockCount"___("") As "Integer";	COMMENT = "";
	Function "canPaste"___("") As "Boolean";	COMMENT = "";
	Function "centerOnScroll"___("") As "Boolean";	COMMENT = "";
	Function "createStandardContextMenu"___("") As "QMenu";	COMMENT = "";
	Function "cursorForPosition"___("Pos As QPoint") As "QTextCursor";	COMMENT = "";
	Function "cursorWidth"___("") As "Integer";	COMMENT = "";
	Function "document"___("") As "QTextDocument";	COMMENT = "";
	Function "documentTitle"___("") As "String";	COMMENT = "";
	Sub "ensureCursorVisible"___("");	COMMENT = "";
	Function "find"___("Exp As String, Options As QTextDocument::FindFlags") As "Boolean";	COMMENT = "";
	Function "isReadOnly"___("") As "Boolean";	COMMENT = "";
	Function "isUndoRedoEnabled"___("") As "Boolean";	COMMENT = "";
	Function "lineWrapMode"___("") As "QPlainTextEdit::LineWrapMode";	COMMENT = "";
	Function "maximumBlockCount"___("") As "Integer";	COMMENT = "";
	Sub "moveCursor"___("Operation As QTextCursor::MoveOperation, Mode As QTextCursor::MoveMode");	COMMENT = "";
	Function "overwriteMode"___("") As "Boolean";	COMMENT = "";
	Sub "print"___("Printer As QPrinter");	COMMENT = "";
	Sub "setBackgroundVisible"___("Visible As Boolean");	COMMENT = "";
	Sub "setCenterOnScroll"___("Enabled As Boolean");	COMMENT = "";
	Sub "setCursorWidth"___("Width As Integer");	COMMENT = "";
	Sub "setDocument"___("Document As QTextDocument");	COMMENT = "";
	Sub "setDocumentTitle"___("Title As String");	COMMENT = "";
	Sub "setLineWrapMode"___("Mode As QPlainTextEdit::LineWrapMode");	COMMENT = "";
	Sub "setMaximumBlockCount"___("Maximum As Integer");	COMMENT = "";
	Sub "setOverwriteMode"___("Overwrite As Boolean");	COMMENT = "";
	Sub "setReadOnly"___("Ro As Boolean");	COMMENT = "";
	Sub "setTabChangesFocus"___("B As Boolean");	COMMENT = "";
	Sub "setTabStopWidth"___("Width As Integer");	COMMENT = "";
	Sub "setTextCursor"___("Cursor As QTextCursor");	COMMENT = "";
	Sub "setTextInteractionFlags"___("Flags As Qt::TextInteractionFlags");	COMMENT = "";
	Sub "setUndoRedoEnabled"___("Enable As Boolean");	COMMENT = "";
	Function "tabChangesFocus"___("") As "Boolean";	COMMENT = "";
	Function "tabStopWidth"___("") As "Integer";	COMMENT = "";
	Function "textCursor"___("") As "QTextCursor";	COMMENT = "";
	Function "textInteractionFlags"___("") As "Qt::TextInteractionFlags";	COMMENT = "";
	Function "toPlainText"___("") As "String";	COMMENT = "";
	Function "wordWrapMode"___("") As "QTextOption::WrapMode";	COMMENT = "";

	Slot "appendHtml"___("Html As String");	COMMENT = "";
	Slot "appendPlainText"___("Text As String");	COMMENT = "";
	Slot "centerCursor"___("");	COMMENT = "";
	Slot "clear"___("");	COMMENT = "";
	Slot "copy"___("");	COMMENT = "";
	Slot "cut"___("");	COMMENT = "";
	Slot "insertPlainText"___("Text As String");	COMMENT = "";
	Slot "paste"___("");	COMMENT = "";
	Slot "redo"___("");	COMMENT = "";
	Slot "selectAll"___("");	COMMENT = "";
	Slot "setPlainText"___("Text As String");	COMMENT = "";
	Slot "undo"___("");	COMMENT = "";

	Signal "blockCountChanged"___("NewBlockCount As Integer") Declare "void blockCountChanged(int newBlockCount)"	COMMENT = "";
	Signal "copyAvailable"___("Yes As Boolean") Declare "void copyAvailable(bool yes)"	COMMENT = "";
	Signal "cursorPositionChanged"___("") Declare "void cursorPositionChanged()"	COMMENT = "";
	Signal "modificationChanged"___("Changed As Boolean") Declare "void modificationChanged(bool changed)"	COMMENT = "";
	Signal "redoAvailable"___("Available As Boolean") Declare "void redoAvailable(bool available)"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";
	Signal "textChanged"___("") Declare "void textChanged()"	COMMENT = "";
	Signal "undoAvailable"___("Available As Boolean") Declare "void undoAvailable(bool available)"	COMMENT = "";	
	Signal "updateRequest"___("Rect As QRect, Dy As Integer") Declare "void updateRequest(const QRect & rect, int dy)"	COMMENT = "";

End_Class



Class "QTableWidget" SuperClass "QTableView"

	Property "alternatingRowColors" As "Boolean";	COMMENT = "";
	Property "autoScroll" As "Boolean";	COMMENT = "";
	Property "autoScrollMargin" As "Boolean";	COMMENT = "";
	Property "columnCount" As "Integer";	COMMENT = "";
	Property "defaultDropAction" As "Qt::DropAction";	COMMENT = "";
	Property "dragDropMode" As "QTableWidget::DragDropMode";	COMMENT = "";
	Property "dragDropOverwriteMode" As "Boolean";	COMMENT = "";
	Property "dragEnabled" As "Boolean";	COMMENT = "";
	Property "editTriggers" As "QTableWidget::EditTriggers";	COMMENT = "";
	Property "horizontalScrollMode" As "QTableWidget::ScrollMode";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "rowCount" As "Integer";	COMMENT = "";
	Property "selectionBehavior" As "QTableWidget::SelectionBehavior";	COMMENT = "";
	Property "selectionMode" As "QTableWidget::SelectionMode";	COMMENT = "";
	Property "showDropIndicator" As "Boolean";	COMMENT = "";
	Property "tabKeyNavigation" As "Boolean";	COMMENT = "";
	Property "textElideMode" As "Qt::TextElideMode";	COMMENT = "";
	Property "verticalScrollMode" As "QTableWidget::ScrollMode";	COMMENT = "";

	Function "alternatingRowColors"___("") As "Boolean";	COMMENT = "";
	Function "autoScrollMargin"___("") As "Integer";	COMMENT = "";
	Function "cellWidget"___("Row As Integer, Column As Integer") As "QWidget";	COMMENT = "";
	Sub "closePersistentEditor"___("Item As QTableWidgetItem");	COMMENT = "";
	Function "colorCount"___("") As "Integer";	COMMENT = "";
	Function "column"___("Item As QTableWidgetItem") As "Integer";	COMMENT = "";
	Function "columnCount"___("") As "Integer";	COMMENT = "";
	Function "currentColumn"___("") As "Integer";	COMMENT = "";
	//Function "currentIndex"___("") As "QModelIndex";	COMMENT = "";
	Function "currentItem"___("") As "QTableWidgetItem";	COMMENT = "";
	Function "currentRow"___("") As "Integer";	COMMENT = "";
	Function "defaultDropAction"___("") As "Qt::DropAction";	COMMENT = "";
	Function "depth"___("") As "Integer";	COMMENT = "";
	Function "dragDropMode"___("") As "QTableWidget::DragDropMode";	COMMENT = "";
	Function "dragDropOverwriteMode"___("") As "Boolean";	COMMENT = "";
	Function "dragEnabled"___("") As "Boolean";	COMMENT = "";
	Sub "editItem"___("Item As QTableWidgetItem");	COMMENT = "";
	Function "editTriggers"___("") As "QTableWidget::EditTriggers";	COMMENT = "";
	Function "findItems"___("Text As String, Flags As Qt::MatchFlags") As "List";	COMMENT = "";
	Function "hasAutoScroll"___("") As "Boolean";	COMMENT = "";
	Function "height"___("") As "Integer";	COMMENT = "";
	Function "heightMM"___("") As "Integer";	COMMENT = "";
	Function "horizontalHeaderItem"___("Column As Integer") As "QTableWidgetItem";	COMMENT = "";
	Function "horizontalScrollMode"___("") As "QTableWidget::ScrollMode";	COMMENT = "";
	Function "iconSize"___("") As "QSize";	COMMENT = "";
	//Function "itemAt"___("Point As QPoint") As "QModelIndex";	COMMENT = "";
	//Function "indexWidget"___("Index As QModelIndex") As "QWidget";	COMMENT = "";
	Function "item"___("Row As Integer, Column As Integer") As "QTableWidgetItem";	COMMENT = "";
	Function "itemAt"___("Point As QPoint") As "QTableWidgetItem";	COMMENT = "";
	Function "itemAt"___("Ax As Integer, Ay As Integer") As "QTableWidgetItem";	COMMENT = "";
	Sub "removeCellWidget"___("Row As Integer, Column As Integer");	COMMENT = "";
	Function "row"___("Item As QTableWidgetItem") As "Integer";	COMMENT = "";
	Function "rowCount"___("") As "Integer";	COMMENT = "";
	Sub "scrollToItem"___("Item As QTableWidgetItem, Hint As QTableWidget::ScrollHint");	COMMENT = "";
	//Sub "scrollTo"___("Index As QModelIndex, Hint As QTableWidget::ScrollHint");	COMMENT = "";
	Function "selectedItems"___("") As "List";	COMMENT = "";
	//Function "selectedRanges"___("") As "List";	COMMENT = "";
	Function "selectionBehavior"___("") As "QAbstractItemView::SelectionBehavior";	COMMENT = "";
	Function "selectionMode"___("") As "QAbstractItemView::SelectionMode";	COMMENT = "";
	Function "selectionModel"___("") As "QItemSelectionModel";	COMMENT = "";
	Sub "setAlternatingRowColors"___("Enable As Boolean");	COMMENT = "";
	Sub "setAutoScroll"___("Enable As Boolean");	COMMENT = "";
	Sub "setAutoScrollMargin"___("Margin As Integer");	COMMENT = "";
	Sub "setCellWidget"___("Row As Integer, Column As Integer, Widget As QWidget");	COMMENT = "";
	Sub "setColumnCount"___("Columns As Integer");	COMMENT = "";
	Sub "setCurrentCell"___("Row As Integer, Column As Integer");	COMMENT = "";
	Sub "setCurrentCell"___("Row As Integer, Column As Integer, Command As QItemSelectionModel::SelectionFlags");	COMMENT = "";
	Sub "setCurrentItem"___("Item As QTableWidgetItem");	COMMENT = "";
	Sub "setCurrentItem"___("Item As QTableWidgetItem, QItemSelectionModel::SelectionFlags");	COMMENT = "";
	Sub "setDefaultDropAction"___("DropAction As Qt::DropAction");	COMMENT = "";
	Sub "setDragDropMode"___("Behavior As QTableWidget::DragDropMode");	COMMENT = "";
	Sub "setDragDropOverwriteMode"___("Overwrite As Boolean");	COMMENT = "";
	Sub "setDragEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setDropIndicatorShown"___("Enable As Boolean");	COMMENT = "";
	Sub "setEditTriggers"___("Triggers As QTableWidget::EditTriggers");	COMMENT = "";
	Sub "setHorizontalHeaderItem"___("Column As Integer, Item As QTableWidgetItem");	COMMENT = "";
	Sub "setHorizontalHeaderLabels"___("Labels As List");	COMMENT = "";
	//Sub "setHorizontalScrollMode"___("Mode As ScrollMode");	COMMENT = "";
	Sub "setIconSize"___("Size As QSize");	COMMENT = "";
	Sub "setItem"___("Row As Integer, Column As Integer, Item As QTableWidgetItem");	COMMENT = "";
	//Sub "setRangeSelected"___("Range As QTableWidgetSelectionRange, Select As Boolean");	COMMENT = "";
	Sub "setRowCount"___("Rows As Integer");	COMMENT = "";
	Sub "setSelectionBehavior"___("Behavior As QAbstractItemView::SelectionBehavior");	COMMENT = "";
	//Sub "setSelectionMode"___("Mode As QAbstractItemView::SelectionMode");	COMMENT = "";
	//Sub "setSelectionModel"___("SelectionModel As QItemSelectionModel");	COMMENT = "";
	Sub "setTabKeyNavigation"___("Enable As Boolean");	COMMENT = "";
	Sub "setTextElideMode"___("Mode As Qt::TextElideMode");	COMMENT = "";
	Sub "setVerticalHeaderItem"___("Row As Integer, Item As QTableWidgetItem");	COMMENT = "";
	Sub "setVerticalHeaderLabels"___("Labels As List");	COMMENT = "";
	Sub "setVerticalScrollMode"___("Mode As QTableWidget::ScrollMode");	COMMENT = "";
	Function "showDropIndicator"___("") As "Boolean";	COMMENT = "";
	//Function "sizeHintForColumn"___("Column As Integer") As "Integer";	COMMENT = "";
	//Function "sizeHintForRow"___("Row As Integer") As "Integer";	COMMENT = "";
	Sub "sortItems"___("Column As Integer, Order As Qt::SortOrder");	COMMENT = "";
	Function "tabKeyNavigation"___("") As "Boolean";	COMMENT = "";
	Function "takeHorizontalHeaderItem"___("Column As Integer") As "QTableWidgetItem";	COMMENT = "";
	Function "takeItem"___("Row As Integer, Column As Integer") As "QTableWidgetItem";	COMMENT = "";
	Function "takeVerticalHeaderItem"___("Row As Integer") As "QTableWidgetItem";	COMMENT = "";
	Function "textElideMode"___("") As "Qt::TextElideMode";	COMMENT = "";
	Function "verticalHeaderItem"___("Row As Integer") As "QTableWidgetItem";	COMMENT = "";
	Function "verticalScrollMode"___("") As "QTableWidget::ScrollMode";	COMMENT = "";
	Function "width"___("") As "Integer";	COMMENT = "";
	Function "widthMM"___("") As "Integer";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "clearContents"___("");	COMMENT = "";
	Slot "clearSelection"___("");	COMMENT = "";
	//Slot "edit"___("Index As QModelIndex");	COMMENT = "";
	Slot "insertColumn"___("Column As Integer");	COMMENT = "";
	Slot "insertRow"___("Row As Integer");	COMMENT = "";
	Slot "removeColumn"___("Column As Integer");	COMMENT = "";
	Slot "removeRow"___("Row As Integer");	COMMENT = "";
	Slot "reset"___("");	COMMENT = "";
	Slot "scrollToBottom"___("");	COMMENT = "";
	Slot "scrollToItem"___("Item As QTableWidgetItem, Hint As QAbstractItemView::ScrollHint");	COMMENT = "";
	Slot "scrollToTop"___("");	COMMENT = "";
	Slot "selectAll"___("");	COMMENT = "";
	//Slot "update"___("Index As QModelIndex");	COMMENT = "";

	Signal "cellActivated"___("Row As Integer, Column As Integer") Declare "void cellActivated(int row, int column)"	COMMENT = "";
	Signal "cellChanged"___("Row As Integer, Column As Integer") Declare "void cellChanged(int row, int column)"	COMMENT = "";
	Signal "cellClicked"___("Row As Integer, Column As Integer") Declare "void cellClicked(int row, int column)"	COMMENT = "";
	Signal "cellDoubleClicked"___("Row As Integer, Column As Integer") Declare "void cellDoubleClicked(int row, int column)"	COMMENT = "";
	Signal "cellEntered"___("Row As Integer, Column As Integer") Declare "void cellEntered(int row, int column)"	COMMENT = "";
	Signal "cellPressed"___("Row As Integer, Column As Integer") Declare "void cellPressed(int row, int column)"	COMMENT = "";
	Signal "currentCellChanged"___("CurrentRow As Integer, CurrentColumn As Integer, PreviousRow As Integer, PreviousColumn As Integer") Declare "void currentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn)"	COMMENT = "";
	Signal "currentItemChanged"___("Current As QTableWidgetItem, Previous As QTableWidgetItem") Declare "void currentItemChanged(QTableWidgetItem * current, QTableWidgetItem * previous)"	COMMENT = "";
	Signal "itemActivated"___("Item As QTableWidgetItem") Declare "void itemActivated(QTableWidgetItem * item)"	COMMENT = "";
	Signal "itemChanged"___("Item As QTableWidgetItem") Declare "void itemChanged(QTableWidgetItem * item)"	COMMENT = "";
	Signal "itemClicked"___("Item As QTableWidgetItem") Declare "void itemClicked(QTableWidgetItem * item)"	COMMENT = "";
	Signal "itemDoubleClicked"___("Item As QTableWidgetItem") Declare "void itemDoubleClicked(QTableWidgetItem * item)"	COMMENT = "";
	Signal "itemEntered"___("Item As QTableWidgetItem") Declare "void itemEntered(QTableWidgetItem * item)"	COMMENT = "";
	Signal "itemPressed"___("Item As QTableWidgetItem") Declare "void itemPressed(QTableWidgetItem * item)"	COMMENT = "";
	Signal "itemSelectionChanged"___("") Declare "void itemSelectionChanged()"	COMMENT = "";

  

End_Class




//---------------------------------------------------------------------------------------------

Class "QStringList" //SuperClass "QList<QString>"

	Function "toList"___("") As "List";	COMMENT = "";
  Function "at"___("Index As Integer") As "String";	COMMENT = "";
  Function "length"___("") As "Integer";	COMMENT = "";

  Function "contains"___("Str As String, Cs As Qt::CaseSensitivity") As "Boolean";	COMMENT = "";
	Function "filter"___("Str As String, Cs As Qt::CaseSensitivity") As "QStringList";	COMMENT = "";
	Function "filter"___("Rx As QRegExp") As "QStringList";	COMMENT = "";
	Function "indexOf"___("Rx As QRegExp, From As Integer") As "Integer";	COMMENT = "";
	Function "indexOf"___("Value As String, From As Integer") As "Integer";	COMMENT = "";
	Function "join"___("Separator As String") As "String";	COMMENT = "";
	Function "lastIndexOf"___("Rx As QRegExp, From As Integer") As "Integer";	COMMENT = "";
	Function "lastIndexOf"___("Value As String, From As Integer") As "Integer";	COMMENT = "";
	Function "removeDuplicates"___("") As "Integer";	COMMENT = "";
	Function "replaceInStrings"___("Before As String, After As String, Cs As Qt::CaseSensitivity") As "QStringList";	COMMENT = "";
	Function "replaceInStrings"___("Rx As QRegExp, After As String") As "QStringList";	COMMENT = "";
	Sub "sort"___("");	COMMENT = "";

  Sub "append"___("Str As String");	COMMENT = "";

End_Class



Class "QTabWidget" SuperClass "QWidget"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentIndex" As "Integer";	COMMENT = "";
	Property "documentMode" As "Boolean";	COMMENT = "";
	Property "elideMode" As "Qt::TextElideMode";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "movable" As "Boolean";	COMMENT = "";
	Property "tabPosition" As "QTabWidget::TabPosition";	COMMENT = "";
	Property "tabShape" As "QTabWidget::TabShape";	COMMENT = "";
	Property "tabsClosable" As "Boolean";	COMMENT = "";
	Property "usesScrollButtons" As "Boolean";	COMMENT = "";

	Function "addTab"___("Page As QWidget, Label As String") As "Integer";	COMMENT = "";
	Function "addTab"___("Page As QWidget, Icon As QIcon, Label As String") As "Integer";	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";
	Function "count"___("") As "Integer";	COMMENT = "";
	Function "currentIndex"___("") As "Integer";	COMMENT = "";
	Function "currentWidget"___("") As "QWidget";	COMMENT = "";
	Function "documentMode"___("") As "Boolean";	COMMENT = "";
	Function "elideMode"___("") As "Qt::TextElideMode";	COMMENT = "";
	Function "iconSize"___("") As "QSize";	COMMENT = "";
	Function "indexOf"___("W As QWidget") As "Integer";	COMMENT = "";
	Function "insertTab"___("Index As Integer, Page As QWidget, Label As String") As "Integer";	COMMENT = "";
	Function "insertTab"___("Index As Integer, Page As QWidget, Icon As QIcon, Label As String") As "Integer";	COMMENT = "";
	Function "isMovable"___("") As "Boolean";	COMMENT = "";
	Function "isTabEnabled"___("Index As Integer") As "Boolean";	COMMENT = "";
	Sub "removeTab"___("Index As Integer");	COMMENT = "";
	Sub "setDocumentMode"___("Set As Boolean");	COMMENT = "";
	Sub "setElideMode"___("Mode As Qt::TextElideMode");	COMMENT = "";
	Sub "setIconSize"___("Size As QSize");	COMMENT = "";
	Sub "setMovable"___("Movable As Boolean");	COMMENT = "";
	Sub "setTabEnabled"___("Index As Integer, Enable As Boolean");	COMMENT = "";
	Sub "setTabIcon"___("Index As Integer, Icon As QIcon");	COMMENT = "";
	Sub "setTabPosition"___("Position As QTabWidget::TabPosition");	COMMENT = "";
	Sub "setTabShape"___("Shape As QTabWidget::TabShape");	COMMENT = "";
	Sub "setTabText"___("Index As Integer, Label As String");	COMMENT = "";
	Sub "setTabToolTip"___("Index As Integer, Tip As String");	COMMENT = "";
	Sub "setTabWhatsThis"___("Index As Integer, Text As String");	COMMENT = "";
	Sub "setTabsClosable"___("Closeable As Boolean");	COMMENT = "";
	Sub "setUsesScrollButtons"___("UseButtons As Boolean");	COMMENT = "";
	Function "tabIcon"___("Index As Integer") As "QIcon";	COMMENT = "";
	Function "tabPosition"___("") As "QTabWidget::TabPosition";	COMMENT = "";
	Function "tabShape"___("") As "QTabWidget::TabShape";	COMMENT = "";
	Function "tabText"___("Index As Integer") As "String";	COMMENT = "";
	Function "tabToolTip"___("Index As Integer") As "String";	COMMENT = "";
	Function "tabWhatsThis"___("Index As Integer") As "String";	COMMENT = "";
	Function "tabsClosable"___("") As "Boolean";	COMMENT = "";
	Function "usesScrollButtons"___("") As "Boolean";	COMMENT = "";
	Function "widget"___("Index As Integer") As "QWidget";	COMMENT = "";

	Slot "setCurrentIndex"___("Index As Integer");	COMMENT = "";
	Slot "setCurrentWidget"___("Widget As QWidget");	COMMENT = "";

	Signal "currentChanged"___("Index As Integer") Declare "void currentChanged(int index)"	COMMENT = "";
	Signal "tabCloseRequested"___("Index As Integer") Declare	"void tabCloseRequested(int index)"	COMMENT = "";

End_Class



Class "QAbstractSlider" SuperClass "QWidget"

	Property "invertedAppearance" As "Boolean";	COMMENT = "";
	Property "invertedControls" As "Boolean";	COMMENT = "";
	Property "maximum" As "Integer";	COMMENT = "";
	Property "minimum" As "Integer";	COMMENT = "";
	Property "orientation" As "Qt::Orientation";	COMMENT = "";
	Property "pageStep" As "Integer";	COMMENT = "";
	Property "singleStep" As "Integer";	COMMENT = "";
	Property "sliderDown" As "Boolean";	COMMENT = "";
	Property "sliderPosition" As "Integer";	COMMENT = "";
	Property "tracking" As "Boolean";	COMMENT = "";
	Property "value" As "Integer";	COMMENT = "";

	Function "hasTracking"___("") As "Boolean";	COMMENT = "";
	Function "invertedAppearance"___("") As "Boolean";	COMMENT = "";
	Function "invertedControls"___("") As "Boolean";	COMMENT = "";
	Function "isSliderDown"___("") As "Boolean";	COMMENT = "";
	Function "maximum"___("") As "Integer";	COMMENT = "";
	Function "minimum"___("") As "Integer";	COMMENT = "";
	Function "orientation"___("") As "Qt::Orientation";	COMMENT = "";
	Function "pageStep"___("") As "Integer";	COMMENT = "";
	Sub "setInvertedAppearance"___("Inverted As Boolean");	COMMENT = "";
	Sub "setInvertedControls"___("Inverted As Boolean");	COMMENT = "";
	Sub "setMaximum"___("Maximum As Integer");	COMMENT = "";
	Sub "setMinimum"___("Minimum As Integer");	COMMENT = "";
	Sub "setPageStep"___("Step As Integer");	COMMENT = "";
	Sub "setRange"___("Min As Integer, Max As Integer");	COMMENT = "";
	Sub "setSingleStep"___("Step As Integer");	COMMENT = "";
	Sub "setSliderDown"___("Down As Integer");	COMMENT = "";
	Sub "setSliderPosition"___("Position As Integer");	COMMENT = "";
	Sub "setTracking"___("Enable As Integer");	COMMENT = "";
	Function "sliderPosition"___("") As "Integer";	COMMENT = "";
	Function "value"___("") As "Integer";	COMMENT = "";

	Slot "setOrientation"___("Orientation As Qt::Orientation");	COMMENT = "";
	Slot "setValue"___("Value As Integer");	COMMENT = "";

	Signal "actionTriggered"___("Action As Integer") Declare "void actionTriggered(int action)"	COMMENT = "";
	Signal "rangeChanged"___("Min As Integer, Max As Integer") Declare "void rangeChanged(int min, int max)"	COMMENT = "";
	Signal "sliderMoved"___("Value As Integer") Declare "void sliderMoved(int value)"	COMMENT = "";
	Signal "sliderPressed"___("") Declare "void sliderPressed()"	COMMENT = "";
	Signal "sliderReleased"___("") Declare "void sliderReleased()"	COMMENT = "";
	Signal "valueChanged"___("Value As Integer") Declare "void valueChanged(int value)"	COMMENT = "";

End_Class



Class "QComboBox" SuperClass "QWidget"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentIndex" As "Integer";	COMMENT = "";
	Property "currentText" As "String";	COMMENT = "";
	Property "duplicatesEnabled" As "Boolean";	COMMENT = "";
	Property "editable" As "Boolean";	COMMENT = "";
	Property "frame" As "Boolean";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "insertPolicy" As "QComboBox::InsertPolicy";	COMMENT = "";
	Property "maxCount" As "Integer";	COMMENT = "";
	Property "maxVisibleItems" As "Integer";	COMMENT = "";
	Property "minimumContentsLength" As "Integer";	COMMENT = "";
	Property "modelColumn" As "Integer";	COMMENT = "";
	Property "sizeAdjustPolicy" As "QComboBox::SizeAdjustPolicy";	COMMENT = "";

	Sub "addItem"___("Text As String, UserData As QVariant");	COMMENT = "";
	Sub "addItem"___("Icon As QIcon, Text As String, UserData As QVariant");	COMMENT = "";
	Sub "addItems"___("Texts As QStringList");	COMMENT = "";
	Function "count"___("") As "Integer";	COMMENT = "";
	Function "currentIndex"___("") As "Integer";	COMMENT = "";
	Function "currentText"___("") As "String";	COMMENT = "";
	Function "duplicatesEnabled"___("") As "Boolean";	COMMENT = "";
	Function "hasFrame"___("") As "Boolean";	COMMENT = "";
	Function "iconSize"___("") As "QSize";	COMMENT = "";
	Sub "insertItem"___("Index As Integer, Text As String, UserData As QVariant");	COMMENT = "";
	Sub "insertItem"___("Index As Integer, Icon As QIcon, Text As String, UserData As QVariant");	COMMENT = "";
	Sub "insertItems"___("Index As Integer, List As QStringList");	COMMENT = "";
	Function "insertPolicy"___("") As "QComboBox::InsertPolicy";	COMMENT = "";
	Sub "insertSeparator"___("Index As Integer");	COMMENT = "";
	Function "isEditable"___("") As "Boolean";	COMMENT = "";
	Function "itemIcon"___("Index As Integer") As "QIcon";	COMMENT = "";
	Function "itemText"___("Index As Integer") As "String";	COMMENT = "";
	Function "lineEdit"___("") As "QLineEdit";	COMMENT = "";
	Function "maxCount"___("") As "Integer";	COMMENT = "";
	Function "maxVisibleItems"___("") As "Integer";	COMMENT = "";
//	Function "minimumContentsLength "___("") As "Integer";	COMMENT = "";
	Function "modelColumn"___("") As "Integer";	COMMENT = "";
	Sub "removeItem"___("Index As Integer");	COMMENT = "";
	Sub "setDuplicatesEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setEditable"___("Editable As Boolean");	COMMENT = "";
	Sub "setFrame"___("Frame As Boolean");	COMMENT = "";
	Sub "setIconSize"___("Size As QSize");	COMMENT = "";
	Sub "setInsertPolicy"___("Policy As QComboBox::InsertPolicy");	COMMENT = "";
	Sub "setItemIcon"___("Index As Integer, Icon As QIcon");	COMMENT = "";
	Sub "setItemText"___("Index As Integer, Text As String");	COMMENT = "";
	Sub "setLineEdit"___("Edit As QLineEdit");	COMMENT = "";
	Sub "setMaxCount"___("Max As Integer");	COMMENT = "";
	Sub "setMaxVisibleItems"___("MaxItems As Integer");	COMMENT = "";
	Sub "setMinimumContentsLength"___("Characters As Integer");	COMMENT = "";
	Sub "setModelColumn"___("VisibleColumn As Integer");	COMMENT = "";
	Sub "setSizeAdjustPolicy"___("Policy As QComboBox::SizeAdjustPolicy");	COMMENT = "";
	Function "sizeAdjustPolicy"___("") As "QComboBox::SizeAdjustPolicy";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "clearEditText"___("");	COMMENT = "";
	Slot "setCurrentIndex"___("Index As Integer");	COMMENT = "";
	Slot "setEditText"___("Text As String");	COMMENT = "";

	Signal "activated"___("Text As String") Declare "void activated(const QString & text)"	COMMENT = "";
	Signal "activated2"___("Index As Integer") Declare "void activated(int index)"	COMMENT = "";
	Signal "currentIndexChanged"___("Text As String") Declare "void currentIndexChanged(const QString & text)"	COMMENT = "";
	Signal "currentIndexChanged2"___("Index As Integer") Declare "void currentIndexChanged(int index)"	COMMENT = "";
	Signal "editTextChanged"___("Text As String") Declare "void editTextChanged(const QString & text)"	COMMENT = "";
	Signal "highlighted"___("Text As String") Declare "void highlighted(const QString & text)"	COMMENT = "";
	Signal "highlighted2"___("Index As Integer") Declare "void highlighted(int index)"	COMMENT = "";

End_Class



Class "QCommandLinkButton" SuperClass "QPushButton"

	Property "description" As "String";	COMMENT = "";
	Property "flat" As "Boolean";	COMMENT = "";

	Function "description"___("") As "String";	COMMENT = "";
	Sub "setDescription"___("Description As String");	COMMENT = "";

End_Class



Class "QLineEdit" SuperClass "QWidget"

	Property "acceptableInput" As "Boolean";	COMMENT = "";
	Property "alignment" As "Qt::Alignment";	COMMENT = "";
	Property "cursorMoveStyle" As "Qt::CursorMoveStyle";	COMMENT = "";
	Property "cursorPosition" As "Integer";	COMMENT = "";
	Property "displayText" As "String";	COMMENT = "";
	Property "dragEnabled" As "Boolean";	COMMENT = "";
	Property "echoMode" As "QLineEdit::EchoMode";	COMMENT = "";
	Property "frame" As "Boolean";	COMMENT = "";
	Property "hasSelectedText" As "Boolean";	COMMENT = "";
	Property "inputMask" As "String";	COMMENT = "";
	Property "maxLength" As "Integer";	COMMENT = "";
	Property "modified" As "Boolean";	COMMENT = "";
	Property "placeholderText" As "String";	COMMENT = "";
	Property "readOnly" As "Boolean";	COMMENT = "";
	Property "redoAvailable" As "Boolean";	COMMENT = "";
	Property "selectedText" As "String";	COMMENT = "";
	Property "text" As "String";	COMMENT = "";
	Property "undoAvailable" As "Boolean";	COMMENT = "";

	Function "alignment"___("") As "Qt::Alignment";	COMMENT = "";
	Sub "backspace"___("");	COMMENT = "";
	Function "createStandardContextMenu"___("") As "QMenu";	COMMENT = "";
	Sub "cursorBackward"___("Mark As Boolean, Steps As Integer");	COMMENT = "";
	Sub "cursorForward"___("Mark As Boolean, Steps As Integer");	COMMENT = "";
	Function "cursorMoveStyle"___("") As "Qt::CursorMoveStyle";	COMMENT = "";
	Function "cursorPosition"___("") As "Integer";	COMMENT = "";
	Function "cursorPositionAt"___("Pos As QPoint") As "Integer";	COMMENT = "";
	Sub "cursorWordBackward"___("Mark As Boolean");	COMMENT = "";
	Sub "cursorWordForward"___("Mark As Boolean");	COMMENT = "";
	Sub "del"___("");	COMMENT = "";
	Sub "deselect"___("");	COMMENT = "";
	Function "displayText"___("") As "String";	COMMENT = "";
	Function "dragEnabled"___("") As "Boolean";	COMMENT = "";
	Function "echoMode"___("") As "QLineEdit::EchoMode";	COMMENT = "";
	Sub "end"___("Mark As Boolean");	COMMENT = "";
	//Sub "getTextMargins"___("Left As Integer, Top As Integer, Right As Integer, Bottom As Integer");	COMMENT = "";
	Function "hasAcceptableInput"___("") As "Boolean";	COMMENT = "";
	Function "hasFrame"___("") As "Boolean";	COMMENT = "";
	Function "hasSelectedText"___("") As "Boolean";	COMMENT = "";
	Sub "home"___("Mark As Boolean");	COMMENT = "";
	Function "inputMask"___("") As "String";	COMMENT = "";
	Sub "insert"___("NewText As String");	COMMENT = "";
	Function "isModified"___("") As "Boolean";	COMMENT = "";
	Function "isReadOnly"___("") As "Boolean";	COMMENT = "";
	Function "isRedoAvailable"___("") As "Boolean";	COMMENT = "";
	Function "isUndoAvailable"___("") As "Boolean";	COMMENT = "";
	Function "maxLength"___("") As "Integer";	COMMENT = "";
	Function "placeholderText"___("") As "String";	COMMENT = "";
	Function "selectedText"___("") As "String";	COMMENT = "";
	Function "selectionStart"___("") As "Integer";	COMMENT = "";
	Sub "setAlignment"___("Flag As Qt::Alignment");	COMMENT = "";
	Sub "setCursorMoveStyle"___("Style As Qt::CursorMoveStyle");	COMMENT = "";
	Sub "setCursorPosition"___("Position As Integer");	COMMENT = "";
	Sub "setDragEnabled"___("B As Boolean");	COMMENT = "";
	Sub "setEchoMode"___("Mode As QLineEdit::EchoMode");	COMMENT = "";
	Sub "setFrame"___("Frame As Boolean");	COMMENT = "";
	Sub "setInputMask"___("InputMask As String");	COMMENT = "";
	Sub "setMaxLength"___("Length As Integer");	COMMENT = "";
	Sub "setModified"___("Modified As Boolean");	COMMENT = "";
	Sub "setPlaceholderText"___("PlaceHolder As String");	COMMENT = "";
	Sub "setReadOnly"___("Ro As Boolean");	COMMENT = "";
	Sub "setSelection"___("Start As Integer, Length As Integer");	COMMENT = "";
	Sub "setTextMargins"___("Left As Integer, Top As Integer, Right As Integer, Bottom As Integer");	COMMENT = "";
	Function "text"___("") As "String";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "copy"___("");	COMMENT = "";
	Slot "cut"___("");	COMMENT = "";
	Slot "paste"___("");	COMMENT = "";
	Slot "redo"___("");	COMMENT = "";
	Slot "selectAll"___("");	COMMENT = "";
	Slot "setText"___("Text As String");	COMMENT = "";
	Slot "undo"___("");	COMMENT = "";

	Signal "cursorPositionChanged"___("OldPosition As Integer, NewPosition As Integer") Declare "void cursorPositionChanged(int oldPosition, int newPosition)"	COMMENT = "";
	Signal "editingFinished"___("") Declare "void editingFinished()"	COMMENT = "";
	Signal "returnPressed"___("") Declare "void returnPressed()"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";
	Signal "textChanged"___("Text As String") Declare "void textChanged(const QString & text)"	COMMENT = "";
	Signal "textEdited"___("Text As String") Declare "void textEdited(const QString & text)"	COMMENT = "";

End_Class



Class "QTreeWidgetItem"

	Sub "addChild"___("Child As QTreeWidgetItem");	COMMENT = "";
	Function "background"___("Column As Integer") As "QBrush";	COMMENT = "";
	Function "checkState"___("Column As Integer") As "Qt::CheckState";	COMMENT = "";
	Function "child"___("Index As Integer") As "QTreeWidgetItem";	COMMENT = "";
	Function "childCount"___("") As "Integer";	COMMENT = "";
	Function "childIndicatorPolicy"___("") As "QTreeWidgetItem::ChildIndicatorPolicy";	COMMENT = "";
	Function "clone"___("") As "QTreeWidgetItem";	COMMENT = "";
	Function "columnCount"___("") As "Integer";	COMMENT = "";
	Function "flags"___("") As "Qt::ItemFlags";	COMMENT = "";
	Function "font"___("Column As Integer") As "QFont";	COMMENT = "";
	Function "foreground"___("Column As Integer") As "QBrush";	COMMENT = "";
	Function "icon"___("Column As Integer") As "QIcon";	COMMENT = "";
	Function "indexOfChild"___("Child As QTreeWidgetItem") As "Integer";	COMMENT = "";
	Sub "insertChild"___("Index As Integer, Child As QTreeWidgetItem");	COMMENT = "";
	Function "isDisabled"___("") As "Boolean";	COMMENT = "";
	Function "isExpanded"___("") As "Boolean";	COMMENT = "";
	Function "isFirstColumnSpanned"___("") As "Boolean";	COMMENT = "";
	Function "isHidden"___("") As "Boolean";	COMMENT = "";
	Function "isSelected "___("") As "Boolean";	COMMENT = "";
	Function "parent"___("") As "QTreeWidgetItem";	COMMENT = "";
	//Sub "read"___("In As QDataStream");	COMMENT = "";
	Sub "removeChild"___("Child As QTreeWidgetItem");	COMMENT = "";
	Sub "setBackground"___("Column As Integer, Brush As QBrush");	COMMENT = "";
	Sub "setCheckState"___("Column As Integer, State As Qt::CheckState");	COMMENT = "";
	Sub "setChildIndicatorPolicy"___("Policy As QTreeWidgetItem::ChildIndicatorPolicy");	COMMENT = "";
	Sub "setDisabled"___("Disabled As Boolean");	COMMENT = "";
	Sub "setExpanded"___("Expand As Boolean");	COMMENT = "";
	Sub "setFirstColumnSpanned"___("Span As Boolean");	COMMENT = "";
	Sub "setFlags"___("Flags As Qt::ItemFlags");	COMMENT = "";
	Sub "setFont"___("Column As Integer, Font As QFont");	COMMENT = "";
	Sub "setForeground"___("Column As Integer, Brush As QBrush");	COMMENT = "";
	Sub "setHidden"___("Hide As Boolean");	COMMENT = "";
	Sub "setIcon"___("Column As Integer, Icon As QIcon");	COMMENT = "";
	Sub "setSelected"___("Select As Boolean");	COMMENT = "";
	Sub "setSizeHint"___("Column As Integer, Size As QSize");	COMMENT = "";
	Sub "setStatusTip"___("Column As Integer, StatusTip As String");	COMMENT = "";
	Sub "setText"___("Column As Integer, Text As String");	COMMENT = "";
	Sub "setTextAlignment"___("Column As Integer, Alignment As Integer");	COMMENT = "";
	Sub "setToolTip"___("Column As Integer, ToolTip As String");	COMMENT = "";
	Sub "setWhatsThis"___("Column As Integer, WhatThis As String");	COMMENT = "";
	Function "sizeHint"___("Column As Integer") As "QSize";	COMMENT = "";
	Function "statusTip"___("Column As Integer") As "String";	COMMENT = "";
	Function "takeChild"___("Index As Integer") As "QTreeWidgetItem";	COMMENT = "";
	Function "text"___("Column As Integer") As "String";	COMMENT = "";
	Function "textAlignment"___("Column As Integer") As "Integer";	COMMENT = "";
	Function "toolTip"___("Column As Integer") As "String";	COMMENT = "";
	Function "treeWidget"___("") As "QTreeWidget";	COMMENT = "";
	Function "type"___("") As "Integer";	COMMENT = "";
	Function "whatsThis"___("Column As Integer") As "String";	COMMENT = "";
	//Sub "write"___("Out As QDataStream");	COMMENT = "";

End_Class



Class "QStackedWidget" SuperClass "QFrame"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentIndex" As "Integer";	COMMENT = "";

	Function "addWidget"___("Widget As QWidget") As "Integer";	COMMENT = "";
	Function "count"___("") As "Integer";	COMMENT = "";
	Function "currentIndex"___("") As "Integer";	COMMENT = "";
	Function "indexOf"___("Widget As QWidget") As "Integer";	COMMENT = "";
	Function "insertWidget"___("Index As Integer, Widget As QWidget") As "Integer";	COMMENT = "";
	Sub "removeWidget"___("Widget As QWidget");	COMMENT = "";
	Function "widget"___("Index As Integer") As "QWidget";	COMMENT = "";
	
	Slot "setCurrentIndex"___("Index As Integer");	COMMENT = "";
	Slot "setCurrentWidget"___("Widget As QWidget");	COMMENT = "";

	Signal "currentChanged"___("Index As Integer") Declare "void currentChanged(int index)"	COMMENT = "";
	Signal "widgetRemoved"___("Index As Integer") Declare "void widgetRemoved(int index)"	COMMENT = "";

End_Class



Class "QWebView" SuperClass "QWidget"

	Property "icon" As "QIcon";	COMMENT = "";
	Property "modified" As "Boolean";	COMMENT = "";
	Property "selectedText" As "String";	COMMENT = "";
	Property "renderHints" As "QPainter::RenderHints";	COMMENT = "";
	Property "title" As "String";	COMMENT = "";
	Property "url" As "QUrl";	COMMENT = "";
	Property "zoomFactor" As "Float";	COMMENT = "";

	Function "findText"___("SubString As String, Options As QWebPage::FindFlags") As "Boolean";	COMMENT = "";
	Function "history"___("") As "QWebHistory";	COMMENT = "";
	Function "icon"___("") As "QIcon";	COMMENT = "";
	Function "isModified"___("") As "Boolean";	COMMENT = "";
	Sub "load"___("Url As QUrl");	COMMENT = "";
	Sub "load2"___("Request As QNetworkRequest, Operation As QNetworkAccessManager::Operation, Body As QByteArray");	COMMENT = "";
	Function "page"___("") As "QWebPage";	COMMENT = "";
	Sub "setPage"___("Page As QWebPage");	COMMENT = "";
	Sub "setHtml"___("Html As String, BaseUrl As QUrl");	COMMENT = "";
	Sub "setTextSizeMultiplier"___("Factor As Float");	COMMENT = "";
	Sub "setUrl"___("Url As QUrl");	COMMENT = "";
	Sub "setZoomFactor"___("Factor As Float");	COMMENT = "";
	Function "settings"___("") As "QWebSettings";	COMMENT = "";
	Function "textSizeMultiplier"___("") As "Float";	COMMENT = "";
	Function "title"___("") As "String";	COMMENT = "";
	Sub "triggerPageAction"___("Action As QWebPage::WebAction, Checked As Boolean");	COMMENT = "";
	Function "url"___("") As "QUrl";	COMMENT = "";
	Function "zoomFactor"___("") As "Float";	COMMENT = "";
	
	Slot "back"___("");	COMMENT = "";
	Slot "forward"___("");	COMMENT = "";
	Slot "print"___("Printer As QPrinter");	COMMENT = "";
	Slot "reload"___("");	COMMENT = "";
	Slot "stop"___("");	COMMENT = "";

	Signal "iconChanged"___("") Declare "void iconChanged()"	COMMENT = "";
	Signal "linkClicked"___("Url As QUrl") Declare "void linkClicked(const QUrl & url)"	COMMENT = "";
	Signal "loadFinished"___("Ok As Boolean") Declare "void loadFinished(bool ok)"	COMMENT = "";
	Signal "loadProgress"___("Progress As Integer") Declare "void loadProgress(int progress)"	COMMENT = "";
	Signal "loadStarted"___("") Declare "void loadStarted()"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";
	Signal "statusBarMessage"___("Text As String") Declare "void statusBarMessage(const QString & text)"	COMMENT = "";
	Signal "titleChanged"___("Title As String") Declare "void titleChanged(const QString & title)"	COMMENT = "";
	Signal "urlChanged"___("Url As QUrl") Declare "void urlChanged(const QUrl & url)"	COMMENT = "";

End_Class



Class "QWebSettings"

	Function "defaultTextEncoding"___("") As "String";	COMMENT = "";
	Function "fontFamily"___("Which As QWebSettings::FontFamily") As "String";	COMMENT = "";
	Function "fontSize"___("Type As QWebSettings::FontSize") As "Integer";	COMMENT = "";
	Function "localStoragePath"___("") As "String";	COMMENT = "";

	Sub "resetFontFamily"___("Which As QWebSettings::FontFamily");	COMMENT = "";
	Sub "resetFontSize"___("Type As QWebSettings::FontSize");	COMMENT = "";
	Sub "setAttribute"___("Attribute As QWebSettings::WebAttribute, On As Boolean");	COMMENT = "";
	Sub "setDefaultTextEncoding"___("Encoding As String");	COMMENT = "";
	Sub "setFontFamily"___("Which As QWebSettings::FontFamily, Family As String");	COMMENT = "";
	Sub "setFontSize"___("Type As QWebSettings::FontSize, Size As Integer");	COMMENT = "";
	Sub "setLocalStoragePath"___("Path As String");	COMMENT = "";
	Function "testAttribute"___("Attribute As QWebSettings::WebAttribute") As "Boolean";	COMMENT = "";

End_Class



Class "QTextEdit" SuperClass "QAbstractScrollArea"

	Property "acceptRichText" As "Boolean";	COMMENT = "";
	Property "autoFormatting" As "QTextEdit::AutoFormatting";	COMMENT = "";
	Property "cursorWidth" As "Integer";	COMMENT = "";
	Property "documentTitle" As "String";	COMMENT = "";
	Property "html" As "String";	COMMENT = "";
	Property "lineWrapColumnOrWidth" As "Integer";	COMMENT = "";
	Property "lineWrapMode" As "QTextEdit::LineWrapMode";	COMMENT = "";
	Property "overwriteMode" As "Boolean";	COMMENT = "";
	Property "plainText" As "String";	COMMENT = "";
	Property "readOnly" As "Boolean";	COMMENT = "";
	Property "tabChangesFocus" As "Boolean";	COMMENT = "";
	Property "tabStopWidth" As "Integer";	COMMENT = "";
	Property "textInteractionFlags" As "Qt::TextInteractionFlags";	COMMENT = "";
	Property "undoRedoEnabled" As "Boolean";	COMMENT = "";
	Property "wordWrapMode" As "QTextOption::WrapMode";	COMMENT = "";

	Function "acceptRichText"___("") As "Boolean";	COMMENT = "";
	Function "alignment"___("") As "Qt::Alignment";	COMMENT = "";
	Function "anchorAt"___("Pos As QPoint") As "String";	COMMENT = "";
	Function "autoFormatting"___("") As "QTextEdit::AutoFormatting";	COMMENT = "";
	Function "canPaste"___("") As "Boolean";	COMMENT = "";
	Function "createStandardContextMenu"___("") As "QMenu";	COMMENT = "";
	Function "createStandardContextMenu2"___("Position As QPoint") As "QMenu";	COMMENT = "";
	Function "currentFont"___("") As "QFont";	COMMENT = "";
	Function "cursorForPosition"___("Pos As QPoint") As "QTextCursor";	COMMENT = "";
	Function "cursorWidth"___("") As "Integer";	COMMENT = "";
	Function "document"___("") As "QTextDocument";	COMMENT = "";
	Function "documentTitle"___("") As "String";	COMMENT = "";
	Sub "ensureCursorVisible"___("");	COMMENT = "";
	Function "find"___("Exp As String, Options As QTextDocument::FindFlags") As "Boolean";	COMMENT = "";
	Function "fontFamily"___("") As "String";	COMMENT = "";
	Function "fontItalic"___("") As "Boolean";	COMMENT = "";
	Function "fontPointSize"___("") As "Float";	COMMENT = "";
	Function "fontUnderline"___("") As "Boolean";	COMMENT = "";
	Function "fontWeight"___("") As "Integer";	COMMENT = "";
	Function "isReadOnly"___("") As "Boolean";	COMMENT = "";
	Function "isUndoRedoEnabled"___("") As "Boolean";	COMMENT = "";
	Function "lineWrapColumnOrWidth"___("") As "Integer";	COMMENT = "";
	Function "lineWrapMode"___("") As "QTextEdit::LineWrapMode";	COMMENT = "";

	Sub "moveCursor"___("Operation As QTextCursor::MoveOperation, Mode As QTextCursor::MoveMode");	COMMENT = "";
	Function "overwriteMode"___("") As "Boolean";	COMMENT = "";
	Sub "print"___("Printer As QPrinter");	COMMENT = "";
	Sub "setAcceptRichText"___("Accept As Boolean");	COMMENT = "";
	Sub "setAutoFormatting"___("Features As QTextEdit::AutoFormatting");	COMMENT = "";
	Sub "setCursorWidth"___("Width As Integer");	COMMENT = "";
	Sub "setDocument"___("Document As QTextDocument");	COMMENT = "";
	Sub "setDocumentTitle"___("Title As String");	COMMENT = "";
	Sub "setLineWrapColumnOrWidth"___("W As Integer");	COMMENT = "";
	Sub "setLineWrapMode"___("Mode As QTextEdit::LineWrapMode");	COMMENT = "";
	Sub "setOverwriteMode"___("Overwrite As Boolean");	COMMENT = "";
	Sub "setReadOnly"___("ReadOnly As Boolean");	COMMENT = "";
	Sub "setTabChangesFocus"___("B As Boolean");	COMMENT = "";
	Sub "setTabStopWidth"___("Width As Integer");	COMMENT = "";
	Sub "setTextCursor"___("Cursor As QTextCursor");	COMMENT = "";
	Sub "setTextInteractionFlags"___("Flags As Qt::TextInteractionFlags");	COMMENT = "";
	Sub "setUndoRedoEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setWordWrapMode"___("Policy As QTextOption::WrapMode");	COMMENT = "";
	Function "tabChangesFocus"___("") As "Boolean";	COMMENT = "";
	Function "tabStopWidth"___("") As "Integer";	COMMENT = "";
	Function "textBackgroundColor"___("") As "QColor";	COMMENT = "";
	Function "textColor"___("") As "QColor";	COMMENT = "";
	Function "textCursor"___("") As "QTextCursor";	COMMENT = "";
	Function "textInteractionFlags"___("") As "Qt::TextInteractionFlags";	COMMENT = "";
	Function "toHtml"___("") As "String";	COMMENT = "";
	Function "toPlainText"___("") As "String";	COMMENT = "";
	Function "wordWrapMode"___("") As "QTextOption::WrapMode";	COMMENT = "";

	Slot "append"___("Text As String");	COMMENT = "";
	Slot "clear"___("");	COMMENT = "";
	Slot "copy"___("");	COMMENT = "";
	Slot "cut"___("");	COMMENT = "";
	Slot "insertHtml"___("Text As String");	COMMENT = "";
	Slot "insertPlainText"___("Text As String");	COMMENT = "";
	Slot "paste"___("");	COMMENT = "";
	Slot "redo"___("");	COMMENT = "";
	Slot "scrollToAnchor"___("Name As String");	COMMENT = "";
	Slot "selectAll"___("");	COMMENT = "";
	Slot "setAlignment"___("A As Qt::Alignment");	COMMENT = "";
	Slot "setCurrentFont"___("F As QFont");	COMMENT = "";
	Slot "setFontFamily"___("FontFamily As String");	COMMENT = "";
	Slot "setFontItalic"___("Italic As Boolean");	COMMENT = "";
	Slot "setFontPointSize"___("S As Float");	COMMENT = "";
	Slot "setFontUnderline"___("Underline As Boolean");	COMMENT = "";
	Slot "setFontWeight"___("Weight As Integer");	COMMENT = "";
	Slot "setHtml"___("Text As String");	COMMENT = "";
	Slot "setPlainText"___("Text As String");	COMMENT = "";
	Slot "setText"___("Text As String");	COMMENT = "";
	Slot "setTextBackgroundColor"___("C As QColor");	COMMENT = "";
	Slot "setTextColor"___("C As QColor");	COMMENT = "";
	Slot "undo"___("");	COMMENT = "";
	Slot "zoomIn"___("Range As Integer");	COMMENT = "";
	Slot "zoomOut"___("Range As Integer");	COMMENT = "";

	Signal "copyAvailable"___("Yes As Boolean") Declare "void copyAvailable(bool yes)"	COMMENT = "";
	Signal "cursorPositionChanged"___("") Declare "void cursorPositionChanged()"	COMMENT = "";
	Signal "redoAvailable"___("Available As Boolean") Declare "void redoAvailable(bool available)"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";
	Signal "textChanged"___("") Declare "void textChanged()"	COMMENT = "";
	Signal "undoAvailable"___("Available As Boolean") Declare "void undoAvailable(bool available)"	COMMENT = "";

End_Class


Class "QAbstractButton" SuperClass "QWidget"

  Property "autoExclusive" As "Boolean";  COMMENT = "";
  Property "autoRepeat" As "Boolean"; COMMENT = "";
  Property "autoRepeatDelay" As "Integer"; COMMENT = "";
  Property "autoRepeatInterval" As "Integer"; COMMENT = "";
  Property "checkable" As "Boolean"; COMMENT = "";
  Property "checked" As "Boolean"; COMMENT = "";
  Property "down" As "Boolean"; COMMENT = "";
  Property "icon" As "QIcon"; COMMENT = "";
  Property "iconSize" As "QSize"; COMMENT = "";
  Property "shortcut" As "QKeySequence"; COMMENT = "";
  Property "text" As "String"; COMMENT = "";

  Function "group"___("") As "QButtonGroup";  COMMENT = ""; 
  Function "icon"___("") As "QIcon"; COMMENT = ""; 

  Slot "animateClick"___("MiliSeconds As Integer");  COMMENT = "";
  Slot "click"___("");  COMMENT = "";
  Slot "toggle"___("");  COMMENT = "";
    
  Signal "pressed"___("") Declare "void pressed()"  COMMENT = "";
  Signal "released"___("") Declare "void released()"  COMMENT = "";
    
End_Class



Class "QCalendarWidget" SuperClass "QWidget"

	Property "dateEditAcceptDelay" As "Integer";	COMMENT = "";
	Property "dateEditEnabled" As "Boolean";    COMMENT = "";
	Property "gridVisible" As "Boolean";    COMMENT = "";
	Property "maximumDate" As "QDate";    COMMENT = "";
	Property "minimumDate" As "QDate";    COMMENT = "";
	Property "navigationBarVisible" As "Boolean";	COMMENT = "";
	Property "selectedDate" As "QDate";	COMMENT = "";

    Function "monthShown"___("") As "Integer";	COMMENT = "";
	Function "selectedDate"___("") As "QDate";	COMMENT = "";
	Function "yearShown"___("") As "Integer";	COMMENT = "";

	Sub "setCurrentPage"___("Year As Integer, Month As Integer");	COMMENT = "";
	Sub "setDateRange"___("Minimum As QDate, Maximum As QDate");	COMMENT = "";
    Sub "setSelectedDate"___("Date As QDate"); COMMENT = "";
	Sub "showNextMonth"___("");	COMMENT = "";
	Sub "showNextYear"___("");	COMMENT = "";
	Sub "showPreviousMonth"___("");	COMMENT = "";
	Sub "showPreviousYear"___("");	COMMENT = "";
	Sub "showSelectedDate"___("");	COMMENT = "";
	Sub "showToday"___("");	COMMENT = "";

	Signal "activated"___("Date As QDate") Declare "void activated(const QDate & date)"	COMMENT = "";
	Signal "clicked"___("Date As QDate") Declare "void clicked(const QDate & date)"	COMMENT = "";
	Signal "currentPageChanged"___("Year As Integer, Month As Integer") Declare "void currentPageChanged(int year, int month)"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";

End_Class



Class "QChar"

	Function "hasMirrored"___("") As "Boolean";	COMMENT = "";
	Function "isDigit"___("") As "Boolean";	COMMENT = "";
	Function "isHighSurrogate"___("") As "Boolean";	COMMENT = "";	
    Function "isLetter"___("") As "Boolean";	COMMENT = "";
	Function "isLetterOrNumber"___("") As "Boolean";	COMMENT = "";    
	Function "isLowSurrogate"___("") As "Boolean";	COMMENT = "";	
	Function "isLower"___("") As "Boolean";	COMMENT = "";
	Function "isMark"___("") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isNumber"___("") As "Boolean";	COMMENT = "";
	Function "isPrint"___("") As "Boolean";	COMMENT = "";
	Function "isPunct"___("") As "Boolean";	COMMENT = "";
	Function "isSpace"___("") As "Boolean";	COMMENT = "";
	Function "isSymbol"___("") As "Boolean";	COMMENT = "";
	Function "isTitleCase"___("") As "Boolean";	COMMENT = "";
	Function "isUpper"___("") As "Boolean";	COMMENT = "";
	Function "mirroredChar"___("") As "QChar";	COMMENT = "";
	//Function "toLatin1"___("") As "String";	COMMENT = "";			'String? or char?
	Function "toCaseFolded"___("") As "QChar";	COMMENT = "";
	//Function "toLatin1"___("") As "String";	COMMENT = "";			'String? or char?
	Function "toLower"___("") As "QChar";	COMMENT = "";
	Function "toTitleCase"___("") As "QChar";	COMMENT = "";
	Function "toUpper"___("") As "QChar";	COMMENT = "";

End_Class




Class "QCheckBox" SuperClass "QAbstractButton"

	Property "tristate" As "Boolean";	COMMENT = "";

	Function "checkState"___("") As "Qt.CheckState";	COMMENT = "";
	Function "setCheckState"___("State As Qt.CheckState") As "";	COMMENT = "";

	Signal "stateChanged"___("State As Integer") Declare "void stateChanged(int state)"	COMMENT = "";

End_Class




Class "QDate"

	Function "addDays"___("NumberDays As Integer") As "QDate";	COMMENT = "";
	Function "addMonths"___("NumberMonths As Integer") As "QDate";	COMMENT = "";
	Function "addYears"___("NumberYears As Integer") As "QDate";	COMMENT = "";
	Function "day"___("") As "Integer";	COMMENT = "";
	Function "dayOfWeek"___("") As "Integer";	COMMENT = "";
	Function "dayOfYear"___("") As "Integer";	COMMENT = "";
	Function "daysInMonth"___("") As "Integer";	COMMENT = "";
	Function "daysInYear"___("") As "Integer";	COMMENT = "";
	Function "daysTo"___("Date As QDate") As "Integer";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "month"___("") As "Integer";	COMMENT = "";
	Function "setDate"___("Year As Integer, Month As Integer, Day As Integer") As "Boolean";	COMMENT = "";
	Function "toJulianDay"___("") As "Integer";	COMMENT = "";
	Function "toString"___("Format As String") As "String";	COMMENT = "";
	//Function "weekNumber"___("YearNumber As Integer") As "Integer";	COMMENT = "";		'not sure. Argument is a pointer to an integer
	Function "year"___("") As "Integer";	COMMENT = "";

End_Class



Class "QDateTime"

	Function "addDays"___("NumberDays As Integer") As "QDateTime";	COMMENT = "";
	Function "addMSecs"___("Milliseconds As Integer") As "QDateTime";	COMMENT = "";
	Function "addMonths"___("NumberMonths As Integer") As "QDateTime";	COMMENT = "";
	Function "addSecs"___("NumberSeconds As Integer") As "QDateTime";	COMMENT = "";
	Function "addYears"___("NumberYears As Integer") As "QDateTime";	COMMENT = "";
	Function "date"___("") As "QDate";	COMMENT = "";
	Function "daysTo"___("Other As QDateTime") As "Integer";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "msecsTo"___("Other As QDateTime") As "Integer";	COMMENT = "";
	Function "secsTo"___("Other As QDateTime") As "Integer";	COMMENT = "";
	Function "setDate"___("Date As QDate");	COMMENT = ""
	Function "setMSecsSinceEpoch"___("Milliseconds As Integer");	COMMENT = "";
	Function "setTime"___("Time As QTime");	COMMENT = "";
	Function "time"___("") As "QTime";	COMMENT = "";
	Function "toLocalTime"___("") As "QDateTime";	COMMENT = "";
	Function "toMSecsSinceEpoch"___("") As "Integer";	COMMENT = "";
	Function "toString"___("Format As String") As "String";	COMMENT = "";

End_Class



Class "QDateTimeEdit" SuperClass "QAbstractSpinBox"

	Property "calendarPopup" As "Boolean";	COMMENT = "";
	Property "currentSection" As "QDateTimeEdit.Section";	COMMENT = "";	
	Property "currentSectionIndex" As "Integer";	COMMENT = "";		
	Property "date" As "QDate";	COMMENT = "";
	Property "dateTime" As "QDateTime";	COMMENT = "";
	Property "displayFormat" As "String";	COMMENT = "";
	Property "displayedSections" As "Integer";	COMMENT = "";
	Property "maximumDate" As "QDate";	COMMENT = "";
	Property "maximumDateTime" As "QDateTime";	COMMENT = "";
	Property "maximumTime" As "QTime";	COMMENT = "";
	Property "minimumDate" As "QDate";	COMMENT = "";
	Property "minimumDateTime" As "QDateTime";	COMMENT = "";
	Property "minimumTime" As "QTime";	COMMENT = "";
	Property "sectionCount" As "Integer";	COMMENT = "";
	Property "time" As "QTime";	COMMENT = "";

	Function "calendarWidget"___("") As "QCalendarWidget";	COMMENT = "";
	Function "clearMaximumDate"___("");	COMMENT = "";
	Function "clearMaximumDateTime"___("");	COMMENT = "";
	Function "clearMaximumTime"___("");	COMMENT = "";
	Function "clearMinimumDate"___("");	COMMENT = "";
	Function "clearMinimumDateTime"___("");	COMMENT = "";
	Function "clearMinimumTime"___("");	COMMENT = "";
	Function "sectionAt"___("Index As Integer") As "Integer";	COMMENT = "";
	Function "sectionCount"___("") As "Integer";	COMMENT = "";
	Function "sectionText"___("Section As QDateTimeEdit.Section") As "String";	COMMENT = "";
	Sub "setCalendarPopup"___("Enable As Boolean");	COMMENT = "";
	Sub "setCalendarWidget"___("CalendarWidget As QCalendarWidget");	COMMENT = "";
	Sub "setDateRange"___("Minimum As QDate, Maximum As QDate");	COMMENT = "";
	Sub "setDateTimeRange"___("Minimum As QDateTime, Maximum As QDateTime");	COMMENT = "";
	Sub "setSelectedSection"___("Section As QDateTimeEdit.Section");	COMMENT = "";
	Sub "setTimeRange"___("Minimum As QTime, Maximum As QTime");	COMMENT = "";
	Function "time"___("") As "QTime";	COMMENT = "";

	Slot "setDate"___("Date As QDate");	COMMENT = "";
	Slot "setDateTime"___("DateTime As QDateTime");	COMMENT = "";
	Slot "setTime"___("Time As QTime");	COMMENT = "";

	Signal "dateChanged"___("Date As QDate") Declare "void dateChanged(const QDate & date)"	COMMENT = "";
	Signal "dateTimeChanged"___("DateTime As QDateTime") Declare "void dateTimeChanged(const QDateTime & datetime)"	COMMENT = "";
	Signal "timeChanged"___("Time As QTime") Declare "void timeChanged(const QTime & time)"	COMMENT = "";

End_Class



Class "QFileInfo"

	Function "absoluteDir"___("") As "QDir";	COMMENT = "";
	Function "absoluteFilePath"___("") As "String";	COMMENT = "";
	Function "absolutePath"___("") As "String";	COMMENT = "";
	Function "baseName"___("") As "String";	COMMENT = "";
	Function "bundleName"___("") As "String";	COMMENT = "";
	Function "caching"___("") As "Boolean";	COMMENT = "";
	Function "canonicalFilePath"___("") As "String";	COMMENT = "";
	Function "canonicalPath"___("") As "String";	COMMENT = "";
	Function "completeBaseName"___("") As "String";	COMMENT = "";
	Function "completeSuffix"___("") As "String";	COMMENT = "";
	Function "created"___("") As "QDateTime";	COMMENT = "";
	Function "dir"___("") As "QDir";	COMMENT = "";
	Function "exists"___("") As "Boolean";	COMMENT = "";
	Function "fileName"___("") As "String";	COMMENT = "";
	Function "filePath"___("") As "String";	COMMENT = "";
	Function "group"___("") As "String";	COMMENT = "";
	Function "groupId"___("") As "Integer";	COMMENT = "";
	Function "isAbsolute"___("") As "Boolean";	COMMENT = "";
	Function "isBundle"___("") As "Boolean";	COMMENT = "";
	Function "isDir"___("") As "Boolean";	COMMENT = "";
	Function "isExecutable"___("") As "Boolean";	COMMENT = "";
	Function "isFile"___("") As "Boolean";	COMMENT = "";
	Function "isHidden"___("") As "Boolean";	COMMENT = "";
	Function "isReadable"___("") As "Boolean";	COMMENT = "";
	Function "isRelative"___("") As "Boolean";	COMMENT = "";
	Function "isRoot"___("") As "Boolean";	COMMENT = "";
	Function "isSymLink"___("") As "Boolean";	COMMENT = "";
	Function "isWritable"___("") As "Boolean";	COMMENT = "";
	Function "lastModified"___("") As "QDateTime";	COMMENT = "";
	Function "lastRead"___("") As "QDateTime";	COMMENT = "";
	Function "makeAbsolute"___("") As "Boolean";	COMMENT = "";
	Function "owner"___("") As "String";	COMMENT = "";
	Function "ownerId"___("") As "Integer";	COMMENT = "";
	Function "path"___("") As "String";	COMMENT = "";
	Function "permission"___("Permissions As QFile.Permissions") As "Boolean";	COMMENT = "";
	Function "permissions"___("") As "QFile.Permissions";	COMMENT = "";
	Sub "refresh"___("");	COMMENT = "";
	Sub "setCaching"___("Enable As Boolean");	COMMENT = "";
	Sub "setFile"___("File As String");	COMMENT = "";
	Function "size"___("") As "Integer";	COMMENT = "";
	Function "suffix"___("") As "String";	COMMENT = "";
	Function "symLinkTarget"___("") As "String";	COMMENT = "";

End_Class




Class "QFileSystemWatcher" SuperClass "QObject"

	Sub "addPath"___("Path As String");	COMMENT = "";
	Sub "addPaths"___("Paths As List");	COMMENT = "";
	Function "directories"___("") As "List";	COMMENT = "";
	Function "files"___("") As "List";	COMMENT = "";
	Sub "removePath"___("Path As String");	COMMENT = "";
	Sub "removePaths"___("Paths As List");	COMMENT = "";

	Signal "directoryChanged"___("Path As String") Declare "void directoryChanged(const QString & path)"	COMMENT = "";
	Signal "fileChanged"___("Path As String") Declare "void fileChanged(const QString & path)"	COMMENT = "";

End_Class



Class "QLabel" SuperClass "QFrame"

	Property "alignment" As "Qt.Alignment";	COMMENT = "";
	Property "hasSelectedText" As "Boolean";	COMMENT = "";
	Property "indent" As "Integer";	COMMENT = "";
	Property "margin" As "Integer";	COMMENT = "";
	Property "openExternalLinks" As "Boolean";	COMMENT = "";
	Property "pixmap" As "QPixmap";	COMMENT = "";
	Property "scaledContents" As "Boolean";	COMMENT = "";
	Property "selectedText" As "String";	COMMENT = "";
	Property "text" As "String";	COMMENT = "";
	Property "textFormat" As "Qt.TextFormat";	COMMENT = "";
	Property "textInteractionFlags" As "Qt.TextInteractionFlags";	COMMENT = "";
	Property "wordWrap" As "Boolean";	COMMENT = "";
	
	Function "buddy"___("") As "QWidget";	COMMENT = "";
	Function "hasScaledContents"___("") As "Boolean";	COMMENT = "";
	Function "hasSelectedText"___("") As "Boolean";	COMMENT = "";
	Function "movie"___("") As "QMovie";	COMMENT = "";
	Function "picture"___("") As "QPicture";	COMMENT = "";
	Function "pixmap"___("") As "QPixmap";	COMMENT = "";
	Function "selectionStart"___("") As "Integer";	COMMENT = "";
	Sub "setBuddy"___("Buddy As QWidget");	COMMENT = "";
	Sub "setSelection"___("Start As Integer, Length As Integer");	COMMENT = "";
	Function "wordWrap"___("") As "Boolean";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "setMovie"___("Movie As QMovie");	COMMENT = "";
	Slot "setNum"___("Num As Integer");	COMMENT = "";
	Slot "setNum"___("Num As Float");	COMMENT = "";
	Slot "setPicture"___("Picture As QPicture");	COMMENT = "";
	Slot "setPixmap"___("Pixmap As QPixmap");	COMMENT = "";
	Slot "setText"___("Text As String");	COMMENT = "";

	Signal "linkActivated"___("Link As String") Declare "void linkActivated(const QString & link)"	COMMENT = "";
	Signal "linkHovered"___("Link As String") Declare "void linkHovered(const QString & link)"	COMMENT = "";

End_Class



Class "QMainWindow" SuperClass "QWidget"

	Property "animated" As "Boolean";	COMMENT = "";
	Property "dockNestingEnabled" As "Boolean";	COMMENT = "";
	Property "dockOptions" As "QMainWindow.DockOption";	COMMENT = "";
	Property "documentMode" As "Boolean";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "tabShape" As "QTabWidget.TabShape";	COMMENT = "";
	Property "toolButtonStyle" As "Qt.ToolButtonStyle";	COMMENT = "";
	Property "unifiedTitleAndToolBarOnMac" As "Boolean";	COMMENT = "";

	Sub "addDockWidget"___("Area As Qt.DockWidgetArea, DockWidget As QDockWidget");	COMMENT = "";
	Sub "addDockWidget2"___("Area As Qt.DockWidgetArea, DockWidget As QDockWidget, Orientation As Qt.Orientation");	COMMENT = "";
	Sub "addToolBar"___("Area As Qt.ToolBarArea, ToolBar As QToolBar");	COMMENT = "";
	Sub "addToolBar2"___("ToolBar As QToolBar");	COMMENT = "";
	Function "addToolBar"___("Title As String") As "QToolBar";	COMMENT = "";
	Sub "addToolBarBreak"___("Area As Qt.ToolBarArea");	COMMENT = "";

	Function "centralWidget"___("") As "QWidget";	COMMENT = "";
	Function "corner"___("Corner As Qt.Corner") As "Qt.DockWidgetArea";	COMMENT = "";

	Event "createPopupMenu"___("") As "QMenu" Declare "void QMenu *createPopupMenu()";	COMMENT = "";

	Function "dockWidgetArea"___("DockWidget As QDockWidget") As "Qt.DockWidgetArea";	COMMENT = "";
	Sub "insertToolBar"___("Before As QToolBar, ToolBar As QToolBar");	COMMENT = "";
	Sub "insertToolBarBreak"___("Before As QToolBar");	COMMENT = "";
	Function "menuBar"___("") As "QMenuBar";	COMMENT = "";
	Function "menuWidget"___("") As "QWidget";	COMMENT = "";

	Sub "removeDockWidget"___("DockWidget As QDockWidget");	COMMENT = "";
	Sub "removeToolBar"___("ToolBar As QToolBar");	COMMENT = "";
	Sub "removeToolBarBreak"___("Before As QToolBar");	COMMENT = "";
	Function "restoreDockWidget"___("DockWidget As QDockWidget") As "Boolean";	COMMENT = "";

	Function "restoreState"___("State As QByteArray, Version As Integer = 0") As "Boolean";	COMMENT = "";
	Function "saveState"___("Version As Integer = 0") As "QByteArray";	COMMENT = "";
	Sub "setCentralWidget"___("Widget As QWidget");	COMMENT = "";
	Sub "setCorner"___("Corner As Qt.Corner, Area As Qt.DockWidgetArea");	COMMENT = "";

	Sub "setMenuBar"___("MenuBar As QMenuBar");	COMMENT = "";
	Sub "setMenuWidget"___("MenuBar As QWidget");	COMMENT = "";
	Sub "setStatusBar"___("StatusBar As QStatusBar");	COMMENT = "";

	Sub "setTabPosition"___("Areas As Qt.DockWidgetAreas, TabPosition As QTabWidget.TabPosition");	COMMENT = "";
	Sub "setTabShape"___("TabShape As QTabWidget.TabShape");	COMMENT = "";
	Sub "splitDockWidget"___("First As QDockWidget, Second As QDockWidget, Orientation As Qt.Orientation");	COMMENT = "";
	Function "statusBar"___("") As "QStatusBar";	COMMENT = "";
	Function "tabPosition"___("Area As Qt.DockWidgetArea") As "QTabWiget.TabPosition";	COMMENT = "";
	Function "tabShape"___("") As "QTabWidget.TabShape";	COMMENT = "";
	Function "tabifiedDockWidgets"___("DockWidget As QDockWidget") As "List";	COMMENT = "";
	Sub "tabifyDockWidget"___("First As QDockWidget, Second As QDockWidget");	COMMENT = "";
	Function "toolBarArea"___("ToolBar As QToolBar") As "Qt.ToolBarArea";	COMMENT = "";
	Function "toolBarBreak"___("ToolBar As QToolBar") As "Boolean";	COMMENT = "";

	Slot "setAnimated"___("Enabled As Boolean");	COMMENT = "";
	Slot "setDockNestingEnabled"___("Enabled As Boolean");	COMMENT = "";

	//Signal "iconSizeChanged"___("IconSize As QSize") Declare "void iconSizeChanged(const QSize & iconSize)"	COMMENT = "";
	//Signal "toolButtonStyleChanged"___("ToolButtonStyle As Qt.ToolButtonStyle") Declare "void toolButtonStyleChanged(Qt.ToolButtonStyle toolButtonStyle)"	COMMENT = "";

End_Class




Class "QMdiArea" SuperClass "QAbstractScrollArea"

	Property "activationOrder" As "QMdiArea.WindowOrder";	COMMENT = "";
	Property "background" As "QBrush";	COMMENT = "";
	Property "documentMode" As "Boolean";	COMMENT = "";
	Property "tabPosition" As "QTabWidget.TabPosition";	COMMENT = "";
	Property "tabShape" As "QTabWidget.TabShape";	COMMENT = "";
	Property "viewMode" As "QMdiArea.ViewMode";	COMMENT = "";

	Function "activeSubWindow"___("") As "QMdiSubWindow";	COMMENT = "";
	Function "addSubWindow"___("Widget As QWidget, WindowFlags As Qt.WindowFlags") As "QMdiSubWindow";	COMMENT = "";
	Sub "removeSubWindow"___("Widget As QWidget");	COMMENT = "";
	Sub "setOption"___("Option As QMdiArea.AreaOption, On As Boolean");	COMMENT = "";
	Function "subWindowList"___("Order As QMdiArea.WindowOrder") As "List";	COMMENT = "";
	Function "testOption"___("Option As QMdiArea.AreaOption") As "Boolean";	COMMENT = "";

	Slot "activateNextSubWindow"___("");	COMMENT = "";
	Slot "activatePreviousSubWindow"___("");	COMMENT = "";
	Slot "cascadeSubWindows"___("");	COMMENT = "";
	Slot "closeActiveSubWindow"___("");	COMMENT = "";
	Slot "closeAllSubWindows"___("");	COMMENT = "";
	Slot "setActiveSubWindow"___("Window As QMdiSubWindow");	COMMENT = "";
	Slot "tileSubWindows"___("");	COMMENT = "";

	Signal "subWindowActivated"___("Window As QMdiSubWindow") Declare "void subWindowActivated(QMdiSubWindow * window)"	COMMENT = "";

End_Class




Class "QTabBar" SuperClass "QWidget"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentIndex" As "Integer";	COMMENT = "";
	Property "documentMode" As "Boolean";	COMMENT = "";
	Property "drawBase" As "Boolean";	COMMENT = "";
	Property "elideMode" As "Qt.TextElideMode";	COMMENT = "";
	Property "expanding" As "Boolean";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "movable" As "Boolean";	COMMENT = "";
	Property "selectionBehaviorOnRemove" As "QTabBar.SelectionBehavior";	COMMENT = "";
	Property "shape" As "QTabBar.Shape";	COMMENT = "";
	Property "tabsClosable" As "Boolean";	COMMENT = "";
	Property "usesScrollButtons" As "Boolean";	COMMENT = "";

	Function "addTab"___("Text As String") As "Integer";	COMMENT = "";
	Function "addTab"___("Icon As QIcon, Text As String") As "Integer";	COMMENT = "";
	Function "insertTab"___("Index As Integer, Text As String") As "Integer";	COMMENT = "";
	Function "insertTab"___("Index As Integer, Icon As QIcon, Text As String") As "Integer";	COMMENT = "";
	Function "isTabEnabled"___("Index As Integer") As "Boolean";	COMMENT = "";
	Sub "moveTab"___("FromTab As Integer, ToTab As Integer");	COMMENT = "";
	Sub "removeTab"___("Index As Integer");	COMMENT = "";
	Sub "setTabButton"___("Index As Integer, Position As QTabBar.ButtonPosition, Widget As QWidget");	COMMENT = "";
	Sub "setTabData"___("Index As Integer, Data As QVariant");	COMMENT = "";
	Sub "setTabEnabled"___("Index As Integer, Enabled As Boolean");	COMMENT = "";
	Sub "setTabIcon"___("Index As Integer, Icon As QIcon");	COMMENT = "";

	Sub "setTabText"___("Index As Integer, Text As String");	COMMENT = "";
	Sub "setTabTextColor"___("Index As Integer, Color As QColor");	COMMENT = "";
	Sub "setTabToolTip"___("Index As Integer, Tip As String");	COMMENT = "";
	Sub "setTabWhatsThis"___("Index As Integer, Text As String");	COMMENT = "";

	Function "tabAt"___("Position As QPoint") As "Integer";	COMMENT = "";
	Function "tabButton"___("Index As Integer, Position As QTabBar.ButtonPosition") As "QWidget";	COMMENT = "";
	Function "tabData"___("Index As Integer") As "QVariant";	COMMENT = "";
	Function "tabIcon"___("Index As Integer") As "QIcon";	COMMENT = "";
	Function "tabRect"___("Index As Integer") As "QRect";	COMMENT = "";
	Function "tabText"___("Index As Integer") As "String";	COMMENT = "";
	Function "tabTextColor"___("Index As Integer") As "QColor";	COMMENT = "";
	Function "tabToolTip"___("Index As Integer") As "String";	COMMENT = "";
	Function "tabWhatsThis"___("Index As Integer") As "String";	COMMENT = "";

	Slot "setCurrentIndex"___("Index As Integer");	COMMENT = "";

	Signal "currentChanged"___("Index As Integer") Declare "void currentChanged(int index)"	COMMENT = "";
	Signal "tabCloseRequested"___("Index As Integer") Declare "void tabCloseRequest(int index)"	COMMENT = "";
	Signal "tabMoved"___("From As Integer, ToTab As Integer") Declare "void tabMoved(int from, int to)"	COMMENT = "";

End_Class




Class "QMdiSubWindow" SuperClass "QWidget"

	Property "keyboardPageStep" As "Integer";	COMMENT = "";
	Property "keyboardSingleStep" As "Integer";	COMMENT = "";

	Function "isShaded"___("") As "Boolean";	COMMENT = "";
	Function "mdiArea"___("") As "QMdiArea";	COMMENT = "";
	Sub "setOption"___("Option As QMdiSubWindow.SubWindowOption, On As Boolean");	COMMENT = "";
	Sub "setSystemMenu"___("SystemMenu As QMenu");	COMMENT = "";	
	Sub "setWidget"___("Widget As QWidget");	COMMENT = "";
	Function "systemMenu"___("") As "QMenu";	COMMENT = "";
	Function "testOption"___("Option As QMdiSubWindow.SubWindowOption") As "Boolean";	COMMENT = "";
	Function "widget"___("") As "QWidget";	COMMENT = "";

	Slot "showShaded"___("");	COMMENT = "";
	Slot "showSystemMenu"___("");	COMMENT = "";

	Signal "aboutToActivate"___("") Declare "void aboutToActivate()"	COMMENT = "";
	Signal "windowStateChanged"___("OldState As Qt.WindowStates, NewState As Qt.WindowStates") Declare "void 	windowStateChanged(Qt.WindowStates oldState, Qt.WindowStates newState)"	COMMENT = "";

End_Class



Class "QLCDNumber" SuperClass "QFrame"

	Property "digitCount" As "Integer";	COMMENT = "";
	Property "intValue" As "Integer";	COMMENT = "";
	Property "mode" As "QLCDNumber.Mode";	COMMENT = "";
	Property "segmentStyle" As "QLCDNumber.SegmentStyle";	COMMENT = "";
	Property "smallDecimalPoint" As "Boolean";	COMMENT = "";
	Property "value" As "Float";	COMMENT = "";

	Function "checkOverflow"___("Number As Float") As "Boolean";	COMMENT = "";
	Function "checkOverflow2"___("Number As Integer") As "Boolean";	COMMENT = "";
	
	Slot "display"___("Text As String");	COMMENT = "";
	Slot "display2"___("Number As Float");	COMMENT = "";
	Slot "setBinMode"___("");	COMMENT = "";
	Slot "setDecMode"___("");	COMMENT = "";
	Slot "setHexMode"___("");	COMMENT = "";
	Slot "setOctMode"___("");	COMMENT = "";
	Slot "setSmallDecimalPoint"___("Enable As Boolean");	COMMENT = "";

	Signal "overflow"___("") Declare "void overflow()"	COMMENT = "";

End_Class



Class "QImage" //SuperClass "QPaintDevice"

	Function "allGray"___("") As "Boolean";	COMMENT = "";
	Function "bitPlaneCount"___("") As "Integer";	COMMENT = "";
	Function "byteCount"___("") As "Integer";	COMMENT = "";	
	Function "bytesPerLine"___("") As "Integer";	COMMENT = "";	
	Function "cacheKey"___("") As "Integer";	COMMENT = "";	
	Function "color"___("I As Integer") As "QRgb";	COMMENT = "";
	Function "colorCount"___("") As "Integer";	COMMENT = "";

	Function "convertToFormat"___("Format As QImage.Format, Flags As Qt.ImageConversionFlags") As "QImage";	COMMENT = "";
	Function "copy"___("Rectangle As QRect") As "QImage";	COMMENT = "";
	Function "copy"___("X As Integer, Y As Integer, Width As Integer, Height As Integer") As "QImage";	COMMENT = "";
	Function "createAlphaMask"___("Flags As Qt.ImageConversionFlags") As "QImage";	COMMENT = "";
	Function "createHeuristicMask"___("ClipTight As Boolean") As "QImage";	COMMENT = "";
	Function "createMaskFromColor"___("Color As QRgb, Mode As Qt.MaskMode") As "QImage";	COMMENT = "";
	
    Function "depth"___("") As "Integer";	COMMENT = "";
	Function "dotsPerMeterX"___("") As "Integer";	COMMENT = "";
	Function "dotsPerMeterY"___("") As "Integer";	COMMENT = "";
	Sub "fill"___("PixelValue As Integer");	COMMENT = "";
	Function "format"___("") As "Format As QImage.Format";	COMMENT = "";
	Function "hasAlphaChannel"___("") As "Boolean";	COMMENT = "";
	Function "height"___("") As "Integer";	COMMENT = "";

	Sub "invertPixels"___("Mode As QImage.InvertMode");	COMMENT = "";
	Function "isGrayscale"___("") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "load"___("FileName As String, Format As String") As "Boolean";	COMMENT = "";
	Function "loadFromData"___("Data As QByteArray, Format As String") As "Boolean";	COMMENT = "";
	Function "mirrored"___("Horizontal As Boolean, Vertical As Boolean") As "QImage";	COMMENT = "";
	Function "offset"___("") As "QPoint";	COMMENT = "";
	Function "pixel"___("Position As QPoint") As "QRgb";	COMMENT = "";
	Function "pixel"___("X As Integer, Y As Integer") As "QRgb";	COMMENT = "";
	Function "pixelIndex"___("Position As QPoint") As "Integer";	COMMENT = "";
	
    Function "rect"___("") As "QRect";	COMMENT = "";
	Function "rgbSwapped"___("") As "QImage";	COMMENT = "";
	Function "save"___("FileName As String, Format As String, Quality As Integer") As "Boolean";	COMMENT = "";
  Function "scaled"___("Size As QSize, AspectRatioMode As Qt.AspectRatioMode, TransformMode As Qt::TransformationMode") As "QImage";	COMMENT = "";
  Function "scaled2"___("Width As Integer, Heigth As Integer, AspectRatioMode As Qt::AspectRatioMode, TransformMode As Qt.TransformationMode") As "QImage";	COMMENT = "";
	Function "scaledToHeight"___("Height As Integer, Mode As Qt.TransformationMode") As "QImage";	COMMENT = "";
	Function "scaledToWidth"___("Width As Integer, Mode As Qt.TransformationMode") As "QImage";	COMMENT = "";

	Sub "setColor"___("Index As Integer, ColorValue As QRgb");	COMMENT = "";
	Sub "setColorCount"___("ColorCount As Integer");	COMMENT = "";
	Sub "setDotsPerMeterX"___("X As Integer");	COMMENT = "";
	Sub "setDotsPerMeterY"___("Y As Integer");	COMMENT = "";
	Sub "setOffset"___("Offset As QPoint");	COMMENT = "";
	Sub "setPixel"___("Position As QPoint, IndexOrRgb As Integer");	COMMENT = "";
	Sub "setPixel2"___("X As Integer, Y As Integer, IndexOrRgb As Integer");	COMMENT = "";
	Sub "setText"___("Key As String, Text As String");	COMMENT = "";
	Function "size"___("") As "QSize";	COMMENT = "";
	Function "text"___("Key As String") As "String";	COMMENT = "";
	Function "textKeys"___("") As "List";	COMMENT = "";
	Function "transformed"___("Matrix As QMatrix, Mode As Qt.TransformationMode") As "QImage";	COMMENT = "";
	Function "transformed2"___("Matrix As QTransform, Mode As Qt.TransformationMode") As "QImage";	COMMENT = "";
	Function "valid"___("Position As QPoint") As "Boolean";	COMMENT = "";
	Function "valid2"___("X As Integer, Y As Integer") As "Boolean";	COMMENT = "";
	Function "width"___("") As "Integer";	COMMENT = "";

End_Class



Class "QScrollArea" SuperClass "QAbstractScrollArea"

	Property "alignment" As "Qt.Alignment";	COMMENT = "";
	Property "widgetResizable" As "Boolean";	COMMENT = "";

	Sub "ensureVisible"___("X As Integer, Y As Integer, YMargin As Integer");	COMMENT = "";
	Sub "ensureWidgetVisible"___("ChildWidget As QWidget, XMargin As Integer, YMargin As Integer");	COMMENT = "";	
	Sub "setWidget"___("Widget As QWidget");	COMMENT = "";
	Function "takeWidget"___("") As "QWidget";	COMMENT = "";
	Function "widget"___("") As "QWidget";	COMMENT = "";

End_Class



Class "QSignalMapper" SuperClass "QObject"

	Function "mapping"___("theId As Integer") As "QObject";	COMMENT = "";
	Function "mapping2"___("theId As String") As "QObject";	COMMENT = "";
	Function "mapping3"___("theObject As QObject") As "QObject";	COMMENT = "";
	Sub "removeMappings"___("Sender As QObject");	COMMENT = "";
	Sub "setMapping"___("Sender As QObject, theId As Integer");	COMMENT = "";
	Sub "setMapping2"___("Sender As QObject, Text As String");	COMMENT = "";
	Sub "setMapping3"___("Sender As QObject, Widget As QWidget");	COMMENT = "";
	Sub "setMapping4"___("Sender As QObject, theObject As QObject");	COMMENT = "";

	Slot "map"___("");	COMMENT = "";
	Slot "map2"___("Sender As QObject");	COMMENT = "";

	Signal "mapped"___("theId As Integer") Declare "void mapped(int i)"	COMMENT = "";
	Signal "mapped2"___("Text As String") Declare "void mapped(const QString & text)"	COMMENT = "";
	Signal "mapped3"___("Widget As QWidget") Declare "void mapped(QWidget * widget)"	COMMENT = "";
	Signal "mapped4"___("theObject As QObject") Declare "void mapped(QObject * object)"	COMMENT = "";

End_Class



Class "QSlider" SuperClass "QAbstractSlider"

	Property "tickInterval" As "Integer";	COMMENT = "";
	Property "tickPosition" As "QSlider.TickPosition";	COMMENT = "";

End_Class



Class "QElapsedTimer"

	Function "elapsed"___("") As "Integer";	COMMENT = "";
	Function "hasExpired"___("Timeout As Integer") As "Boolean";	COMMENT = "";
	Sub "invalidate"___("");	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "msecsSinceReference"___("") As "Integer";	COMMENT = "";
	Function "msecsTo"___("Other As QElapsedTimer") As "Integer";	COMMENT = "";
	Function "restart"___("") As "Integer";	COMMENT = "";
	Function "secsTo"___("Other As QElapsedTimer") As "Integer";	COMMENT = "";
	Sub "start"___("");	COMMENT = "";

End_Class



Class "QSpinBox" SuperClass "QAbstractSpinBox"

	Property "cleanText" As "String";	COMMENT = "";
	Property "maximum" As "Integer";	COMMENT = "";
	Property "minimum" As "Integer";	COMMENT = "";
	Property "prefix" As "String";	COMMENT = "";
	Property "singleStep" As "Integer";	COMMENT = "";
	Property "suffix" As "String";	COMMENT = "";
	Property "value" As "Integer";	COMMENT = "";	

	Sub "setRange"___("Minimum As Integer, Maximum As Integer");	COMMENT = "";
	Function "value"___("") As "Integer";	COMMENT = "";

	Slot "setValue"___("Val As Integer");	COMMENT = "";

	Signal "valueChanged"___("Value As Integer") Declare "void valueChanged(int i)"	COMMENT = "";
	Signal "valueChanged2"___("Text As String") Declare "void	valueChanged(const QString & text)"	COMMENT = "";

End_Class



Class "QSplashScreen" SuperClass "QWidget"

	Sub "finish"___("MainWin As QWidget");	COMMENT = "";
	Function "pixmap"___("") As "QPixmap";	COMMENT = "";
	Sub "repaint"___("");	COMMENT = "";
	Sub "setPixmap"___("Pixmap As QPixmap");	COMMENT = "";

	Slot "clearMessage"___("");	COMMENT = "";
	Slot "showMessage"___("Message As String, Alignment As Integer, Color As QColor");	COMMENT = "";

	Signal "messageChanged"___("Message As String") Declare "void messageChanged(const QString & message)"	COMMENT = "";

End_Class



Class "QSplitter" SuperClass "QFrame"

	Property "childrenCollapsible" As "Boolean";	COMMENT = "";
	Property "handleWidth" As "Integer";	COMMENT = "";
	Property "opaqueResize" As "Boolean";	COMMENT = "";
	Property "orientation" As "Qt.Orientation";	COMMENT = "";

	Sub "addWidget"___("Widget As QWidget");	COMMENT = "";
	Function "count"___("") As "Integer";	COMMENT = "";
	//Sub "getRange"___("Index As Integer, Min As Integer, Max As Integer");	COMMENT = "";
	Function "handle"___("Index As Integer") As "QSplitterHandle";	COMMENT = "";
	Function "indexOf"___("Widget As QWidget") As "Integer";	COMMENT = "";
	Sub "insertWidget"___("Index As Integer, Widget As QWidget");	COMMENT = "";
	Function "isCollapsible"___("Index As Integer") As "Boolean";	COMMENT = "";
	Sub "refresh"___("");	COMMENT = "";
	Function "restoreState"___("State As QByteArray") As "Boolean";	COMMENT = "";
	Function "saveState"___("") As "QByteArray";	COMMENT = "";
	Sub "setCollapsible"___("Index As Integer, Collapse As Boolean");	COMMENT = "";
	Sub "setSizes"___("list As List");	COMMENT = "";
	Sub "setStretchFactor"___("Index As Integer, Stretch As Integer");	COMMENT = "";
	Function "sizes"___("") As "List";	COMMENT = "";
	Function "widget"___("Index As Integer") As "QWidget";	COMMENT = "";

	Signal "splitterMoved"___("Pos As Integer, Index As Integer") Declare "void splitterMoved(int pos, int index)"	COMMENT = "";

End_Class



Class "QWebPage" SuperClass "QObject"

	Property "contentEditable" As "Boolean";	COMMENT = "";
	Property "forwardUnsupportedContent" As "Boolean";	COMMENT = "";
	Property "linkDelegationPolicy" As "QWebPage.LinkDelegationPolicy";	COMMENT = "";
	Property "modified" As "Boolean";	COMMENT = "";
	Property "palette" As "QPalette";	COMMENT = "";
	Property "preferredContentsSize" As "QSize";	COMMENT = "";
	Property "selectedText" As "String";	COMMENT = "";
	Property "viewportSize" As "QSize";	COMMENT = "";

	Function "bytesReceived"___("") As "Integer";	COMMENT = "";
	
	Event "createStandardContextMenu"___("") As "QMenu" Declare "QMenu *createStandardContextMenu ()"	COMMENT = "";
	
	Function "currentFrame"___("") As "QWebFrame";	COMMENT = "";
	Function "findText"___("SubString As String, Options As QWebPage.FindFlags") As "Boolean";	COMMENT = "";
	Function "focusNextPrevChild"___("Next As Boolean") As "Boolean";	COMMENT = "";
	Function "frameAt"___("Pos As QPoint") As "QWebFrame";	COMMENT = "";
	Function "history"___("") As "QWebHistory";	COMMENT = "";
	Function "mainFrame"___("") As "QWebFrame";	COMMENT = "";
	Sub "setView"___("View As QWidget");	COMMENT = "";
	Sub "setViewportSize"___("Size As QSize");	COMMENT = "";
	Function "settings"___("") As "QWebSettings";	COMMENT = "";
	Function "swallowContextMenuEvent"___("Event As QContextMenuEvent") As "Boolean";	COMMENT = "";
	Function "totalBytes"___("") As "Integer";	COMMENT = "";
	Sub "updatePositionDependentActions"___("Pos As QPoint");	COMMENT = "";
	Function "view"___("") As "QWidget";	COMMENT = "";

	Slot "shouldInterruptJavaScript"___("") As "Boolean";	COMMENT = "";

	Signal "contentsChanged"___("") Declare "void contentsChanged()"	COMMENT = "";
	Signal "databaseQuotaExceeded"___("Frame As QWebFrame, DataBaseName As String") Declare "void databaseQuotaExceeded(QWebFrame * frame, QString databaseName)"	COMMENT = "";
	Signal "downloadRequested"___("Resquest As QNetworkRequest") Declare "void downloadRequested(const QNetworkRequest & request)"	COMMENT = "";
	Signal "frameCreated"___("Frame As QWebFrame") Declare "void frameCreated(QWebFrame * frame)"	COMMENT = "";
	Signal "geometryChangeRequested"___("Geom As QRect") Declare "void geometryChangeRequested(const QRect & geom)"	COMMENT = "";
	
	Signal "linkClicked"___("Url As QUrl") Declare "void linkClicked(const QUrl & url)"	COMMENT = "";
	Signal "linkHovered"___("Link As String, Title As String, TextContent As String") Declare "void linkHovered(const QString & link, const QString & title, const QString & textContent)"	COMMENT = "";
	Signal "loadFinished"___("Ok As Boolean") Declare "void loadFinished(bool ok)"	COMMENT = "";
	Signal "loadProgress"___("Progress As Integer") Declare "void loadProgress(int progress)"	COMMENT = "";
	Signal "loadStarted"___("") Declare "void loadStarted()"	COMMENT = "";
	Signal "menuBarVisibilityChangeRequested"___("Visible As Boolean") Declare "void menuBarVisibilityChangeRequested(bool visible)"	COMMENT = "";
	
	Signal "microFocusChanged"___("") Declare "void microFocusChanged()"	COMMENT = "";
	Signal "printRequested"___("Frame As QWebFrame") Declare "void printRequested(QWebFrame * frame)"	COMMENT = "";
	Signal "repaintRequested"___("DirtyRect As QRect") Declare "void repaintRequested(const QRect & dirtyRect)"	COMMENT = "";
	Signal "restoreFrameStateRequested"___("Frame As QWebFrame") Declare "void restoreFrameStateRequested(QWebFrame * frame)"	COMMENT = "";
	Signal "saveFrameStateRequested"___("Frame As QWebFrame, Item As QWebHistoryItem") Declare "void saveFrameStateRequested(QWebFrame * frame, QWebHistoryItem * item)"	COMMENT = "";
	Signal "scrollRequested"___("Dx As Integer, Dy As Integer, RectToScroll As QRect") Declare "void scrollRequested(int dx, int dy, const QRect & rectToScroll)"	COMMENT = "";
	Signal "selectionChanged"___("") Declare "void selectionChanged()"	COMMENT = "";
	Signal "statusBarMessage"___("Text As String") Declare "void statusBarMessage(const QString & text)"	COMMENT = "";
	Signal "statusBarVisibilityChangeRequested"___("Visible As Boolean") Declare "void statusBarVisibilityChangeRequested(bool visible)"	COMMENT = "";
	Signal "toolBarVisibilityChangeRequested"___("Visible As Boolean") Declare "void toolBarVisibilityChangeRequested(bool visible)"	COMMENT = "";
	Signal "unsupportedContent"___("Reply As QNetworkReply") Declare "void unsupportedContent(QNetworkReply * reply)"	COMMENT = "";
	Signal "windowCloseRequested"___("") Declare "void windowCloseRequested()"	COMMENT = "";

End_Class



Class "QGroupBox" SuperClass "QWidget"

	Property "alignment" As "Qt.Alignment";	COMMENT = "";
	Property "checkable" As "Boolean";	COMMENT = "";
	Property "checked" As "Boolean";	COMMENT = "";
	Property "flat" As "Boolean";	COMMENT = "";
	Property "title" As "String";	COMMENT = "";

	Slot "setChecked"___("Checked As Boolean");	COMMENT = "";

	Signal "clicked"___("Checked As Boolean") Declare "void clicked(bool checked = false)"	COMMENT = "";
	Signal "toggled"___("On As Boolean") Declare "void toggled(bool on)"	COMMENT = "";

End_Class




Class "QHostInfo"

	//BN Function "addresses"___("") As "List";	COMMENT = "";
	Function "error"___("") As "QHostInfo.HostInfoError";	COMMENT = "";
	Function "errorString"___("") As "String";	COMMENT = "";
	Function "hostName"___("") As "String";	COMMENT = "";
	Function "lookupId"___("") As "Integer";	COMMENT = "";
	//BN Sub "setAddresses"___("Addresses As List");	COMMENT = "";
	Sub "setError"___("Error As QHostInfo.HostInfoError");	COMMENT = "";
	Sub "setErrorString"___("Str As String");	COMMENT = "";
	Sub "setHostName"___("HostName As String");	COMMENT = "";
	Sub "setLookupId"___("Id As Integer");	COMMENT = "";

End_Class



Class "QListWidget" SuperClass "QListView"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentRow" As "Integer";	COMMENT = "";
	Property "sortingEnabled" As "Boolean";	COMMENT = "";

	Sub "addItem"___("theLabel As String");	COMMENT = "";
	Sub "addItem2"___("Item As QListWidgetItem");	COMMENT = "";
	Sub "addItems"___("Labels As List");	COMMENT = "";
	Sub "closePersistentEditor"___("Item As QListWidgetItem");	COMMENT = "";
	Function "currentItem"___("") As "QListWidgetItem";	COMMENT = "";

	Sub "editItem"___("Item As QListWidgetItem");	COMMENT = "";
	Function "findItems"___("Text As String, Flags As Qt.MatchFlags") As "List";	COMMENT = "";
	Sub "insertItem"___("Row As Integer, Item As QListWidgetItem");	COMMENT = "";
	Sub "insertItem2"___("Row As Integer, theLabel As String");	COMMENT = "";
	Sub "insertItems"___("Row As Integer, Labels As List");	COMMENT = "";

	Function "item"___("Row As Integer") As "QListWidgetItem";	COMMENT = "";
	Function "itemAt"___("P As QPoint") As "QListWidgetItem";	COMMENT = "";
	Function "itemAt2"___("X As Integer, Y As Integer") As "QListWidgetItem";	COMMENT = "";
	Function "itemWidget"___("Item As QListWidgetItem") As "QWidget";	COMMENT = "";

	Sub "openPersistentEditor"___("Item As QListWidgetItem");	COMMENT = "";
	Sub "removeItemWidget"___("Item As QListWidgetItem");	COMMENT = "";
	Function "row"___("Item As QListWidgetItem") As "Integer";	COMMENT = "";
	Function "selectedItems"___("") As "List";	COMMENT = "";

	Sub "setCurrentItem"___("Item As QListWidgetItem");	COMMENT = "";
	Sub "setCurrentItem2"___("Item As QListWidgetItem, Command As QItemSelectionModel.SelectionFlags");	COMMENT = "";
	Sub "setCurrentRow"___("Row As Integer, Command As QItemSelectionModel.SelectionFlags");	COMMENT = "";

	Sub "setItemWidget"___("Item As QListWidgetItem, Widget As QWidget");	COMMENT = "";
	Sub "sortItems"___("Order As Qt.SortOrder");	COMMENT = "";
	Function "takeItem"___("Row As Integer") As "QListWidgetItem";	COMMENT = "";
	Function "visualItemRect"___("Item As QListWidgetItem") As "QRect";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "scrollToItem"___("Item As QListWidgetItem, Hint As QAbstractItemView.ScrollHint");	COMMENT = "";

	Signal "currentItemChanged"___("Current As QListWidgetItem, Previous As QListWidgetItem") Declare "void currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)"	COMMENT = "";
	Signal "currentRowChanged"___("CurrentRow As Integer") Declare "void currentRowChanged(int currentRow)"	COMMENT = "";
	Signal "currentTextChanged"___("CurrentText As String") Declare "void currentTextChanged(const QString & currentText)"	COMMENT = "";
	Signal "itemActivated"___("Item As QListWidgetItem") Declare "void itemActivated(QListWidgetItem * item)"	COMMENT = "";
	Signal "itemChanged"___("Item As QListWidgetItem") Declare "void itemChanged(QListWidgetItem * item)"	COMMENT = "";
	Signal "itemClicked"___("Item As QListWidgetItem") Declare "void itemClicked(QListWidgetItem * item)"	COMMENT = "";
	Signal "itemDoubleClicked"___("Item As QListWidgetItem") Declare "void itemDoubleClicked(QListWidgetItem * item)"	COMMENT = "";
	Signal "itemEntered"___("Item As QListWidgetItem") Declare "void itemEntered(QListWidgetItem * item)"	COMMENT = "";
	Signal "itemPressed"___("Item As QListWidgetItem") Declare "void itemPressed(QListWidgetItem * item)"	COMMENT = "";
	Signal "itemSelectionChanged"___("") Declare "void itemSelectionChanged()"	COMMENT = "";

End_Class




Class "QListWidgetItem"

	Function "background"___("") As "QBrush";	COMMENT = "";
	Function "checkState"___("") As "Qt.CheckState";	COMMENT = "";
	Function "data"___("Role As Integer") As "QVariant";	COMMENT = "";
	Function "flags"___("") As "Qt.ItemFlags";	COMMENT = "";
	Function "font"___("") As "QFont";	COMMENT = "";
	Function "foreground"___("") As "QBrush";	COMMENT = "";
	Function "icon"___("") As "QIcon";	COMMENT = "";
	Function "isHidden"___("") As "Boolean";	COMMENT = "";
	Function "isSelected"___("") As "Boolean";	COMMENT = "";
	Function "listWidget"___("") As "QListWidget";	COMMENT = "";
//	Sub "read"___("In As QDataStream");	COMMENT = "";
	Sub "setBackground"___("Brush As QBrush");	COMMENT = "";
	Sub "setCheckState"___("State As Qt.CheckState");	COMMENT = "";
	Sub "setData"___("Role As Integer, Value As QVariant");	COMMENT = "";
	Sub "setFlags"___("Flags As Qt.ItemFlags");	COMMENT = "";
	Sub "setFont "___("Font As QFont");	COMMENT = "";
	Sub "setForeground"___("Brush As QBrush");	COMMENT = "";
	Sub "setHidden"___("Hide As Boolean");	COMMENT = "";
	Sub "setIcon"___("Icon As QIcon");	COMMENT = "";
	Sub "setSelected"___("Select As Boolean");	COMMENT = "";
	Sub "setSizeHint"___("Size As QSize");	COMMENT = "";
	Sub "setStatusTip"___("StatusTip As String");	COMMENT = "";
	Sub "setText"___("Text As String");	COMMENT = "";
	Sub "setTextAlignment"___("Alignment As Integer");	COMMENT = "";
	Sub "setToolTip"___("Tooltip As String");	COMMENT = "";
	Sub "setWhatsThis"___("WhatsThis As String");	COMMENT = "";
	Function "sizeHint"___("") As "QSize";	COMMENT = "";
	Function "statusTip"___("") As "String";	COMMENT = "";
	Function "text"___("") As "String";	COMMENT = "";
	Function "textAlignment"___("") As "Integer";	COMMENT = "";
	Function "toolTip"___("") As "String";	COMMENT = "";
	Function "type"___("") As "Integer";	COMMENT = "";
	Function "whatsThis"___("") As "String";	COMMENT = "";
//	Sub "write"___("Out As QDataStream");	COMMENT = "";

End_Class




Class "QMovie" SuperClass "QObject"


	Property "cacheMode" As "QMovie.CacheMode";	COMMENT = "";
	Property "speed" As "Integer";	COMMENT = "";

	Function "backgroundColor"___("") As "QColor";	COMMENT = "";
	Function "currentFrameNumber"___("") As "Integer";	COMMENT = "";
	Function "currentImage"___("") As "QImage";	COMMENT = "";
	Function "currentPixmap"___("") As "QPixmap";	COMMENT = "";
	Function "fileName"___("") As "String";	COMMENT = "";
	Function "format"___("") As "QByteArray";	COMMENT = "";
	Function "frameCount"___("") As "Integer";	COMMENT = "";
	Function "frameRect"___("") As "QRect";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "jumpToFrame"___("FrameNumber As Integer") As "Boolean";	COMMENT = "";
	Function "loopCount"___("") As "Integer";	COMMENT = "";
	Function "nextFrameDelay"___("") As "Integer";	COMMENT = "";
	Function "scaledSize"___("") As "QSize";	COMMENT = "";
	Sub "setBackgroundColor"___("Color As QColor");	COMMENT = "";
	Sub "setFileName"___("FileName As String");	COMMENT = "";
	Sub "setFormat"___("Format As QByteArray");	COMMENT = "";
	Sub "setScaledSize"___("Size As QSize");	COMMENT = "";
	Function "state"___("") As "QMovie.MovieState";	COMMENT = "";

	Slot "jumpToNextFrame"___("") As "Boolean";	COMMENT = "";
	Slot "setPaused"___("Paused As Boolean");	COMMENT = "";
	Slot "setSpeed"___("PercentSpeed As Integer");	COMMENT = "";
	Slot "start"___("");	COMMENT = "";
	Slot "stop"___("");	COMMENT = "";

	Signal "error"___("Error As QImageReader.ImageReaderError") Declare "void error(QImageReader.ImageReaderError error)"	COMMENT = "";
	Signal "finished"___("") Declare "void finished()"	COMMENT = "";
	Signal "frameChanged"___("FrameNumber As Integer") Declare "void frameChanged(int frameNumber)"	COMMENT = "";
	Signal "resized"___("Size As QSize") Declare "void resized(const QSize & size)"	COMMENT = "";
	Signal "started"___("") Declare "void started()"	COMMENT = "";
	Signal "stateChanged"___("State As QMovie.MovieState") Declare "void stateChanged(QMovie.MovieState state)"	COMMENT = "";
	Signal "updated"___("Rect As QRect") Declare "void updated(const QRect & rect)"	COMMENT = "";

End_Class




Class "QProgressBar" SuperClass "QWidget"

	Property "alignment" As "Qt.Alignment";	COMMENT = "";
	Property "format" As "String";	COMMENT = "";
	Property "invertedAppearance" As "Boolean";	COMMENT = "";
	Property "maximum" As "Integer";	COMMENT = "";
	Property "minimum" As "Integer";	COMMENT = "";
	Property "orientation" As "Qt.Orientation";	COMMENT = "";
	Property "text" As "String";	COMMENT = "";
	Property "textDirection" As "QProgressBar.Direction";	COMMENT = "";
	Property "textVisible" As "Boolean";	COMMENT = "";
	Property "value" As "Integer";	COMMENT = "";

	Slot "reset"___("");	COMMENT = "";
	Slot "setMaximum"___("Maximum As Integer");	COMMENT = "";
	Slot "setMinimum"___("Minimum As Integer");	COMMENT = "";
	Slot "setOrientation"___("Qt.Orientation");	COMMENT = "";
	Slot "setRange"___("Minimum As Integer, Maximum As Integer");	COMMENT = "";
	Slot "setValue"___("Value As Integer");	COMMENT = "";

	Signal "valueChanged"___("Value As Integer") Declare "void valueChanged(int value)"	COMMENT = "";

End_Class





Class "QPushButton" SuperClass "QAbstractButton"

	Property "autoDefault" As "Boolean";	COMMENT = "";
	Property "default" As "Boolean";	COMMENT = "";
	Property "flat" As "Boolean";	COMMENT = "";

	Function "menu"___("") As "QMenu";	COMMENT = "";
	Sub "setMenu"___("Menu As QMenu");	COMMENT = "";

	Slot "showMenu"___("");	COMMENT = "";

End_Class 




Class "QSyntaxHighlighter" SuperClass "QObject"

	//Property "currentBlockState" As "Integer";	COMMENT = "";

	Function "document"___("") As "QTextDocument";	COMMENT = "";
	Sub "setDocument"___("Doc As QTextDocument");	COMMENT = "";

  //Function "previousBlockState"___("") As "Integer";	COMMENT = "";

	Slot "rehighlight"___("");	COMMENT = "";
	Slot "rehighlightBlock"___("Block As QTextBlock");	COMMENT = "";

  Event "highlightBlock"___("text As String") Declare "void 	highlightBlock ( const QString & text )"   COMMENT = "";

	//Sub "setFormat"___("start As Integer, count As Integer, color As QColor");	COMMENT = "";
	//Sub "setFormat2"___("start As Integer, count As Integer, font As QFont");	COMMENT = "";
	//Sub "setFormat3"___("start As Integer, count As Integer, format As QTextCharFormat");	COMMENT = "";

End_Class



Class "QDial" SuperClass "QAbstractSlider"

	Property "notchSize" As "Integer";	COMMENT = "";
	Property "notchTarget" As "Float";	COMMENT = "";
	Property "notchesVisible" As "Boolean";	COMMENT = "";
	Property "wrapping" As "Boolean";	COMMENT = "";

	Slot "setNotchesVisible"___("Visible As Boolean");	COMMENT = "";
	Slot "setWrapping"___("On As Boolean");	COMMENT = "";

End_Class




Class "QProcess" //SuperClass "QIODevice"

	Sub "closeReadChannel"___("Channel As QProcess.ProcessChannel");	COMMENT = "";
	Sub "closeWriteChannel"___("");	COMMENT = "";
	Function "error"___("") As "QProcess.ProcessError";	COMMENT = "";
	Function "exitCode"___("") As "Integer";	COMMENT = "";
	Function "exitStatus"___("") As "QProcess.ExitStatus";	COMMENT = "";
	//Function "nativeArguments"___("") As "String";	COMMENT = "";
	Function "pid"___("") As "Integer";	COMMENT = "";

	Function "processChannelMode"___("") As "QProcess.ProcessChannelMode";	COMMENT = "";
	Function "processEnvironment"___("") As "QProcessEnvironment";	COMMENT = "";
	Function "readAllStandardError"___("") As "QByteArray";	COMMENT = "";
	Function "readAllStandardOutput"___("") As "QByteArray";	COMMENT = "";
	Function "readChannel"___("") As "QProcess.ProcessChannel";	COMMENT = "";

	//Sub "setNativeArguments"___("Arguments As String");	COMMENT = "";
	Sub "setProcessChannelMode"___("Mode As QProcess.ProcessChannelMode");	COMMENT = "";
	Sub "setProcessEnvironment"___("Environment As QProcessEnvironment");	COMMENT = "";

	Sub "setReadChannel"___("Channel As QProcess.ProcessChannel");	COMMENT = "";
	Sub "setStandardErrorFile"___("FileName As String, Mode As QIODevice.OpenMode");	COMMENT = "";
	Sub "setStandardInputFile"___("FileName As String");	COMMENT = "";
	Sub "setStandardOutputFile"___("FileName As String, Mode As QIODevice.OpenMode");	COMMENT = "";
	Sub "setStandardOutputProcess"___("Destination As QProcess");	COMMENT = "";
	Sub "setWorkingDirectory"___("theDir As String");	COMMENT = "";
	Sub "start"___("Program As String, Arguments As QStringList");	COMMENT = "";
//	Sub "start"___("Program As String, Arguments As List, Mode As QIODevice.OpenMode");	COMMENT = "";
//	Sub "start"___("Program As String, Mode As QIODevice.OpenMode");	COMMENT = "";
	Function "state"___("") As "QProcess.ProcessState";	COMMENT = "";
	Function "waitForFinished"___("Msecs As Integer") As "Boolean";	COMMENT = "";
	Function "waitForStarted"___("Msecs As Integer") As "Boolean";	COMMENT = "";
	Function "workingDirectory"___("") As "String";	COMMENT = "";
	
	Slot "kill"___("");	COMMENT = "";
	Slot "terminate"___("");	COMMENT = "";

	Signal "error"___("Error As QProcess.ProcessError") Declare "void error(QProcess.ProcessError error)"	COMMENT = "";
	Signal "finished"___("") Declare "void finished(int exitCode, QProcess.ExitStatus exitStatus)"	COMMENT = "";
	Signal "readyReadStandardError"___("") Declare "void readyReadStandardError()"	COMMENT = "";
	Signal "readyReadStandardOutput"___("") Declare "void readyReadStandardOutput()"	COMMENT = "";
	Signal "started"___("") Declare "void started()"	COMMENT = "";
	Signal "stateChanged"___("") Declare "void stateChanged(QProcess.ProcessState newState)"	COMMENT = "";

End_Class



Class "QSvgWidget" SuperClass "QWidget"

	Slot "load"___("File As String");	COMMENT = "";
	Slot "load"___("Contents As QByteArray");	COMMENT = "";

End_Class



Class "QTimer" SuperClass "QObject"

	Property "active" As "Boolean";	COMMENT = "";
	Property "interval" As "Integer";	COMMENT = "";
	Property "singleShot" As "Boolean";	COMMENT = "";

	Function "timerId"___("") As "Integer";

	Slot "start"___("");	COMMENT = "";
	Slot "start2"___("Msec As Integer");	COMMENT = "";
	Slot "stop"___("");	COMMENT = "";

	Signal "timeout"___("") Declare "void timeout()"	COMMENT = "";

End_Class




Class "QToolBar" SuperClass "QWidget"

	Property "allowedAreas" As "Qt.ToolBarAreas";	COMMENT = "";
	Property "floatable" As "Boolean";	COMMENT = "";
	Property "floating" As "Boolean";	COMMENT = "";
	Property "iconSize" As "QSize";	COMMENT = "";
	Property "movable" As "Boolean";	COMMENT = "";
	Property "orientation" As "Qt.Orientation";	COMMENT = "";
	Property "toolButtonStyle" As "Qt.ToolButtonStyle";	COMMENT = "";

	Function "actionAt"___("P As QPoint") As "QAction";	COMMENT = "";
	Function "actionAt2"___("X As Integer, Y As Integer") As "QAction";	COMMENT = "";

	Sub "addAction"___("Action As QAction");	COMMENT = "";
	Function "addAction2"___("Text As String") As "QAction";	COMMENT = "";
	Function "addAction3"___("Icon As QIcon, Text As String") As "QAction";	COMMENT = "";
	Function "addAction4"___("Text As String, Receiver As QObject, Member As String") As "QAction";	COMMENT = "";
	Function "addAction5"___("Icon As QIcon, Text As String, Receiver As QObject, Member As String") As "QAction";	COMMENT = "";

	Function "addSeparator"___("") As "QAction";	COMMENT = "";
	Function "addWidget"___("Widget As QWidget") As "QAction";	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";

	Function "insertSeparator"___("Before As QAction") As "QAction";	COMMENT = "";
	Function "insertWidget"___("Before As QAction, Widget As QWidget") As "QAction";	COMMENT = "";
	Function "isAreaAllowed"___("Area As Qt.ToolBarArea") As "Boolean";	COMMENT = "";
	Function "toggleViewAction"___("") As "QAction";	COMMENT = "";
	Function "widgetForAction"___("Action As QAction") As "QWidget";	COMMENT = "";

	Slot "setIconSize"___("IconSize As QSize");	COMMENT = "";
	Slot "setToolButtonStyle"___("ToolButtonStyle As Qt.ToolButtonStyle");	COMMENT = "";

	Signal "actionTriggered"___("Action As QAction") Declare "void actionTriggered(QAction * action)"	COMMENT = "";
	Signal "allowedAreasChanged"___("AllowedAreas As Qt.ToolBarAreas") Declare "void allowedAreasChanged(Qt.ToolBarAreas allowedAreas)"	COMMENT = "";
	Signal "iconSizeChanged"___("IconSize As QSize") Declare "void iconSizeChanged(const QSize & iconSize)"	COMMENT = "";
	Signal "movableChanged"___("Movable As Boolean") Declare "void movableChanged(bool movable)"	COMMENT = "";
	Signal "orientationChanged"___("Orientation As Qt.Orientation") Declare "void orientationChanged(Qt.Orientation orientation)"	COMMENT = "";
	Signal "toolButtonStyleChanged"___("ToolButtonStyle As Qt.ToolButtonStyle") Declare "void toolButtonStyleChanged(Qt.ToolButtonStyle toolButtonStyle)"	COMMENT = "";
	Signal "topLevelChanged"___("TopLevel As Boolean") Declare "void topLevelChanged(bool topLevel)"	COMMENT = "";
	Signal "visibilityChanged"___("Visible As Boolean") Declare "void visibilityChanged(bool visible)"	COMMENT = "";

End_Class




Class "QToolButton" SuperClass "QAbstractButton"

	Property "arrowType" As "Qt.ArrowType";	COMMENT = "";
	Property "autoRaise" As "Boolean";	COMMENT = "";
	Property "popupMode" As "QToolButton.ToolButtonPopupMode";	COMMENT = "";
	Property "toolButtonStyle" As "Qt.ToolButtonStyle";	COMMENT = "";

	Function "defaultAction"___("") As "QAction";	COMMENT = "";
	Function "menu"___("") As "QMenu";	COMMENT = "";
	Sub "setMenu"___("Menu As QMenu");	COMMENT = "";

	Slot "setDefaultAction"___("Action As QAction");	COMMENT = "";
	Slot "setToolButtonStyle"___("Style As Qt.ToolButtonStyle");	COMMENT = "";
	//BN Slot "showMenu"___("");	COMMENT = "";

	Signal "triggered"___("Action As QAction") Declare "void triggered(QAction * action)"	COMMENT = "";

End_Class




Class "QWidget" SuperClass "QObject"

	Property "acceptDrops" As "Boolean";	COMMENT = "";
	Property "accessibleDescription" As "String";	COMMENT = "";
	Property "accessibleName" As "String";	COMMENT = "";
	Property "autoFillBackground" As "Boolean";	COMMENT = "";
	Property "baseSize" As "QSize";	COMMENT = "";
	Property "childrenRect" As "QRect";	COMMENT = "";
	Property "childrenRegion" As "QRegion";	COMMENT = "";
	Property "contextMenuPolicy" As "Qt.ContextMenuPolicy";	COMMENT = "";
	Property "cursor" As "QCursor";	COMMENT = "";
	Property "enabled" As "Boolean";	COMMENT = "";
	Property "focus" As "Boolean";	COMMENT = "";
	Property "focusPolicy" As "Qt.FocusPolicy";	COMMENT = "";
	Property "font" As "QFont";	COMMENT = "";
	Property "frameGeometry" As "QRect";	COMMENT = "";
	Property "frameSize" As "QSize";	COMMENT = "";
	Property "fullScreen" As "Boolean";	COMMENT = "";
	Property "geometry" As "QRect";	COMMENT = "";
	Property "height" As "Integer";	COMMENT = "";
	Property "inputMethodHints" As "Qt.InputMethodHints";	COMMENT = "";
	Property "isActiveWindow" As "Boolean";	COMMENT = "";
	Property "layoutDirection" As "Qt.LayoutDirection";	COMMENT = "";
	Property "locale" As "QLocale";	COMMENT = "";
	Property "maximized" As "Boolean";	COMMENT = "";
	Property "maximumHeight" As "Integer";	COMMENT = "";
	Property "maximumSize" As "QSize";	COMMENT = "";
	Property "maximumWidth" As "Integer";	COMMENT = "";
	Property "minimized" As "Boolean";	COMMENT = "";
	Property "minimumHeight" As "Integer";	COMMENT = "";
	Property "minimumSize" As "QSize";	COMMENT = "";
	Property "minimumSizeHint" As "QSize";	COMMENT = "";
	Property "minimumWidth" As "Integer";	COMMENT = "";
	Property "modal" As "Boolean";	COMMENT = "";
	Property "mouseTracking" As "Boolean";	COMMENT = "";
	Property "normalGeometry" As "QRect";	COMMENT = "";
	Property "palette" As "QPalette";	COMMENT = "";
	Property "pos" As "QPoint";	COMMENT = "";
	Property "rect" As "QRect";	COMMENT = "";
	Property "size" As "QSize";	COMMENT = "";
	Property "sizeHint" As "QSize";	COMMENT = "";
	Property "sizeIncrement" As "QSize";	COMMENT = "";
	Property "sizePolicy" As "QSizePolicy";	COMMENT = "";
	Property "statusTip" As "String";	COMMENT = "";
	Property "styleSheet" As "String";	COMMENT = "";
	Property "toolTip" As "String";	COMMENT = "";
	Property "updatesEnabled" As "Boolean";	COMMENT = "";
	Property "visible" As "Boolean";	COMMENT = "";
	Property "whatsThis" As "String";	COMMENT = "";
	Property "width" As "Integer";	COMMENT = "";
	Property "windowFilePath" As "String";	COMMENT = "";
	Property "windowFlags" As "Qt.WindowFlags";	COMMENT = "";
	Property "windowIcon" As "QIcon";	COMMENT = "";
	Property "windowIconText" As "String";	COMMENT = "";
	Property "windowModality" As "Qt.WindowModality";	COMMENT = "";
	Property "windowModified" As "Boolean";	COMMENT = "";
	Property "windowOpacity" As "Float";	COMMENT = "";
	Property "windowTitle" As "String";	COMMENT = "";
	Property "x" As "Integer";	COMMENT = "";
	Property "y" As "Integer";	COMMENT = "";

	Function "actions"___("") As "List";	COMMENT = "";
	Sub "activateWindow"___("");	COMMENT = "";
	Sub "addAction"___("Action As QAction");	COMMENT = "";
	Sub "addActions"___("Actions As List");	COMMENT = "";
	Sub "adjustSize"___("");	COMMENT = "";
	Function "backgroundRole"___("") As "QPalette.ColorRole";	COMMENT = "";

	Function "childAt"___("X As Integer, Y As Integer") As "QWidget";	COMMENT = "";
	Function "childAt2"___("P As QPoint") As "QWidget";	COMMENT = "";
	Sub "clearFocus"___("");	COMMENT = "";
	Sub "clearMask"___("");	COMMENT = "";
	Function "contentsMargins"___("") As "QMargins";	COMMENT = "";
	Function "contentsRect"___("") As "QRect";	COMMENT = "";
	Sub "ensurePolished"___("");	COMMENT = "";
	Function "focusProxy"___("") As "QWidget";	COMMENT = "";
	Function "focusWidget"___("") As "QWidget";	COMMENT = "";
	Function "fontInfo"___("") As "QFontInfo";	COMMENT = "";
	Function "fontMetrics"___("") As "QFontMetrics";	COMMENT = "";
	Function "foregroundRole"___("") As "QPalette.ColorRole";	COMMENT = "";

	Sub "grabGesture"___("Gesture As Qt.GestureType, Flags As Qt.GestureFlags");	COMMENT = "";
	Sub "grabKeyboard"___("");	COMMENT = "";
	Sub "grabMouse"___("");	COMMENT = "";
	Sub "grabMouse2"___("Cursor As QCursor");	COMMENT = "";
	
  Function "grabShortcut"___("Key As QKeySequence, Context As Qt.ShortcutContext") As "Integer";	COMMENT = "";
	Function "hasFocus"___("") As "Boolean";	COMMENT = "";
	Function "hasMouseTracking"___("") As "Boolean";	COMMENT = "";
	Function "heightForWidth"___("W As Integer") As "Integer";	COMMENT = "";

	Sub "insertAction"___("Before As QAction, Action As QAction");	COMMENT = "";
	Sub "insertActions"___("Before As QAction, Actions As List");	COMMENT = "";
	Function "isAncestorOf"___("Child As QWidget") As "Boolean";	COMMENT = "";
	Function "isEnabledTo"___("Ancestor As QWidget") As "Boolean";	COMMENT = "";
	Function "isHidden"___("") As "Boolean";	COMMENT = "";
	Function "isVisibleTo"___("Ancestor As QWidget") As "Boolean";	COMMENT = "";
	Function "isWindow"___("") As "Boolean";	COMMENT = "";
	Function "isWindowModified"___("") As "Boolean";	COMMENT = "";

	Function "layout"___("") As "QLayout";	COMMENT = "";
	Function "mapFrom"___("Parent As QWidget, Pos As QPoint") As "QPoint";	COMMENT = "";
	Function "mapFromGlobal"___("Pos As QPoint") As "QPoint";	COMMENT = "";
	Function "mapFromParent"___("Pos As QPoint") As "QPoint";	COMMENT = "";
	Function "mapTo"___("Parent As QWidget, Pos As QPoint") As "QPoint";	COMMENT = "";
	Function "mapToGlobal"___("Pos As QPoint") As "QPoint";	COMMENT = "";
	Function "mapToParent"___("Pos As QPoint") As "QPoint";	COMMENT = "";
	Function "mask"___("") As "QRegion";	COMMENT = "";
	Sub "move"___("Point As QPoint");	COMMENT = "";
	Sub "move2"___("X As Integer, Y As Integer");	COMMENT = "";
	Function "nativeParentWidget"___("") As "QWidget";	COMMENT = "";
	Function "nextInFocusChain"___("") As "QWidget";	COMMENT = "";
	Function "normalGeometry"___("") As "QRect";	COMMENT = "";
	Sub "overrideWindowFlags"___("Flags As Qt.WindowFlags");	COMMENT = "";

	Function "palette"___("") As "QPalette";	COMMENT = "";
	Function "parentWidget"___("") As "QWidget";	COMMENT = "";
	Function "pos"___("") As "QPoint";	COMMENT = "";
	Function "previousInFocusChain"___("") As "QWidget";	COMMENT = "";
	Function "rect"___("") As "QRect";	COMMENT = "";
	Sub "releaseKeyboard"___("");	COMMENT = "";
	Sub "releaseMouse"___("");	COMMENT = "";
	Sub "releaseShortcut"___("Id As Integer");	COMMENT = "";
	Sub "removeAction"___("Action As QAction");	COMMENT = "";
	Sub "repaint"___("X As Integer, Y As Integer, W As Integer, H As Integer");	COMMENT = "";
	Sub "repaint2"___("Rect As QRect");	COMMENT = "";
	Sub "repaint3"___("Rgn As QRegion");	COMMENT = "";
	Sub "resize"___("NewSize As QSize");	COMMENT = "";
	Sub "resize2"___("W As Integer, H As Integer");	COMMENT = "";

	Function "restoreGeometry"___("Geometry As QByteArray") As "Boolean";	COMMENT = "";
	Function "saveGeometry"___("") As "QByteArray";	COMMENT = "";
	Sub "scroll"___("Dx As Integer, Dy As Integer");	COMMENT = "";
	Sub "scroll2"___("Dx As Integer, Dy As Integer, R As QRect");	COMMENT = "";

	Sub "setAttribute"___("Attribute As Qt.WidgetAttribute, On As Boolean");	COMMENT = "";
	Sub "setBackgroundRole"___("Role As QPalette.ColorRole");	COMMENT = "";
	Sub "setBaseSize"___("BaseW As Integer, BaseH As Integer");	COMMENT = "";
	Sub "setContentsMargins"___("Left As Integer, Top As Integer, Right As Integer, Bottom As Integer");	COMMENT = "";
	Sub "setContentsMargins2"___("Margins As QMargins");	COMMENT = "";
	Sub "setContextMenuPolicy"___("Policy As Qt.ContextMenuPolicy");	COMMENT = "";
	//Sub "setEditFocus"___("Enable As Boolean");	COMMENT = "";
	Sub "setFixedHeight"___("H As Integer");	COMMENT = "";
	Sub "setFixedSize"___("S As QSize");	COMMENT = "";
	Sub "setFixedSize2"___("W As Integer, H As Integer");	COMMENT = "";
	Sub "setFixedWidth"___("W As Integer");	COMMENT = "";

	Sub "setFocus"___("Reason As Qt.FocusReason");	COMMENT = "";
	Sub "setFocusPolicy"___("Policy As Qt.FocusPolicy");	COMMENT = "";
	Sub "setFocusProxy"___("W As QWidget");	COMMENT = "";
	Sub "setForegroundRole"___("Role As QPalette.ColorRole");	COMMENT = "";
	Sub "setGeometry"___("X As Integer, Y As Integer, W As Integer, H As Integer");	COMMENT = "";

	Sub "setLayout"___("Layout As QLayout");	COMMENT = "";
	Sub "setLayoutDirection"___("Direction As Qt.LayoutDirection");	COMMENT = "";
	Sub "setLocale"___("Locale As QLocale");	COMMENT = "";
	Sub "setMask"___("Bitmap As QBitmap");	COMMENT = "";
	Sub "setMask2"___("Region As QRegion");	COMMENT = "";

	Sub "setMaximumSize"___("MaxW As Integer, MaxH As Integer");	COMMENT = "";
	Sub "setMaximumWidth"___("MaxW As Integer");	COMMENT = "";
	Sub "setMinimumSize"___("MinW As Integer, MinH As Integer");	COMMENT = "";
	Sub "setMinimumWidth"___("MinW As Integer");	COMMENT = "";
	Sub "setParent"___("Parent As QWidget");	COMMENT = "";
	Sub "setParent2"___("Parent As QWidget, Flags As Qt.WindowFlags");	COMMENT = "";
	Sub "setShortcutAutoRepeat"___("Id As Integer, Enable As Boolean");	COMMENT = "";
	Sub "setShortcutEnabled"___("Id As Integer, Enable As Boolean");	COMMENT = "";
	Sub "setSizeIncrement"___("W As Integer, H As Integer");	COMMENT = "";
	Sub "setSizePolicy"___("Horizontal As QSizePolicy.Policy, Vertical As QSizePolicy.Policy");	COMMENT = "";
	
        Sub "setWindowModality"___("WindowModality As Qt.WindowModality");	COMMENT = "";
	Sub "setWindowRole"___("Role As String");	COMMENT = "";
	Sub "setWindowState"___("WindowState As Qt.WindowStates");	COMMENT = "";
	//Sub "setWindowSurface"___("Surface As QWindowSurface");	COMMENT = "";
	//Sub "setupUi"___("Widget As QWidget");	COMMENT = "";
	Function "size"___("") As "QSize";	COMMENT = "";
	Function "sizePolicy"___("") As "QSizePolicy";	COMMENT = "";
	Function "style"___("") As "QStyle";	COMMENT = "";
	Function "testAttribute"___("Attribute As Qt.WidgetAttribute") As "Boolean";	COMMENT = "";
	Function "toolTip"___("") As "String";	COMMENT = "";
	Function "underMouse"___("") As "Boolean";	COMMENT = "";
	Sub "ungrabGesture"___("Gesture As Qt.GestureType");	COMMENT = "";
	Sub "unsetCursor"___("");	COMMENT = "";
	Sub "unsetLayoutDirection"___("");	COMMENT = "";
	Sub "unsetLocale"___("");	COMMENT = "";
	Sub "update"___("X As Integer, Y As Integer, W As Integer, H As Integer");	COMMENT = "";
	Sub "update2"___("Rect As QRect");	COMMENT = "";
	Sub "update3"___("Rgn As QRegion");	COMMENT = "";
	Sub "updateGeometry"___("");	COMMENT = "";

	Function "visibleRegion"___("") As "QRegion";	COMMENT = "";
	Function "window"___("") As "QWidget";	COMMENT = "";
	Function "windowRole"___("") As "String";	COMMENT = "";
	Function "windowState"___("") As "Qt.WindowStates";	COMMENT = "";
	//Function "windowSurface"___("") As "QWindowSurface";	COMMENT = "";
	Function "windowTitle"___("") As "QString";	COMMENT = "";
	Function "windowType"___("") As "Qt.WindowType";	COMMENT = "";

	Slot "close"___("") As "Boolean";	COMMENT = "";
	Slot "hide"___("");	COMMENT = "";
	Slot "lower"___("");	COMMENT = "";
	Slot "raise"___("");	COMMENT = "";
	Slot "repaint"___("");	COMMENT = "";
	Slot "setDisabled"___("Disable As Boolean");	COMMENT = "";
	Slot "setEnabled"___("Enable As Boolean");	COMMENT = "";
	Slot "setFocus"___("");	COMMENT = "";
	Slot "setHidden"___("Hidden As Boolean");	COMMENT = "";
	Slot "setStyleSheet"___("StyleSheet As String");	COMMENT = "";
	Slot "setVisible"___("Visible As Boolean");	COMMENT = "";
	Slot "setWindowModified"___("Modified As Boolean");	COMMENT = "";
	Slot "setWindowTitle"___("Title As String");	COMMENT = "";
	Slot "show"___("");	COMMENT = "";
	Slot "showFullScreen"___("");	COMMENT = "";
	Slot "showMaximized"___("");	COMMENT = "";
	Slot "showMinimized"___("");	COMMENT = "";
	Slot "showNormal"___("");	COMMENT = "";
	Slot "update"___("");	COMMENT = "";

	Signal "customContextMenuRequested"___("Pos As QPoint") Declare "void customContextMenuRequested(const QPoint & pos)"	COMMENT = "";

	Event "actionEvent"___("Event As QActionEvent"); Declare "void actionEvent(QActionEvent * event)"	COMMENT = "";
	Event "changeEvent"___("Event As QEvent"); Declare "void changeEvent(QEvent * event)"	COMMENT = "";
	Event "closeEvent"___("Event As QCloseEvent"); Declare "void closeEvent(QCloseEvent * event)"	COMMENT = "";
	Event "contextMenuEvent"___("Event As QContextMenuEvent"); Declare "void contextMenuEvent(QContextMenuEvent * event)"	COMMENT = "";
	Event "dragEnterEvent"___("Event As QDragEnterEvent"); Declare "void dragEnterEvent(QDragEnterEvent * event)"	COMMENT = "";
	Event "dragLeaveEvent"___("Event As QDragLeaveEvent"); Declare "void dragLeaveEvent(QDragLeaveEvent * event)"	COMMENT = "";
	Event "dragMoveEvent"___("Event As QDragMoveEvent"); Declare "void dragMoveEvent(QDragMoveEvent * event)"	COMMENT = "";
	Event "dropEvent"___("Event As QDropEvent"); Declare "void dropEvent(QDropEvent * event)"	COMMENT = "";
	Event "enterEvent"___("Event As QEvent"); Declare "void enterEvent(QEvent * event)"	COMMENT = "";
	Event "focusInEvent"___("Event As QFocusEvent"); Declare "void focusInEvent(QFocusEvent * event)"	COMMENT = "";
	Event "focusNextChild"___("") As "Boolean"; Declare "bool focusNextChild()"	COMMENT = "";
	
  Event "focusNextPrevChild"___("Next As Boolean") As "Boolean"; Declare "bool focusNextPrevChild(bool next)"	COMMENT = "";
	Event "focusOutEvent"___("Event As QFocusEvent"); Declare "void focusOutEvent(QFocusEvent * event)"	COMMENT = "";
	Event "focusPreviousChild"___("") As "Boolean"; Declare "bool focusPreviousChild()"	COMMENT = "";
	Event "hideEvent"___("Event As QHideEvent"); Declare "void hideEvent(QHideEvent * event)"	COMMENT = "";
	Event "inputMethodEvent"___("Event As QInputMethodEvent"); Declare "void inputMethodEvent(QInputMethodEvent * event)"	COMMENT = "";
	Event "keyPressEvent"___("Event As QKeyEvent"); Declare "void keyPressEvent(QKeyEvent * event)"	COMMENT = "";
	Event "keyReleaseEvent"___("Event As QKeyEvent"); Declare "void keyReleaseEvent(QKeyEvent * event)"	COMMENT = "";
	Event "leaveEvent"___("Event As QEvent"); Declare "void leaveEvent(QEvent * event)"	COMMENT = "";
	Event "mouseDoubleClickEvent"___("Event As QMouseEvent"); Declare "void mouseDoubleClickEvent(QMouseEvent * event)"	COMMENT = "";
	Event "mouseMoveEvent"___("Event As QMouseEvent"); Declare "void mouseMoveEvent(QMouseEvent * event)"	COMMENT = "";
	Event "mousePressEvent"___("Event As QMouseEvent"); Declare "void mousePressEvent(QMouseEvent * event)"	COMMENT = "";
	Event "mouseReleaseEvent"___("Event As QMouseEvent"); Declare "void mouseReleaseEvent(QMouseEvent * event)"	COMMENT = "";
	Event "moveEvent"___("Event As QMoveEvent"); Declare "void moveEvent(QMoveEvent * event)"	COMMENT = "";
	Event "paintEvent"___("Event As QPaintEvent"); Declare "void paintEvent(QPaintEvent * event)"	COMMENT = "";
	Event "resizeEvent"___("Event As QResizeEvent"); Declare "void resizeEvent(QResizeEvent * event)"	COMMENT = "";
	Event "showEvent"___("Event As QShowEvent"); Declare "void showEvent(QShowEvent * event)"	COMMENT = "";
	Event "tabletEvent"___("Event As QTabletEvent"); Declare "void tabletEvent(QTabletEvent * event)"	COMMENT = "";
	Event "wheelEvent"___("Event As QWheelEvent"); Declare "void wheelEvent(QWheelEvent * event)"	COMMENT = "";

End_Class



Class "QString"

	Function "append"___("Str As String") As "String";	COMMENT = "";
	Function "append2"___("Ch As QChar") As "String";	COMMENT = "";
	Function "arg"___("A As String, FieldWidth As Integer, FillChar As QChar") As "String";	COMMENT = "";
	Function "arg2"___("A As Integer, FieldWidth As Integer, Base As Integer, FillChar As QChar") As "String";	COMMENT = "";
	Function "arg3"___("A As QChar, FieldWidth As Integer, FillChar As QChar") As "String";	COMMENT = "";
	Function "arg4"___("A As Float, FieldWidth As Integer, Format As String, Precision As Integer, FillChar As QChar") As "String";	COMMENT = "";
	Function "at"___("Position As Integer") As "QChar";	COMMENT = "";
	Function "capacity"___("") As "Integer";	COMMENT = "";
	Sub "chop"___("N As Integer");	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";
	Function "compare"___("Other As String") As "Integer";	COMMENT = "";
	Function "compare2"___("Other As String, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "contains"___("Str As String, Cs As Qt.CaseSensitivity") As "Boolean";	COMMENT = "";
	Function "contains2"___("Ch As QChar, Cs As Qt.CaseSensitivity") As "Boolean";	COMMENT = "";
	Function "contains3 "___("Rx As QRegExp") As "Boolean";	COMMENT = "";

	Function "count"___("Str As String, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "count2"___("Ch As QChar, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "count3"___("Rx As QRegExp") As "Integer";	COMMENT = "";
	Function "count4"___("") As "Integer";	COMMENT = "";
	Function "endsWith"___("S As String, Cs As Qt.CaseSensitivity") As "Boolean";	COMMENT = "";
	Function "endsWith2"___("C As QChar, Cs As Qt.CaseSensitivity") As "Boolean";	COMMENT = "";
	Function "fill"___("Ch As QChar, Size As Integer") As "String";	COMMENT = "";

	Function "indexOf"___("Str As String, From As Integer, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "indexOf2"___("Ch As QChar, From As Integer, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "indexOf3"___("Rx As QRegExp, From As Integer") As "Integer";	COMMENT = "";
	Function "insert"___("Position As Integer, Str As String") As "String";	COMMENT = "";
	Function "insert2"___("Position As Integer, Ch As QChar") As "String";	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isRightToLeft"___("") As "Boolean";	COMMENT = "";
	Function "lastIndexOf"___("Str As String, From As Integer, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "lastIndexOf2"___("Ch As QChar, From As Integer, Cs As Qt.CaseSensitivity") As "Integer";	COMMENT = "";
	Function "lastIndexOf3"___("Rx As QRegExp, From As Integer") As "Integer";	COMMENT = "";
	Function "left"___("N As Integer") As "String";	COMMENT = "";
	Function "leftJustified"___("Width As Integer, Fill As QChar, Truncate As Boolean") As "String";	COMMENT = "";
	Function "length"___("") As "Integer";	COMMENT = "";
	Function "localeAwareCompare"___("Other As String") As "Integer";	COMMENT = "";
	Function "mid"___("Position As Integer, N As Integer") As "String";	COMMENT = "";
	Function "normalized"___("Mode As QString.NormalizationForm") As "String";	COMMENT = "";
	Function "normalized2"___("Mode As QString.NormalizationForm, Version As QChar.UnicodeVersion") As "String";	COMMENT = "";
	Function "prepend"___("Str As String") As "String";	COMMENT = "";
	Function "prepend2"___("Ch As QChar") As "String";	COMMENT = "";

	Sub "push_back"___("Other As String");	COMMENT = "";
	Sub "push_back2"___("Ch As QChar");	COMMENT = "";
	Sub "push_front"___("Other As String");	COMMENT = "";
	Sub "push_front2"___("Ch As QChar");	COMMENT = "";
	Function "remove"___("Position As Integer, N As Integer") As "String";	COMMENT = "";
	Function "remove2"___("Ch As QChar, Cs As Qt.CaseSensitivity") As "String";	COMMENT = "";
	Function "remove3"___("Str As String, Cs As Qt.CaseSensitivity") As "String";	COMMENT = "";
	Function "remove4"___("Rx As QRegExp") As "String";	COMMENT = "";
	Function "repeated"___("Times As Integer") As "String";	COMMENT = "";

	Function "replace"___("Position As Integer, N As Integer, After As String") As "String";	COMMENT = "";
	Function "replace2"___("Position As Integer, N As Integer, After As QChar") As "String";	COMMENT = "";
	Function "replace3"___("Before As String, After As String, Cs As Qt.CaseSensitivity") As "String";	COMMENT = "";
	Function "replace4"___("Before As QChar, After As String, Qt.CaseSensitivity") As "String";	COMMENT = "";
	Function "replace5"___("Before As QChar, After As QChar, Cs As Qt.CaseSensitivity") As "String";	COMMENT = "";
	Function "replace6"___("Rx As QRegExp, After As String") As "String";	COMMENT = "";

	Sub "reserve"___("Size As Integer");	COMMENT = "";
	Sub "resize"___("Size As Integer");	COMMENT = "";
	Function "right"___("N As Integer") As "String";	COMMENT = "";
	Function "rightJustified"___("Width As Integer, Fill As QChar, Truncate As Boolean") As "String";	COMMENT = "";
	//Function "rightRef"___("N As Integer") As "QStringRef";	COMMENT = "";
	Function "section"___("Sep As QChar, Start As Integer, End As Integer, Flags As QString.SectionFlags") As "String";	COMMENT = "";
	Function "section2"___("Sep As String, Start As Integer, End As Integer, Flags As QString.SectionFlags") As "String";	COMMENT = "";
	Function "section3"___("Reg As QRegExp, Start As Integer, End As Integer, Flags As QString.SectionFlags") As "String";	COMMENT = "";
	Function "setNum"___("N As Integer, Base As Integer") As "String";	COMMENT = "";
	Function "setNum2"___("N As Float, Format As String, Precision As Integer") As "String";	COMMENT = "";
	Function "simplified"___("") As "String";	COMMENT = "";
	Function "size"___("") As "Integer";	COMMENT = "";
	Function "split"___("Sep As String, Behavior As QString.SplitBehavior, Cs As Qt.CaseSensitivity") As "QStringList";	COMMENT = "";
	Function "split2"___("Sep As QChar, Behavior As QString.SplitBehavior, Cs As Qt.CaseSensitivity") As "QStringList";	COMMENT = "";
	Function "split3"___("Rx As QRegExp, Behavior As QString.SplitBehavior") As "QStringList";	COMMENT = "";
	Sub "squeeze"___("");	COMMENT = "";
	Function "startsWith"___("S As String, Cs As Qt.CaseSensitivity") As "Boolean";	COMMENT = "";
	Function "startsWith2"___("C As QChar, Cs As Qt.CaseSensitivity") As "Boolean";	COMMENT = "";

	Function "toLatin1"___("") As "QByteArray";	COMMENT = "";
	Function "toCaseFolded"___("") As "String";	COMMENT = "";
	Function "toDouble"___("Ok As Boolean") As "Float";	COMMENT = "";
	Function "toInt"___("Ok As Boolean, Base As Integer") As "Integer";	COMMENT = "";
	Function "toLatin1"___("") As "QByteArray";	COMMENT = "";
	Function "toLocal8Bit"___("") As "QByteArray";	COMMENT = "";
	Function "toLongLong"___("Ok As Boolean, Base As Integer") As "Integer";	COMMENT = "";
	Function "toLower"___("") As "String";	COMMENT = "";
	Function "toUpper"___("") As "String";	COMMENT = "";
	Function "toUtf8"___("") As "QByteArray";	COMMENT = "";
	Function "trimmed"___("") As "String";	COMMENT = "";
	Sub "truncate"___("Position As Integer");	COMMENT = "";

End_Class



Class "QTreeWidget" SuperClass "QTreeView"

	Property "columnCount" As "Integer";	COMMENT = "";
	Property "topLevelItemCount" As "Integer";	COMMENT = "";

	Sub "addTopLevelItem"___("Item As QTreeWidgetItem");	COMMENT = "";
	Sub "addTopLevelItems"___("Items As List");	COMMENT = "";
	Sub "closePersistentEditor"___("Item As QTreeWidgetItem, Column As Integer");	COMMENT = "";
	Function "currentColumn"___("") As "Integer";	COMMENT = "";
	Function "currentItem"___("") As "QTreeWidgetItem";	COMMENT = "";

	Sub "editItem"___("Item As QTreeWidgetItem, Column As Integer");	COMMENT = "";
	Function "findItems"___("Text As String, Flags As Qt.MatchFlags, Column As Integer") As "List";	COMMENT = "";
	Function "headerItem"___("") As "QTreeWidgetItem";	COMMENT = "";
	Function "indexOfTopLevelItem"___("Item As QTreeWidgetItem") As "Integer";	COMMENT = "";
	Sub "insertTopLevelItem"___("Index As Integer, Item As QTreeWidgetItem");	COMMENT = "";
	Sub "insertTopLevelItems"___("Index As Integer, Items As List");	COMMENT = "";
	Function "invisibleRootItem"___("") As "QTreeWidgetItem";	COMMENT = "";
	Function "isFirstItemColumnSpanned"___("Item As QTreeWidgetItem") As "Boolean";	COMMENT = "";
	Function "itemAbove"___("Item As QTreeWidgetItem") As "QTreeWidgetItem";	COMMENT = "";
	Function "itemAt"___("P As QPoint") As "QTreeWidgetItem";	COMMENT = "";
	Function "itemAt2"___("X As Integer, Y As Integer") As "QTreeWidgetItem";	COMMENT = "";
	Function "itemBelow"___("Item As QTreeWidgetItem") As "QTreeWidgetItem";	COMMENT = "";
	Function "itemWidget"___("Item As QTreeWidgetItem, Column As Integer") As "QWidget";	COMMENT = "";
	Sub "openPersistentEditor"___("Item As QTreeWidgetItem, Column As Integer");	COMMENT = "";
	Sub "removeItemWidget "___("Item As QTreeWidgetItem, Column As Integer");	COMMENT = "";
	Function "selectedItems"___("") As "List";	COMMENT = "";

	Sub "setCurrentItem"___("Item As QTreeWidgetItem");	COMMENT = "";
	Sub "setCurrentItem2"___("Item As QTreeWidgetItem, Column As Integer");	COMMENT = "";
	Sub "setCurrentItem3"___("Item As QTreeWidgetItem, Column As Integer, Command As QItemSelectionModel.SelectionFlags");	COMMENT = "";
	Sub "setFirstItemColumnSpanned"___("Item As QTreeWidgetItem, Span As Boolean");	COMMENT = "";
	Sub "setHeaderItem"___("Item As QTreeWidgetItem");	COMMENT = "";
	Sub "setHeaderLabel"___("Label As String");	COMMENT = "";
	Sub "setHeaderLabels"___("Labels As List");	COMMENT = "";
	Sub "setItemWidget"___("Iteam As QTreeWidgetItem, Column As Integer, Widget As QWidget");	COMMENT = "";
	Function "sortColumn"___("") As "Integer";	COMMENT = "";

	Sub "sortItems"___("Column As Integer, Order As Qt.SortOrder");	COMMENT = "";
	Function "takeTopLevelItem"___("Index As Integer") As "QTreeWidgetItem";	COMMENT = "";
	Function "topLevelItem"___("Index As Integer") As "QTreeWidgetItem";	COMMENT = "";
	Function "visualItemRect"___("Item As QTreeWidgetItem") As "QRect";	COMMENT = "";

	Slot "clear"___("");	COMMENT = "";
	Slot "collapseItem"___("Item As QTreeWidgetItem");	COMMENT = "";
	Slot "expandItem"___("Item As QTreeWidgetItem");	COMMENT = "";
	Slot "scrollToItem"___("Item As QTreeWidgetItem, Hint As QAbstractItemView.ScrollHint");	COMMENT = "";

	//Signal "currentItemChanged2"___("Current As QTreeWidgetItem, Previous As QTreeWidgetItem") Declare "void currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)"	COMMENT = "";	
	//Signal "itemActivated2"___("Item As QTreeWidgetItem, Column As Integer") Declare "void itemActivated(QTreeWidgetItem * item, int column)"	COMMENT = "";	
	//Signal "itemChanged2"___("Item As QTreeWidgetItem, Column As Integer") Declare "void itemChanged(QTreeWidgetItem * item, int column)"	COMMENT = "";	
	//Signal "itemClicked2"___("Item As QTreeWidgetItem, Column As Integer") Declare "void itemClicked(QTreeWidgetItem * item, int column)"	COMMENT = "";	
	//Signal "itemCollapsed2"___("Item As QTreeWidgetItem") Declare "void itemCollapsed(QTreeWidgetItem * item)"	COMMENT = "";	
//	Signal "itemDoubleClicked2"___("Item As QTreeWidgetItem, Column As Integer") Declare "void itemDoubleClicked(QTreeWidgetItem * item, int column)"	COMMENT = "";	
//	Signal "itemEntered2"___("Item As QTreeWidgetItem, Column As Integer") Declare "void itemEntered(QTreeWidgetItem * item, int column)"	COMMENT = "";	
//	Signal "itemExpanded2"___("Item As QTreeWidgetItem") Declare "void itemExpanded(QTreeWidgetItem * item)"	COMMENT = "";	
//	Signal "itemPressed2"___("Item As QTreeWidgetItem, Column As Integer") Declare "void itemPressed(QTreeWidgetItem * item, int column)"	COMMENT = "";	
//	Signal "itemSelectionChanged"___("") Declare "void itemSelectionChanged()"	COMMENT = "";	

End_Class



Class "QLocale"

	Function "amText"___("") As "String";	COMMENT = "";
	Function "bcp47Name"___("") As "String";	COMMENT = "";
	Function "country"___("") As "QLocale.Country";	COMMENT = "";
	Function "createSeparatedList"___("ItemList As List") As "String";	COMMENT = "";
	Function "currencySymbol"___("Format As QLocale.CurrencySymbolFormat") As "String";	COMMENT = "";
	Function "dateFormat"___("Format As QLocale.FormatType") As "String";	COMMENT = "";
	Function "dateTimeFormat"___("Format As QLocale.FormatType") As "String";	COMMENT = "";
	Function "dayName"___("Day As Integer, Type As QLocale.FormatType") As "String";	COMMENT = "";
	Function "decimalPoint"___("") As "QChar";	COMMENT = "";
	Function "exponential"___("") As "QChar";	COMMENT = "";
	Function "firstDayOfWeek"___("") As "Qt.DayOfWeek";	COMMENT = "";
	Function "groupSeparator"___("") As "QChar";	COMMENT = "";
	Function "language"___("") As "QLocale.Language";	COMMENT = "";
	Function "measurementSystem"___("") As "QLocale.MeasurementSystem";	COMMENT = "";
	Function "monthName"___("Month As Integer, Type As QLocale.FormatType") As "String";	COMMENT = "";
	Function "name"___("") As "String";	COMMENT = "";
	Function "nativeCountryName"___("") As "String";	COMMENT = "";
	Function "nativeLanguageName"___("") As "String";	COMMENT = "";
	Function "negativeSign"___("") As "QChar";	COMMENT = "";

	Function "numberOptions"___("") As "QLocale.NumberOptions";	COMMENT = "";
	Function "percent"___("") As "QChar";	COMMENT = "";
	Function "pmText"___("") As "String";	COMMENT = "";
	Function "positiveSign"___("") As "QChar";	COMMENT = "";
	Function "quoteString"___("Str As String, Style As QLocale.QuotationStyle") As "String";	COMMENT = "";
	Function "script"___("") As "QLocale.Script";	COMMENT = "";
	Sub "setNumberOptions"___("Options As QLocale.NumberOptions");	COMMENT = "";
	Function "standaloneDayName"___("Day As Integer, Type As QLocale.FormatType") As "String";	COMMENT = "";
	Function "standaloneMonthName"___("Month As Integer, Type As QLocale.FormatType") As "String";	COMMENT = "";
	Function "textDirection"___("") As "Qt.LayoutDirection";	COMMENT = "";
	Function "timeFormat"___("Format As QLocale.FormatType") As "String";	COMMENT = "";
	Function "toCurrencyString"___("Value As Integer, Symbol As String") As "String";	COMMENT = "";
	Function "toCurrencyString2"___("Value As Float, Symbol As String") As "String";	COMMENT = "";
	Function "toDate"___("DateString As String, Format As QLocale.FormatType") As "QDate";	COMMENT = "";
	Function "toDate2"___("DateString As String, Format As String") As "QDate";	COMMENT = "";
	Function "toDateTime"___("DateString As String, Format As QLocale.FormatType") As "QDateTime";	COMMENT = "";
	Function "toDateTime2"___("DateString As String, Format As String") As "QDateTime";	COMMENT = "";
	Function "toDouble"___("S As String, Ok As Boolean") As "Float";	COMMENT = "";
	Function "toLongLong"___("S As String, Ok As Boolean, Base As Integer") As "Integer";	COMMENT = "";
	Function "toLower"___("Str As String") As "String";	COMMENT = "";

	Function "toString"___("I As Integer") As "String";	COMMENT = "";
	Function "toString2"___("Date As QDate, Format As String") As "String";	COMMENT = "";
	Function "toString3"___("Date As QDate, Format As QLocale.FormatType") As "String";	COMMENT = "";
	Function "toString4"___("Time As QTime, Format As String") As "String";	COMMENT = "";
	Function "toString5"___("Time As QTime, Format As QLocale.FormatType") As "String";	COMMENT = "";
	Function "toString6"___("DateTime As QDateTime, Format As QLocale.FormatType") As "String";	COMMENT = "";
	Function "toString7"___("DateTime As QDateTime, Format As String") As "String";	COMMENT = "";
	Function "toString8"___("I As Double, F As String, Prec As Integer") As "String";	COMMENT = "";
	Function "toTime"___("TimeString As String, Format As QLocale.FormatType") As "QTime";	COMMENT = "";
	Function "toTime"___("TimeString As String, Format As String") As "String";	COMMENT = "";
	Function "toUpper"___("Str As String") As "String";	COMMENT = "";
	Function "uiLanguages"___("") As "List";	COMMENT = "";
	Function "weekdays"___("") As "List";	COMMENT = "";
	Function "zeroDigit"___("") As "QChar";	COMMENT = "";

End_Class



Class "QProcessEnvironment"

	Sub "clear"___("");	COMMENT = "";
	Function "contains"___("Name As String") As "Boolean";	COMMENT = "";
	Sub "insert"___("Name As String, Value As String");	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "keys"___("") As "List";	COMMENT = "";
	Sub "remove"___("Name As String");	COMMENT = "";
	Function "toStringList"___("") As "QStringList";	COMMENT = "";
	Function "value"___("Name As String, DefaultValue As String") As "String";	COMMENT = "";

End_Class



Class "QProgressDialog" SuperClass "QDialog"

	Property "autoClose" As "Boolean";	COMMENT = "";
	Property "autoReset" As "Boolean";	COMMENT = "";
	Property "labelText" As "String";	COMMENT = "";
	Property "maximum" As "Integer";	COMMENT = "";
	Property "minimum" As "Integer";	COMMENT = "";
	Property "minimumDuration" As "Integer";	COMMENT = "";
	Property "value" As "Integer";	COMMENT = "";
	Property "wasCanceled" As "Boolean";	COMMENT = "";

	Sub "open"___("Receiver As QObject, Member As String");	COMMENT = "";
	Sub "setBar"___("Bar As QProgressBar");	COMMENT = "";
	Sub "setCancelButton"___("CancelButton As QPushButton");	COMMENT = "";
	Sub "setLabel"___("Label As QLabel");	COMMENT = "";

	Slot "cancel"___("");	COMMENT = "";
	Slot "reset"___("");	COMMENT = "";
	Slot "setCancelButtonText"___("CancelButtonText As String");	COMMENT = "";
	Slot "setLabelText"___("Text As String");	COMMENT = "";
	Slot "setMaximum"___("Maximum As Integer");	COMMENT = "";
	Slot "setMinimum"___("Minimum As Integer");	COMMENT = "";
	Slot "setMinimumDuration"___("Ms As Integer");	COMMENT = "";
	Slot "setRange"___("Minimum As Integer, Maximum As Integer");	COMMENT = "";
	Slot "setValue"___("Progress As Integer");	COMMENT = "";

	Signal "canceled"___("") Declare "void canceled()"	COMMENT = "";

End_Class



Class "QTime"

	Function "addMSecs"___("Ms As Integer") As "QTime";	COMMENT = "";
	Function "addSecs"___("S As Integer") As "QTime";	COMMENT = "";
	Function "elapsed"___("") As "Integer";	COMMENT = "";
	Function "hour"___("") As "Integer";	COMMENT = "";
	Function "isNull"___("") As "Boolean";	COMMENT = "";
	Function "isValid"___("") As "Boolean";	COMMENT = "";
	Function "minute"___("") As "Integer";	COMMENT = "";
	Function "msec"___("") As "Integer";	COMMENT = "";
	Function "msecsTo"___("T As QTime") As "Integer";	COMMENT = "";
	Function "restart"___("") As "Integer";	COMMENT = "";
	Function "second"___("") As "Integer";	COMMENT = "";
	Function "secsTo"___("T As QTime") As "Integer";	COMMENT = "";
	Function "setHMS"___("H As Integer, M As Integer, S As Integer, Ms As Integer") As "Boolean";	COMMENT = "";
	Sub "start"___("");	COMMENT = "";
	Function "toString"___("Format As String") As "String";	COMMENT = "";

End_Class



Class "QDockWidget" SuperClass "QWidget"

	Property "allowedAreas" As "Qt.DockWidgetAreas";	COMMENT = "";
	Property "features" As "QDockWidget.DockWidgetFeatures";	COMMENT = "";
	Property "floating" As "Boolean";	COMMENT = "";
	Property "windowTitle" As "String";	COMMENT = "";

	Function "isAreaAllowed"___("Area As Qt.DockWidgetArea") As "Boolean";	COMMENT = "";
	Sub "setFeatures"___("Features As QDockWidget.DockWidgetFeatures");	COMMENT = "";
	Sub "setTitleBarWidget"___("Widget As QWidget");	COMMENT = "";
	Sub "setWidget"___("Widget As QWidget");	COMMENT = "";
	Function "titleBarWidget"___("") As "QWidget";	COMMENT = "";
	Function "toggleViewAction"___("") As "QAction";	COMMENT = "";
	Function "widget"___("") As "QWidget";	COMMENT = "";

	Signal "allowedAreasChanged"___("AllowedAreas As Qt.DockWidgetAreas") Declare "void allowedAreasChanged(Qt.DockWidgetAreas allowedAreas)"	COMMENT = "";
	Signal "dockLocationChanged"___("Area As Qt.DockWidgetArea") Declare "void dockLocationChanged(Qt.DockWidgetArea area)"	COMMENT = "";
	Signal "featuresChanged"___("Features As QDockWidget.DockWidgetFeatures") Declare "void featuresChanged(QDockWidget.DockWidgetFeatures features)"	COMMENT = "";
	Signal "topLevelChanged"___("TopLevel As Boolean") Declare "void topLevelChanged(bool topLevel)"	COMMENT = "";
	Signal "visibilityChanged"___("Visible As Boolean") Declare "void visibilityChanged(bool visible)"	COMMENT = "";

End_Class



Class "QStatusBar" SuperClass "QWidget"

	Property "sizeGripEnabled" As "Boolean";	COMMENT = "";

	Sub "addPermanentWidget"___("Widget As QWidget, Stretch As Integer");	COMMENT = "";
	Sub "addWidget"___("Widget As QWidget, Stretch As Integer");	COMMENT = "";
	Function "currentMessage"___("") As "String";	COMMENT = "";
	Function "insertPermanentWidget"___("Index As Integer, Widget As QWidget, Stretch As Integer") As "Integer";	COMMENT = "";
	Function "insertWidget"___("Index As Integer, Widget As QWidget, Stretch As Integer") As "Integer";	COMMENT = "";
	Sub "removeWidget"___("Widget As QWidget");	COMMENT = "";

	Slot "clearMessage"___("");	COMMENT = "";
	Slot "showMessage"___("Message As String, Timeout As Integer");	COMMENT = "";

	Signal "messageChanged"___("Message As String") Declare "void messageChanged(const QString & message)"	COMMENT = "";

End_Class



Class "QThread" SuperClass "QObject"

	Sub "exit"___("ReturnCode As Integer");	COMMENT = "";
	Function "isFinished"___("") As "Boolean";	COMMENT = "";
	Function "isRunning"___("") As "Boolean";	COMMENT = "";
	Function "priority"___("") As "QThread.Priority";	COMMENT = "";
	Sub "setPriority"___("Priority As QThread.Priority");	COMMENT = "";
	Sub "setStackSize"___("StackSize As Integer");	COMMENT = "";
	Function "stackSize"___("") As "Integer";	COMMENT = "";
	Function "wait"___("Time As Integer") As "Boolean";	COMMENT = "";

	Slot "quit"___("");	COMMENT = "";
	Slot "start"___("Priority As QThread.Priority");	COMMENT = "";
	Slot "terminate"___("");	COMMENT = "";

  Event "run"___("") As "void run()";	COMMENT = "";

	Signal "finished"___("") Declare "void finished()"	COMMENT = "";
	Signal "started"___("") Declare "void started()"	COMMENT = "";
	Signal "terminated"___("") Declare "void terminated()"	COMMENT = "";

End_Class



Class "QToolBox" SuperClass "QFrame"

	Property "count" As "Integer";	COMMENT = "";
	Property "currentIndex" As "Integer";	COMMENT = "";

	Function "addItem"___("Widget As QWidget, IconSet As QIcon, Text As String") As "Integer";	COMMENT = "";
	Function "addItem2"___("W As QWidget, Text As String") As "Integer";	COMMENT = "";
	Function "currentWidget"___("") As "QWidget";	COMMENT = "";
	Function "indexOf"___("Widget As QWidget") As "Integer";	COMMENT = "";
	Function "insertItem"___("Index As Integer, Widget As QWidget, Icon As QIcon, Text As String") As "Integer";	COMMENT = "";
	Function "insertItem2"___("Index As Integer, Widget As QWidget, Text As String") As "Integer";	COMMENT = "";
	Function "isItemEnabled"___("Index As Integer") As "Boolean";	COMMENT = "";
	Function "itemIcon"___("Index As Integer") As "QIcon";	COMMENT = "";
	Function "itemText"___("Index As Integer") As "String";	COMMENT = "";
	Function "itemToolTip"___("Index As Integer") As "String";	COMMENT = "";
	Sub "removeItem"___("Index As Integer");	COMMENT = "";
	Sub "setItemEnabled"___("Index As Integer, Enabled As Boolean");	COMMENT = "";
	Sub "setItemIcon"___("Index As Integer, Icon As QIcon");	COMMENT = "";
	Sub "setItemText"___("Index As Integer, Text As String");	COMMENT = "";
	Sub "setItemToolTip"___("Index As Integer, ToolTip As String");	COMMENT = "";
	Function "widget"___("Index As Integer") As "QWidget";	COMMENT = "";

	Slot "setCurrentIndex"___("Index As Integer");	COMMENT = "";
	Slot "setCurrentWidget"___("Widget As QWidget");	COMMENT = "";

	Signal "currentChanged"___("Index As Integer") Declare "void currentChanged(int index)"	COMMENT = "";

End_Class



Class "QTextDocument" SuperClass "QObject"

	Property "blockCount" As "Integer";	COMMENT = "";
	Property "defaultFont" As "QFont";	COMMENT = "";
	Property "defaultStyleSheet" As "String";	COMMENT = "";
	Property "defaultTextOption" As "QTextOption";	COMMENT = "";
	Property "documentMargin" As "Float";	COMMENT = "";
	Property "indentWidth" As "Float";	COMMENT = "";
	Property "maximumBlockCount" As "Integer";	COMMENT = "";
	Property "modified" As "Boolean";	COMMENT = "";
	Property "pageSize" As "QSizeF";	COMMENT = "";
	Property "size" As "QSizeF";	COMMENT = "";
	Property "textWidth" As "Float";	COMMENT = "";
	Property "undoRedoEnabled" As "Boolean";	COMMENT = "";
	Property "useDesignMetrics" As "Boolean";	COMMENT = "";

	Sub "addResource"___("theType As Integer, Name As QUrl, Resource As QVariant");	COMMENT = "";
	Sub "adjustSize"___("");	COMMENT = "";
	Function "availableRedoSteps"___("") As "Integer";	COMMENT = "";
	Function "availableUndoSteps"___("") As "Integer";	COMMENT = "";
	Function "begin"___("") As "QTextBlock";	COMMENT = "";
	Function "characterAt"___("Pos As Integer") As "QChar";	COMMENT = "";
	Function "characterCount"___("") As "Integer";	COMMENT = "";
	Sub "clear"___("");	COMMENT = "";
	Function "defaultCursorMoveStyle"___("") As "Qt::CursorMoveStyle";	COMMENT = "";

	Function "documentLayout"___("") As "QAbstractTextDocumentLayout";	COMMENT = "";
	//Sub "drawContents"___("P as QPainter, Rect As QRectF");	COMMENT = "";
	Function "end"___("") As "QTextBlock";	COMMENT = "";
	Function "find"___("SubString As String, Cursor As QTextCursor, Options As QTextDocument::FindFlags") As "QTextCursor";	COMMENT = "";
	Function "find2"___("Expr As QRegExp, Cursor As QTextCursor, Options As QTextDocument::FindFlags") As "QTextCursor";	COMMENT = "";
	Function "find3"___("SubString As String, Position As Integer, Options As QTextDocument::FindFlags") As "QTextCursor";	COMMENT = "";
	Function "find4"___("Expr As QRegExp, Position As Integer, Options As QTextDocument::FindFlags") As "QTextCursor";	COMMENT = "";
	
  Function "findBlock"___("Pos As Integer") As "QTextBlock";	COMMENT = "";
	Function "findBlockByLineNumber"___("LineNumber As Integer") As "QTextBlock";	COMMENT = "";
	Function "findBlockByNumber"___("BlockNumber As Integer") As "QTextBlock";	COMMENT = "";
	Function "firstBlock"___("") As "QTextBlock";	COMMENT = "";
	Function "idealWidth"___("") As "Float";	COMMENT = "";
	Function "isEmpty"___("") As "Boolean";	COMMENT = "";
	Function "isRedoAvailable"___("") As "Boolean";	COMMENT = "";
	Function "isUndoAvailable"___("") As "Boolean";	COMMENT = "";

	Function "lastBlock"___("") As "QTextBlock";	COMMENT = "";
	Function "lineCount"___("") As "Integer";	COMMENT = "";
	Sub "markContentsDirty"___("Position As Integer, Length As Integer");	COMMENT = "";
	Function "metaInformation"___("Info As QTextDocument::MetaInformation") As "String";	COMMENT = "";
	Function "object"___("ObjectIndex As Integer") As "QTextObject";	COMMENT = "";
	Function "objectForFormat"___("Format As QTextFormat") As "QTextObject";	COMMENT = "";
	Function "pageCount"___("") As "Integer";	COMMENT = "";

	Sub "print"___("Printer As QPrinter");	COMMENT = "";
	Sub "redo"___("Cursor As QTextCursor");	COMMENT = "";
	Function "resource"___("Type As Integer, Name As QUrl") As "QVariant";	COMMENT = "";
	Function "revision"___("") As "Integer";	COMMENT = "";
	Function "rootFrame"___("") As "QTextFrame";	COMMENT = "";
	Sub "setDefaultCursorMoveStyle"___("Style As Qt::CursorMoveStyle");	COMMENT = "";
	Sub "setDocumentLayout"___("Layout As QAbstractTextDocumentLayout");	COMMENT = "";
	Sub "setHtml"___("Html As String");	COMMENT = "";
	Sub "setMetaInformation"___("Info As QTextDocument::MetaInformation, S As String");	COMMENT = "";
	Sub "setPlainText"___("Text As String");	COMMENT = "";
	Sub "setTextWidth"___("Width As Float");	COMMENT = "";
	Sub "setUndoRedoEnabled"___("Enable As Boolean");	COMMENT = "";
	Sub "setUseDesignMetrics"___("B As Boolean");	COMMENT = "";
	Function "toHtml"___("Encoding As QByteArray") As "String";	COMMENT = "";
	Function "toPlainText"___("") As "String";	COMMENT = "";
	Sub "undo"___("Cursor As QTextCursor");	COMMENT = "";

	Slot "redo"___("");	COMMENT = "";
	Slot "setModified"___("Modified As Boolean");	COMMENT = "";
	Slot "undo"___("");	COMMENT = "";

	Signal "blockCountChanged"___("NewBlockCount As Integer") Declare "void blockCountChanged(int newBlockCount)"	COMMENT = "";
	Signal "contentsChange"___("Position As Integer, CharsRemoved As Integer, CharsAdded As Integer") Declare "void contentsChange(int position, int charsRemoved, int charsAdded)"	COMMENT = "";
	Signal "contentsChanged"___("") Declare "void contentsChanged()"	COMMENT = "";
	Signal "cursorPositionChanged"___("Cursor As QTextCursor") Declare "void cursorPositionChanged(const QTextCursor & cursor)"	COMMENT = "";
	Signal "documentLayoutChanged"___("") Declare "void documentLayoutChanged()"	COMMENT = "";
	Signal "modificationChanged"___("Changed As Boolean") Declare "void modificationChanged(bool changed)"	COMMENT = "";
	Signal "redoAvailable"___("Available As Boolean") Declare "void redoAvailable(bool available)"	COMMENT = "";
	Signal "undoAvailable"___("Available As Boolean") Declare "void undoAvailable(bool available)"	COMMENT = "";
	Signal "undoCommandAdded"___("") Declare "void undoCommandAdded()"	COMMENT = "";

End_Class




  }

}


bool Parser::parseBuiltinClassOrControlOrObjectHelper(_expressions & ReturnExpression, bool bAssignment, _variableconstant Variable, _statements VariableStatements, QString sClass, QString sProcedureOrProperty, bool *bFakeAlreadyHandled, bool bFirst)
{    


  if (sClass == "Debug"){

     *bFakeAlreadyHandled = true;


     QString sPrefix;


  sPrefix = PREFIX + "ID(";


     if (sProcedureOrProperty == "Line"){
       ReturnExpression.Statements << Compiler::pushCode(QString(sPrefix + "\"%1\")").arg(Me.nLine));
     } else if (sProcedureOrProperty == "ClassName"){
       ReturnExpression.Statements << Compiler::pushCode(QString(sPrefix + "\"%1\")").arg(getClassName(Me.sFileName)));
     } else if (sProcedureOrProperty == "SuperClassName"){
       ReturnExpression.Statements << Compiler::pushCode(QString(sPrefix + "\"%1\")").arg(getSuperClassName(Me.sFileName)));
     } else if (sProcedureOrProperty == "File"){
       ReturnExpression.Statements << Compiler::pushCode(QString(sPrefix + "\"%1\")").arg(Me.sFileName));
     } else if (sProcedureOrProperty == "Scope"){
       ReturnExpression.Statements << Compiler::pushCode(QString(sPrefix + "\"%1\")").arg(Me.SubFunction.sName));
     } else if (sProcedureOrProperty == "Info"){
       QString s;
       s += sPrefix + "\"File: " + Me.sFileName;
       s +=  "\\nLine: " + QString("%1").arg(Me.nLine);
       s +=  "\\nClassName: " + getClassName(Me.sFileName);
       s +=  "\\nScope: " + Me.SubFunction.sName;
       s +=  "\\nSuperClassName: " + getSuperClassName(Me.sFileName) + "\")";

       ReturnExpression.Statements << Compiler::pushCode(s);

     } else { error(""); return false; }

     ReturnExpression.sType = "String";
     return true;
     

  }

  *bFakeAlreadyHandled = false;

  bool bLoop=false;
  do {
    bLoop=false;

  QMap<QString, QString>                      classes;
  QMap<QString, QMap<QString, QString> > 			classes_properties;
  QMap<QString, QMap<QString, QStringList> > 	classes_subsfunctions;    

  if (Me.nLine == 531){
    Me.nLine = Me.nLine;
  }

  QString sClassSave = sClass;

  for (int i = 0; i < 3; i++){

    sClass = sClassSave;

    switch(i){
      case 0:
        classes = Me.controls;
        classes_properties = Me.controls_properties;
        classes_subsfunctions = Me.controls_subsfunctions;
        break;
      case 1:
        classes = Me.objects;
        classes_properties = Me.objects_properties;
        classes_subsfunctions = Me.objects_subsfunctions;
        break;
      case 2:
        classes = Me.classes;
        classes_properties = Me.classes_properties;
        classes_subsfunctions = Me.classes_subsfunctions;
        break;
    }

    if (sProcedureOrProperty == "setText" && sClass == "QClipboard"){
      sProcedureOrProperty = sProcedureOrProperty;
    }
    
    while (!classes.contains(sClass)){
      if (sClass.isEmpty() || !Me.DeclareClasses.contains(sClass)){ break; }
      sClass = Me.DeclareClasses[sClass];
    }  
  
  if (Me.nLine == 20 && Me.sFileName == "Global.QObject.q7b"){
    Me.nLine = Me.nLine;
  }

    if (classes.contains(sClass)){

      do {

        if (classes_properties[sClass].contains(sProcedureOrProperty)){

          ReturnExpression.sType = classes_properties[sClass][sProcedureOrProperty];


          if (Me.nLine == 217){
            Me.nLine = Me.nLine;
          }

          if (ReturnExpression.bReturn){
              if (bFirst){
                ReturnExpression.Statements << Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, VariableStatements);
              } else {
                  ReturnExpression.Statements = Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, ReturnExpression.Statements);
              }
          } else {

              if (Me.nLine == 217){
                Me.nLine = Me.nLine;
              }



            if (bAssignment){
              if (!parseTerm("=")){
                  if (bFirst){
                    ReturnExpression.Statements << Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, VariableStatements);
                  } else {
                      ReturnExpression.Statements = Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, ReturnExpression.Statements);
                  }

                  QString sarrrdf = Compiler::decode(ReturnExpression.Statements);



                  return true;
              }
         

              if (Me.nLine == 6){
                Me.nLine = Me.nLine;
              }

              _expressions Expression;

              if (!parseExpression(Expression)){ error(""); return false; }   
              if (!typeCompatible(ReturnExpression.sType, Expression.sType)){ error("types incompatible"); return false; }

              
           
           //   QString oosaf = Compiler::decode(Expression.Statements);
              if (bFirst){
                ReturnExpression.Statements << Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, VariableStatements, Expression.Statements);
              } else {
                  ReturnExpression.Statements = Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, ReturnExpression.Statements, Expression.Statements);
              }

            } else {
                if (bFirst){
                  ReturnExpression.Statements << Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, VariableStatements);
                } else {
                    ReturnExpression.Statements = Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, ReturnExpression.Statements);
                }
            }
          }

          //if (parseTerm(".")){
          
         // }
      //    ReturnExpression.sType = sClass;
          return true;
        }

        if (classes_subsfunctions[sClass].contains(sProcedureOrProperty)){

          if (sClass == "QClipboard" && sProcedureOrProperty == "setText"){
            sClass = sClass;
          }

          if (sProcedureOrProperty == "SetParent"){
            sClass = sClass;
          }

  if (Me.nLine == 20 && Me.sFileName == "Global.QObject.q7b"){
    Me.nLine = Me.nLine;
  }
          _expressions Expression(ReturnExpression.bReturn);
          if (parseBuiltinClassControlObject_Procedure(&sProcedureOrProperty, Expression, classes_subsfunctions[sClass])){



            QString sadf = Compiler::decode(Expression.Statements);

            if (bFirst){
              ReturnExpression.Statements << Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, VariableStatements, Expression.Statements);
            } else {
                ReturnExpression.Statements = Compiler::pushBuiltinClassProperty(sClass, ReturnExpression.bReturn, sProcedureOrProperty, ReturnExpression.Statements, Expression.Statements);
            }

         

            QString sa333df = Compiler::decode(Expression.Statements);

            ReturnExpression.sType = Expression.sType;
            return true;
          }
        }
        sClassSave = sClass = classes[sClass]; 
        if (!sClass.isEmpty() && !classes.contains(sClass)){
          break; 
        }
        i = 0;
      } while (!sClass.isEmpty());
    }

  }

  if (Me.Classes.contains(sClass)){
    sClass = getSuperClassNameOfType(sClass);

    if (sClass.isEmpty() == false){
      bLoop=true;
     
    } else {
      
    }
  }
  } while(bLoop);
  return false;
}


bool Parser::parseBuiltinClassOrControlOrObject_PropertyOrProcedure(_expressions & ReturnExpression, _variableconstant Variable, _statements VariableStatements, bool *bFakeAlreadyHandled, bool bAssignment)
{    
  _BEGIN_

  {

      if (Me.nLine == 217){
        Me.nLine = Me.nLine;
      }

  
    QString sClass = Variable.sType;

    bool b = false;
    bool bFirst = true;
    while (parseTerm(".")){
      b = false;
      QString sProcedureOrProperty;

      if (parseIdentifier(&sProcedureOrProperty) || parseTerm(&sProcedureOrProperty)){

        if (sProcedureOrProperty == "QProgressBar"){
          sProcedureOrProperty = sProcedureOrProperty;
        }
        if (parseBuiltinClassOrControlOrObjectHelper(ReturnExpression, bAssignment, Variable, VariableStatements, sClass, sProcedureOrProperty, bFakeAlreadyHandled, bFirst)){
          b = true;
          sClass = ReturnExpression.sType;
        } else { break; }


        QString sarrrdf = Compiler::decode(ReturnExpression.Statements);

        bFirst = false;
      }    
    }
    return b;
  }

  _END_  
}




#undef COMMENT
#undef CLASSCOMMENT
#undef Property
#undef Function
#undef Sub
#undef Event
#undef Signal
#undef Delegate
#undef As
#undef Declare
#undef Cast
#undef Class
#undef SuperClass
#undef End_Class
#undef SEEALSO
#undef EXAMPLE
#undef ___
#undef As
#undef Alias





#include "_Q7BCompiler.h"



#define COMMENT ll<<sType;ll<<v;Me.constants[r.isEmpty()?l:l+"."+r]=ll;Me.comments_constants[r.isEmpty()?l:l+"."+r]._RETURN=sType;Me.comments_constants[r.isEmpty()?l:l+"."+r]._GROUP=r.isEmpty()?"":l;Me.comments_constants[r.isEmpty()?l:l+"."+r]._COMMENT

#define Const ll.clear();l=
#define _ ;r=
#define ___ ;v=
#define As ;sType=


void Parser::CreateListOfConstants()
{      
  QList<QVariant> ll;
  QString l;
  QString r;
  QVariant v;
  QString sType;
  QString sKey;
    
  if (Me.constants.size() == 0){    
    


    

    Const "Qt.CaseInsensitive"___        (Qt::CaseInsensitive) As "Integer";          COMMENT = "";
    Const "Qt.CaseSensitive"___          (Qt::CaseSensitive) As "Integer";          COMMENT = "";

    Const "CaseSensitive"___          (true) As "Boolean";                            COMMENT = "";
    Const "CaseInsensitive"___        (false) As "Boolean";                           COMMENT = "";
    
    Const "SectionDefault"___        (QString::SectionDefault) As "Integer";          COMMENT = "";
    Const "SectionSkipEmpty"___        (QString::SectionSkipEmpty) As "Integer";          COMMENT = "";
    Const "SectionIncludeLeadingSep"___        (QString::SectionIncludeLeadingSep) As "Integer";          COMMENT = "";
    Const "SectionIncludeTrailingSep"___        (QString::SectionIncludeTrailingSep) As "Integer";          COMMENT = "";
    Const "SectionCaseInsensitiveSeps"___        (QString::SectionCaseInsensitiveSeps) As "Integer";          COMMENT = "";

    Const "vbCr"___        ("\"\\r\"") As "String";          COMMENT = "";
    Const "vbLf"___        ("\"\\n\"") As "String";          COMMENT = "";
    Const "vbCrLf"___        ("\"\\r\\n\"") As "String";          COMMENT = "";
    
    Const "vbOKOnly"___        (0) As "Integer";          COMMENT = "";
    Const "vbOKCancel"___        (1) As "Integer";          COMMENT = "";
    Const "vbAbortRetryIgnore"___        (2) As "Integer";          COMMENT = "";
    Const "vbYesNoCancel"___        (3) As "Integer";          COMMENT = "";
    Const "vbYesNo"___        (4) As "Integer";          COMMENT = "";
    Const "vbRetryCancel"___        (5) As "Integer";          COMMENT = "";
    Const "vbCritical"___        (16) As "Integer";          COMMENT = "";
    Const "vbQuestion"___        (32) As "Integer";          COMMENT = "";
    Const "vbExclamation"___        (48) As "Integer";          COMMENT = "";
    Const "vbInformation"___        (64) As "Integer";          COMMENT = "";
    Const "vbDefaultButton1"___        (0) As "Integer";          COMMENT = "";
    Const "vbDefaultButton2"___        (256) As "Integer";          COMMENT = "";
    Const "vbDefaultButton3"___        (512) As "Integer";          COMMENT = "";

    Const "vbOK"___        (1) As "Integer";          COMMENT = "";
    Const "vbCancel"___        (2) As "Integer";          COMMENT = "";
    Const "vbAbort"___        (3) As "Integer";          COMMENT = "";
    Const "vbRetry"___        (4) As "Integer";          COMMENT = "";
    Const "vbIgnore"___        (5) As "Integer";          COMMENT = "";
    Const "vbYes"___        (6) As "Integer";          COMMENT = "";
    Const "vbNo"___        (7) As "Integer";          COMMENT = "";

  //  TODO2 Type "Dir.Filter" oder As Const "..."

    Const "Dir"_"NoSort"___    (QDir::NoSort) As "Integer";                    COMMENT = "";
    Const "Dir"_"Name"___             (QDir::Name) As "Integer";                      COMMENT = "";
    Const "Dir"_"Time"___             (QDir::Time) As "Integer";                      COMMENT = "";
    Const "Dir"_"Size"___             (QDir::Size) As "Integer";                      COMMENT = "";
    Const "Dir"_"Type"___             (QDir::Type) As "Integer";                      COMMENT = "";
    Const "Dir"_"Unsorted"___             (QDir::Unsorted) As "Integer";                      COMMENT = "";
    Const "Dir"_"DirsFirst"___             (QDir::DirsFirst) As "Integer";                      COMMENT = "";
    Const "Dir"_"DirsLast"___             (QDir::DirsLast) As "Integer";                      COMMENT = "";
    Const "Dir"_"Reversed"___             (QDir::Reversed) As "Integer";                      COMMENT = "";
    Const "Dir"_"IgnoreCase"___             (QDir::IgnoreCase) As "Integer";                      COMMENT = "";
    Const "Dir"_"LocaleAware"___             (QDir::LocaleAware) As "Integer";                      COMMENT = "";

   

    Const "Dir"_"NoFilter"___             (QDir::NoFilter) As "Integer";                      COMMENT = "";
    Const "Dir"_"Dirs"___             (QDir::Dirs) As "Integer";                      COMMENT = "";
    Const "Dir"_"AllDirs"___             (QDir::AllDirs) As "Integer";                      COMMENT = "";
    Const "Dir"_"Files"___             (QDir::Files) As "Integer";                      COMMENT = "";
    Const "Dir"_"Drives"___             (QDir::Drives) As "Integer";                      COMMENT = "";
    Const "Dir"_"NoSymLinks"___             (QDir::NoSymLinks) As "Integer";                      COMMENT = "";
    Const "Dir"_"NoDotAndDotDot"___             (QDir::NoDotAndDotDot) As "Integer";                      COMMENT = "";
    Const "Dir"_"AllEntries"___             (QDir::AllEntries) As "Integer";                      COMMENT = "";
    Const "Dir"_"Readable"___             (QDir::Readable) As "Integer";                      COMMENT = "";
    Const "Dir"_"Writable"___             (QDir::Writable) As "Integer";                      COMMENT = "";
    Const "Dir"_"Executable"___             (QDir::Executable) As "Integer";                      COMMENT = "";
    Const "Dir"_"Modified"___             (QDir::Modified) As "Integer";                      COMMENT = "";
    Const "Dir"_"Hidden"___             (QDir::Hidden) As "Integer";                      COMMENT = "";
    Const "Dir"_"System"___             (QDir::System) As "Integer";                      COMMENT = "";
    Const "Dir"_"CaseSensitive"___             (QDir::CaseSensitive) As "Integer";                      COMMENT = "";

    Const "QTableWidget"_"MatchExactly"___             (Qt::MatchExactly) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchFixedString"___             (Qt::MatchFixedString) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchContains"___             (Qt::MatchContains) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchStartsWith"___             (Qt::MatchStartsWith) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchEndsWith"___             (Qt::MatchEndsWith) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchCaseSensitive"___             (Qt::MatchCaseSensitive) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchRegExp"___             (Qt::MatchRegExp) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchWildcard"___             (Qt::MatchWildcard) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchWrap"___             (Qt::MatchWrap) As "Integer";                      COMMENT = "";
    Const "QTableWidget"_"MatchRecursive"___             (Qt::MatchRecursive) As "Integer";                      COMMENT = "";

    Const "InputDialog"_"Normal"___             (QLineEdit::Normal) As "Integer";                      COMMENT = "";
    Const "InputDialog"_"NoEcho"___             (QLineEdit::NoEcho) As "Integer";                      COMMENT = "";
    Const "InputDialog"_"Password"___             (QLineEdit::Password) As "Integer";                      COMMENT = "";
    Const "InputDialog"_"PasswordEchoOnEdit"___             (QLineEdit::PasswordEchoOnEdit) As "Integer";                      COMMENT = "";

    Const "QDialog"_"Accepted"___             (QDialog::Accepted) As "Integer";                      COMMENT = "";
    Const "QDialog"_"Rejected"___             (QDialog::Rejected) As "Integer";                      COMMENT = "";

    Const "QMdiArea"_"SubWindowView"___             (QMdiArea::SubWindowView) As "Integer";                      COMMENT = "";
    Const "QMdiArea"_"TabbedView"___             (QMdiArea::TabbedView) As "Integer";                      COMMENT = "";

    Const "Flags"_"NoItemFlags"___             (Qt::NoItemFlags) As "Integer";                      COMMENT = "It does not have any properties set.";
    Const "Flags"_"ItemIsSelectable"___             (Qt::ItemIsSelectable) As "Integer";                      COMMENT = "It can be selected.";
    Const "Flags"_"ItemIsEditable"___             (Qt::ItemIsEditable) As "Integer";                      COMMENT = "It can be edited.";
    Const "Flags"_"ItemIsDragEnabled"___             (Qt::ItemIsDragEnabled) As "Integer";                      COMMENT = "It can be dragged.";
    Const "Flags"_"ItemIsDropEnabled"___             (Qt::ItemIsDropEnabled) As "Integer";                      COMMENT = "It can be used as a drop target.";
    Const "Flags"_"ItemIsUserCheckable"___             (Qt::ItemIsUserCheckable) As "Integer";                      COMMENT = "It can be checked or unchecked by the user.";
    Const "Flags"_"ItemIsEnabled"___             (Qt::ItemIsEnabled) As "Integer";                      COMMENT = "The user can interact with the item.";
    Const "Flags"_"ItemIsTristate"___             (Qt::ItemIsTristate) As "Integer";                      COMMENT = "The item is checkable with three separate states.";

    Const "EchoMode"_"Normal"___             (QLineEdit::Normal) As "Integer";                      COMMENT = "";
    Const "EchoMode"_"NoEcho"___             (QLineEdit::NoEcho) As "Integer";                      COMMENT = "";
    Const "EchoMode"_"Password"___             (QLineEdit::Password) As "Integer";                      COMMENT = "";
    Const "EchoMode"_"PasswordEchoOnEdit"___             (QLineEdit::PasswordEchoOnEdit) As "Integer";                      COMMENT = "";

    Const "CheckState"_"Unchecked"___             (Qt::Unchecked) As "Integer";                      COMMENT = "The item is unchecked.";
    Const "CheckState"_"PartiallyChecked"___             (Qt::PartiallyChecked) As "Integer";                      COMMENT = "The item is partially checked. Items in hierarchical models may be partially checked if some, but not all, of their children are checked.";
    Const "CheckState"_"Checked"___             (Qt::Checked) As "Integer";                      COMMENT = "The item is checked.";

    Const "MatchFlags"_"MatchExactly"___             (Qt::MatchExactly) As "Integer";                      COMMENT = "Performs QVariant-based matching.";
    Const "MatchFlags"_"MatchFixedString"___             (Qt::MatchFixedString) As "Integer";                      COMMENT = "Performs string-based matching. String-based comparisons are case-insensitive unless the MatchCaseSensitive flag is also specified.";
    Const "MatchFlags"_"MatchContains"___             (Qt::MatchContains) As "Integer";                      COMMENT = "The search term is contained in the item.";
    Const "MatchFlags"_"MatchStartsWith"___             (Qt::MatchStartsWith) As "Integer";                      COMMENT = "The search term matches the start of the item.";
    Const "MatchFlags"_"MatchEndsWith"___             (Qt::MatchEndsWith) As "Integer";                      COMMENT = "The search term matches the end of the item.";
    Const "MatchFlags"_"MatchCaseSensitive"___             (Qt::MatchCaseSensitive) As "Integer";                      COMMENT = "The search is case sensitive.";
    Const "MatchFlags"_"MatchRegExp"___             (Qt::MatchRegExp) As "Integer";                      COMMENT = "Performs string-based matching using a regular expression as the search term.";
    Const "MatchFlags"_"MatchWildcard"___             (Qt::MatchWildcard) As "Integer";                      COMMENT = "Performs string-based matching using a string with wildcards as the search term.";
    Const "MatchFlags"_"MatchWrap"___             (Qt::MatchWrap) As "Integer";                      COMMENT = "Perform a search that wraps around, so that when the search reaches the last item in the model, it begins again at the first item and continues until all items have been examined.";
    Const "MatchFlags"_"MatchRecursive"___             (Qt::MatchRecursive) As "Integer";                      COMMENT = "Searches the entire hierarchy.";

    Const "TextAlignment"_"AlignLeft"___             (Qt::AlignLeft) As "Integer";                      COMMENT = "Aligns with the left edge.";
    Const "TextAlignment"_"AlignRight"___             (Qt::AlignRight) As "Integer";                      COMMENT = "Aligns with the right edge.";
    Const "TextAlignment"_"AlignHCenter"___             (Qt::AlignHCenter) As "Integer";                      COMMENT = "Centers horizontally in the available space.";
    Const "TextAlignment"_"AlignJustify"___             (Qt::AlignJustify) As "Integer";                      COMMENT = "Justifies the text in the available space.";
    Const "TextAlignment"_"AlignTop"___             (Qt::AlignTop) As "Integer";                      COMMENT = "Aligns with the top.";
    Const "TextAlignment"_"AlignBottom"___             (Qt::AlignBottom) As "Integer";                      COMMENT = "Aligns with the bottom.";
    Const "TextAlignment"_"AlignVCenter"___             (Qt::AlignVCenter) As "Integer";                      COMMENT = "Centers vertically in the available space.";
    Const "TextAlignment"_"AlignCenter"___             (Qt::AlignCenter) As "Integer";                      COMMENT = "Centers in both dimensions.";
    Const "TextAlignment"_"AlignAbsolute"___             (Qt::AlignAbsolute) As "Integer";                      COMMENT = "";
    Const "TextAlignment"_"AlignLeading"___             (Qt::AlignLeading) As "Integer";                      COMMENT = "Synonym for AlignLeft.";
    Const "TextAlignment"_"AlignHorizontal_Mask"___             (Qt::AlignHorizontal_Mask) As "Integer";                      COMMENT = "Combined.";
    Const "TextAlignment"_"AlignVertical_Mask"___             (Qt::AlignVertical_Mask) As "Integer";                      COMMENT = "Combined.";
    Const "TextAlignment"_"AlignTrailing"___             (Qt::AlignTrailing) As "Integer";                      COMMENT = "Synonym for AlignRight.";

    Const "Alignment"_"AlignLeft"___             (Qt::AlignLeft) As "Integer";                      COMMENT = "Aligns with the left edge.";
    Const "Alignment"_"AlignRight"___             (Qt::AlignRight) As "Integer";                      COMMENT = "Aligns with the right edge.";
    Const "Alignment"_"AlignHCenter"___             (Qt::AlignHCenter) As "Integer";                      COMMENT = "Centers horizontally in the available space.";
    Const "Alignment"_"AlignJustify"___             (Qt::AlignJustify) As "Integer";                      COMMENT = "Justifies the text in the available space.";
    Const "Alignment"_"AlignTop"___             (Qt::AlignTop) As "Integer";                      COMMENT = "Aligns with the top.";
    Const "Alignment"_"AlignBottom"___             (Qt::AlignBottom) As "Integer";                      COMMENT = "Aligns with the bottom.";
    Const "Alignment"_"AlignVCenter"___             (Qt::AlignVCenter) As "Integer";                      COMMENT = "Centers vertically in the available space.";
    Const "Alignment"_"AlignCenter"___             (Qt::AlignCenter) As "Integer";                      COMMENT = "Centers in both dimensions.";
    Const "Alignment"_"AlignAbsolute"___             (Qt::AlignAbsolute) As "Integer";                      COMMENT = "";
    Const "Alignment"_"AlignLeading"___             (Qt::AlignLeading) As "Integer";                      COMMENT = "Synonym for AlignLeft.";
    Const "Alignment"_"AlignHorizontal_Mask"___             (Qt::AlignHorizontal_Mask) As "Integer";                      COMMENT = "Combined.";
    Const "Alignment"_"AlignVertical_Mask"___             (Qt::AlignVertical_Mask) As "Integer";                      COMMENT = "Combined.";
    Const "Alignment"_"AlignTrailing"___             (Qt::AlignTrailing) As "Integer";                      COMMENT = "Synonym for AlignRight.";

    Const "TextInteractionFlags"_"NoTextInteraction"___             (Qt::NoTextInteraction) As "Integer";                      COMMENT = "No interaction with the text is possible.";
    Const "TextInteractionFlags"_"TextSelectableByMouse"___             (Qt::TextSelectableByMouse) As "Integer";                      COMMENT = "Text can be selected with the mouse and copied to the clipboard using a context menu or standard keyboard shortcuts.";
    Const "TextInteractionFlags"_"TextSelectableByKeyboard"___             (Qt::TextSelectableByKeyboard) As "Integer";                      COMMENT = "Text can be selected with the cursor keys on the keyboard. A text cursor is shown.";
    Const "TextInteractionFlags"_"LinksAccessibleByMouse"___             (Qt::LinksAccessibleByMouse) As "Integer";                      COMMENT = "Links can be highlighted and activated with the mouse.";
    Const "TextInteractionFlags"_"LinksAccessibleByKeyboard"___             (Qt::LinksAccessibleByKeyboard) As "Integer";                      COMMENT = "Links can be focused using tab and activated with enter.";
    Const "TextInteractionFlags"_"TextEditable"___             (Qt::TextEditable) As "Integer";                      COMMENT = "The text is fully editable.";
    Const "TextInteractionFlags"_"TextEditorInteraction"___             (Qt::TextEditorInteraction) As "Integer";                      COMMENT = "Combined.";
    Const "TextInteractionFlags"_"TextBrowserInteraction"___             (Qt::TextBrowserInteraction) As "Integer";                      COMMENT = "Combined.";

    Const "SystemTrayIcon"_"Unknown"___             (QSystemTrayIcon::Unknown) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"Context"___             (QSystemTrayIcon::Context) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"DoubleClick"___             (QSystemTrayIcon::DoubleClick) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"Trigger"___             (QSystemTrayIcon::Trigger) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"MiddleClick"___             (QSystemTrayIcon::MiddleClick) As "Integer";                      COMMENT = "";

    Const "SystemTrayIcon"_"NoIcon"___             (QSystemTrayIcon::NoIcon) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"Information"___             (QSystemTrayIcon::Information) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"Warning"___             (QSystemTrayIcon::Warning) As "Integer";                      COMMENT = "";
    Const "SystemTrayIcon"_"Critical"___             (QSystemTrayIcon::Critical) As "Integer";                      COMMENT = "";

    Const "MessageBox"_"Sheet"___             (999999) As "Integer";                      COMMENT = ""; 
    Const "MessageBox"_"NoIcon"___             (QMessageBox::NoIcon) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Question"___             (QMessageBox::Question) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Information"___             (QMessageBox::Information) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Warning"___             (QMessageBox::Warning) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Critical"___             (QMessageBox::Critical) As "Integer";                      COMMENT = "";

    Const "MessageBox"_"Ok"___             (QMessageBox::Ok) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Open"___             (QMessageBox::Open) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Save"___             (QMessageBox::Save) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Cancel"___             (QMessageBox::Cancel) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Close"___             (QMessageBox::Close) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Discard"___             (QMessageBox::Discard) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Apply"___             (QMessageBox::Apply) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Reset"___             (QMessageBox::Reset) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"RestoreDefaults"___             (QMessageBox::RestoreDefaults) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Help"___             (QMessageBox::Help) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"SaveAll"___             (QMessageBox::SaveAll) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Yes"___             (QMessageBox::Yes) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"YesToAll"___             (QMessageBox::YesToAll) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"No"___             (QMessageBox::No) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"NoToAll"___             (QMessageBox::NoToAll) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Abort"___             (QMessageBox::Abort) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Retry"___             (QMessageBox::Retry) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"Ignore"___             (QMessageBox::Ignore) As "Integer";                      COMMENT = "";

    Const "MessageBox"_"NoButton"___             (QMessageBox::NoButton) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"InvalidRole"___             (QMessageBox::InvalidRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"AcceptRole"___             (QMessageBox::AcceptRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"RejectRole"___             (QMessageBox::RejectRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"DestructiveRole"___             (QMessageBox::DestructiveRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"ActionRole"___             (QMessageBox::ActionRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"HelpRole"___             (QMessageBox::HelpRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"YesRole"___             (QMessageBox::YesRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"NoRole"___             (QMessageBox::NoRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"ApplyRole"___             (QMessageBox::ApplyRole) As "Integer";                      COMMENT = "";
    Const "MessageBox"_"ResetRole"___             (QMessageBox::ResetRole) As "Integer";                      COMMENT = "";

    Const "MsgBox"_"Ok"___             (QMessageBox::Ok) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Open"___             (QMessageBox::Open) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Save"___             (QMessageBox::Save) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Cancel"___             (QMessageBox::Cancel) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Close"___             (QMessageBox::Close) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Discard"___             (QMessageBox::Discard) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Apply"___             (QMessageBox::Apply) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Reset"___             (QMessageBox::Reset) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"RestoreDefaults"___             (QMessageBox::RestoreDefaults) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Help"___             (QMessageBox::Help) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"SaveAll"___             (QMessageBox::SaveAll) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Yes"___             (QMessageBox::Yes) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"YesToAll"___             (QMessageBox::YesToAll) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"No"___             (QMessageBox::No) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"NoToAll"___             (QMessageBox::NoToAll) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Abort"___             (QMessageBox::Abort) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Retry"___             (QMessageBox::Retry) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"Ignore"___             (QMessageBox::Ignore) As "Integer";                      COMMENT = "";
    Const "MsgBox"_"NoButton"___             (QMessageBox::NoButton) As "Integer";                      COMMENT = "";



  }


  


}

void pushConstant(QList<QVariant> & l, _expressions & Expression)
{
  Expression.sType = l.at(0).toString();

  if (l.at(0) == "String"){ 
    Expression.Statements << Compiler::pushString(l.at(1).toString());

  } else if (l.at(0) == "Identifier"){
     Expression.Statements << Compiler::pushIdentifier(l.at(1).toString());

  } else if (l.at(0) == "Boolean"){ 
    Expression.Statements << Compiler::pushBoolean(l.at(1).toBool());    

  } else {
    Expression.Statements << Compiler::pushInteger(l.at(1).toInt());    
  }
}

bool Parser::parseBuiltinConstant(_expressions & ReturnExpression)
{    
  _BEGIN_

  QString sIdentifier;

  if (parseIdentifier(&sIdentifier)){

    if (Me.constants.contains(sIdentifier)){

      pushConstant(Me.constants[sIdentifier], ReturnExpression);

      
           if (sIdentifier == "vbOKOnly") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbOKCancel") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbAbortRetryIgnore") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbYesNoCancel") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbYesNo") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbRetryCancel") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbCritical") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbQuestion") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbExclamation") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbInformation") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbDefaultButton1") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbDefaultButton2") Me.bVB6MsgBox = true;
      else if (sIdentifier == "vbDefaultButton3") Me.bVB6MsgBox = true;

      return true;
    }

    if (parseTerm(".")){

      QString sIdentifier2;

      if (parseIdentifier(&sIdentifier2)){

        if (Me.constants.contains(sIdentifier + "." + sIdentifier2)){

          if (!peekTerm("(")){ 
            pushConstant(Me.constants[sIdentifier + "." + sIdentifier2], ReturnExpression);
            
            return true;
          }
        }

      }

    }

  }

  _END_  
}



#undef COMMENT
#undef Const
#undef _
#undef ___
#undef As








#include "_Q7BCompiler.h"






#include "_Q7BCompiler.h"




#define COMMENT ;;Parser::doComment(CLASS,SUPERCLASS,SUBFUNCTION,lAlias,sType,l,sGROUP,sSEEALSO,sCOMMENT,sCLASSCOMMENT,sEXAMPLE,bProperty,bEvent,bSignal,bDelegate,Me.comments_controls, Me.controls_properties,Me.controls_subsfunctions, Me.controls_events, Me.controls_signals, Me.controls_delegates, Me.controls_declare_events_signals_delegates, Me.controls_declarecast_events_signals_delegates, Me.controls_declarecode_events_signals_delegates, Me.controls_declaretype_events_signals_delegates, sDeclare, sCast, sCode);Me.comments_controls[CLASS][SUBFUNCTION]._COMMENT


#define CLASSCOMMENT ;Me.comments_controls[CLASS][""]._COMMENT

#define Property ;bProperty=true;SUBFUNCTION=
#define As ;sType=
#define Declare ;sCast="";sCode="";sDeclare=
#define Cast ;sCast=
#define Code ;sCode=

#define Control ;SUPERCLASS="";CLASS=
#define End_Control ;Me.controls[CLASS]=SUPERCLASS;
#define SuperClass ;SUPERCLASS=

#define SEEALSO ;sSEEALSO
#define EXAMPLE ;sEXAMPLE

#define Function ;sType="";SUBFUNCTION=
#define Sub ;sType="";SUBFUNCTION=
#define Event ;bEvent=true;sType="";SUBFUNCTION=
#define Signal ;bSignal=true;sType="";SUBFUNCTION=
#define Delegate ;bDelegate=true;sType="";SUBFUNCTION=

#define ___ ;l<<Parser::SubFunction
#define As ;sType=
#define Alias ;lAlias<<

void Parser::CreateListOfControls()
{    
  
  QString CLASS;
  QString SUPERCLASS;
  QString SUBFUNCTION;
  QStringList lAlias; 
  QString sType;
  QString sDeclare;
  QString sCast;
  QString sCode;
  QStringList l;

  QString sGROUP;
  QString sSEEALSO;
  QString sCOMMENT;
  QString sEXAMPLE;
  QString sCLASSCOMMENT;  

  bool bProperty = false;
  bool bEvent = false;
  bool bSignal = false;
  bool bDelegate = false;
  
  if (Me.controls_properties.size() == 0){    
    
    





    // ----------------------------------------------------------------------------------------------------------------------------

    Control "Control" SuperClass "QWidget"
  
      Property "Group" As "String";    COMMENT = "";

    End_Control

    

    Control "ImageButton" SuperClass "Control"
  
      Property "Caption" As "String";    COMMENT = "";
      Property "Icon" As "String";    COMMENT = "";
      Property "Checkable" As "Boolean";    COMMENT = "";
      Property "CheckableExclusive" As "Boolean";    COMMENT = "";
      Property "Checked" As "Boolean";    COMMENT = "";
      Property "EnabledImage" As "String";    COMMENT = "";
      Property "DisabledImage" As "String";    COMMENT = "";
      Property "EnterImage" As "String";    COMMENT = "";
      Property "ExitImage" As "String";    COMMENT = "";
      Property "MouseDownImage" As "String";    COMMENT = "";
      Property "MouseUpImage" As "String";    COMMENT = "";
      Property "EnterSound" As "String";    COMMENT = "";
      Property "ExitSound" As "String";    COMMENT = "";
      Property "MouseDownSound" As "String";    COMMENT = "";
      Property "MouseUpSound" As "String";    COMMENT = "";
      Property "CheckedEnabledImage" As "String";    COMMENT = "";
      Property "CheckedDisabledImage" As "String";    COMMENT = "";
      Property "CheckedEnterImage" As "String";    COMMENT = "";
      Property "CheckedExitImage" As "String";    COMMENT = "";
      Property "CheckedMouseDownImage" As "String";    COMMENT = "";
      Property "CheckedMouseUpImage" As "String";    COMMENT = "";
      Property "Scale" As "Boolean";    COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "CommandButton" SuperClass "QPushButton"
  
      Property "Icon" As "String";    COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "CommandLinkButton" SuperClass "QCommandLinkButton"
  
      Property "Icon" As "String";    COMMENT = "";
      Property "Description" As "String";    COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "ToolButton" SuperClass "QToolButton"
  
      Property "Icon" As "String";    COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "Timer" SuperClass "Control"
  
      Property "Interval" As "Integer";    COMMENT = "";
      Property "Enabled" As "Boolean";    COMMENT = "";

      Sub      "Start"___("");  COMMENT = "";
      Sub      "Stop"___("");  COMMENT = "";
      Function "IsRunning"___("") As "Boolean";  COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "UdpSocket" SuperClass "Control"
  
      Property "Port" As "Integer";    COMMENT = "";
      Property "Host" As "String";    COMMENT = "";

      Function "Open"___("") As "Boolean";  COMMENT = "";
      Function "ReadData"___("") As "String";  COMMENT = "";
      Sub      "Close"___("");  COMMENT = "";
      Function "LastError"___("") As "String";  COMMENT = "";
      Function "LastErrorText"___("") As "String";  COMMENT = "";
      Function "WriteData"___("theData As String") As "Boolean";  COMMENT = "";
      Function "Bind"___("Host As String, Port As Integer") As "Boolean";  COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

      Signal "Error"___("") Declare "void Error()"   COMMENT = "";
      Signal "Open"___("") Declare "void Open()"   COMMENT = "";
      Signal "Close"___("") Declare "void Close()"   COMMENT = "";

    End_Control

    

    Control "CheckBox" SuperClass "QCheckBox"
  
      Property "Icon" As "String";    COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "TextBox" SuperClass "QLineEdit"
  
      #include "Control.h" // Control signals

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "RadioButton" SuperClass "QRadioButton"
  
      Property "Icon" As "String";    COMMENT = "";

      #include "Control.h" 

      Signal "Event"___("") Declare "void Event()"   COMMENT = "";

    End_Control

    

    Control "Label" SuperClass "QLabel"
  
      Property "InputControl" As "String";    COMMENT = "";
      Property "Shape" As "Boolean";    COMMENT = "";
      Property "Icon" As "String";    COMMENT = "";

      #include "Control.h" 

    End_Control

    

    Control "Frame" SuperClass "QGroupBox"

      #include "Control.h" // Control signals

    End_Control

    // ----------------------------------------------------------------------------------------------------------------------------

    Control "ImageBox" SuperClass "QFrame"
  
      Property "Value" As "String";    COMMENT = "";
      Property "Text" As "String";    COMMENT = "";

      #include "Control.h" 

    End_Control

    


  }
}


#undef COMMENT
#undef CLASSCOMMENT
#undef Property
#undef Function
#undef Sub
#undef Event
#undef Signal
#undef Delegate
#undef As
#undef Declare
#undef Cast
#undef Control
#undef SuperClass
#undef End_Control
#undef SEEALSO
#undef EXAMPLE
#undef ___
#undef As
#undef Alias





#include "_Q7BCompiler.h"

void Parser::CreateListOfcppobjcjava_keywords()
{    


  
  Me.cppobjcjava_keywords << "asm" << "delete" << "goto" << "return" << "typedef" << "auto" << "do" << "if" << "short" << "typeid" << "bad_cast" << "double" << "inline" << "signed" << "typename" << "bad_typeid" << "dynamic_cast" << "int" << "sizeof" << "union" << "bool" << "else" << "long" << "static" << "unsigned" << "break" << "enum" << "mutable" << "static_cast" << "using" << "case" << "except" << "namespace" << "struct" << "virtual" << "catch" << "explicit" << "new" << "switch" << "void" << "char" << "extern" << "operator" << "template" << "volatile" << "class" << "false" << "private" << "this" << "while" << "const" << "finally" << "protected" << "throw" << "const_cast" << "float" << "public" << "true" << "continue" << "for" << "register" << "try" << "default" << "friend" << "reinterpret_cast" << "type_info";
  Me.cppobjcjava_keywords << "id" << "ui" << "Q7B"; 
   

  for (int i = 0; i < Me.cppobjcjava_keywords.size(); i++){

    Me.comments_cppobjb_keywords[Me.cppobjcjava_keywords.at(i)]._COMMENT = "";
    
  }

  Me.cppobjcjava_keywords.sort();
  
}



  
  




#include "_Q7BCompiler.h"

#define COMMENT ;Me.keywords<<sKeyword;Me.comments_keywords[sKeyword]._COMMENT
#define EXAMPLE ;Me.comments_keywords[sKeyword]._EXAMPLE
#define SEEALSO ;Me.comments_keywords[sKeyword]._SEEALSO

#define Keyword ;sKeyword=


void Parser::CreateListOfKeywords()
{      
  QString sKeyword;
    
  if (Me.keywords.size() == 0){    
    
    
    





      Keyword "REM"        COMMENT = "Very old basic command. Not supported yet.";
      Keyword "$Dynamic"        COMMENT = "Very old basic command. Not supported yet.";
      Keyword "$Static"        COMMENT = "Very old basic command. Not supported yet.";
      Keyword "Option"        COMMENT = "Very old basic command. Not supported yet.";
      Keyword "Base"        COMMENT = "Very old basic command. Not supported yet.";
      Keyword "Binary"        COMMENT = "Very old basic command. Not supported yet.";
      Keyword "Text"        COMMENT = "Very old basic command. Not supported yet.";
    Keyword "Inherits"        COMMENT = "Reserved.";
    Keyword "Abstract"        COMMENT = "Reserved.";
     Keyword "Compare"        COMMENT = "Very old basic command. Not supported yet.";
	      Keyword "Class_Initialize"        COMMENT = "Very old basic command. Not supported yet.";
	      Keyword "Class_Terminate"        COMMENT = "Very old basic command. Not supported yet.";
	      Keyword "Common"        COMMENT = "Very old basic command. Not supported yet.";
	   Keyword "Shared"        COMMENT = "Very old basic command. Not supported yet.";
	   Keyword "Data"        COMMENT = "Very old basic command. Not supported yet.";
	 	   Keyword "Read"        COMMENT = "Very old basic command. Not supported yet.";
	  	   Keyword "Restore"        COMMENT = "Very old basic command. Not supported yet.";
	 
	   	   Keyword "DefBool"        COMMENT = "Very old basic command. Not supported yet.";
	   	   Keyword "DefByte"        COMMENT = "Very old basic command. Not supported yet.";
	   	   Keyword "DefCur"        COMMENT = "Very old basic command. Not supported yet.";
	   	   Keyword "DefDate"        COMMENT = "Very old basic command. Not supported yet.";
	   	   Keyword "DefDbl"        COMMENT = "Very old basic command. Not supported yet.";
	   	   Keyword "DefInt"        COMMENT = "Very old basic command. Not supported yet.";
	   	   Keyword "DefLng"        COMMENT = "Very old basic command. Not supported yet.";
	   Keyword "DefObj"        COMMENT = "Very old basic command. Not supported yet.";
	   Keyword "DefSng"        COMMENT = "Very old basic command. Not supported yet."
	   Keyword "DefStr"        COMMENT = "Very old basic command. Not supported yet.";
	    Keyword "DefVar"        COMMENT = "Very old basic command. Not supported yet.";
	 
	 
	    Keyword "Empty"        COMMENT = "Very old basic command. Not supported yet.";
	    Keyword "Nothing"        COMMENT = "Very old basic command. Not supported yet.";
	 
	    Keyword "Erase"        COMMENT = "Very old basic command. Not supported yet.";
	     Keyword "Explicit"        COMMENT = "Very old basic command. Not supported yet.";
	 	     Keyword "GoSub"        COMMENT = "Very old basic command. Not supported yet.";
	     Keyword "Let"        COMMENT = "Very old basic command. Not supported yet.";
	 	     Keyword "Like"        COMMENT = "Very old basic command. Not supported yet.";
	     Keyword "LSet"        COMMENT = "Very old basic command. Not supported yet.";
	     Keyword "Off"        COMMENT = "Very old basic command. Not supported yet.";
	     Keyword "On"        COMMENT = "Very old basic command. Not supported yet.";
	    Keyword "Optional"        COMMENT = "Very old basic command. Not supported yet.";
		    Keyword "Range"        COMMENT = "Very old basic command. Not supported yet.";
	    Keyword "Resume"        COMMENT = "Very old basic command. Not supported yet.";
	    Keyword "RSet"        COMMENT = "Very old basic command. Not supported yet.";
	    Keyword "Stop"        COMMENT = "Very old basic command. Not supported yet.";
	 	    Keyword "System"        COMMENT = "Very old basic command. Not supported yet.";
	  //	    Keyword "Timer"        COMMENT = "Very old basic command. Not supported yet.";
	 	    Keyword "TypeOf"        COMMENT = "Very old basic command. Not supported yet.";
	     Keyword "WEnd"        COMMENT = "Very old basic command. Not supported yet.";
	 







    Keyword "With"        COMMENT = "Reserved.";
    Keyword "Throw"        COMMENT = "Reserved.";
      Keyword "Throws"        COMMENT = "Reserved.";
  

       Keyword "Protected"        COMMENT = "Reserved.";
     Keyword "New"        COMMENT = "Reserved.";
Keyword "Each"        COMMENT = "Reserved.";
     
	     Keyword "Try"        COMMENT = "Reserved.";
         Keyword "Catch"        COMMENT = "Reserved.";
        Keyword "Finally"        COMMENT = "Reserved.";
	
      Keyword "Form"        COMMENT = "";
      Keyword "FormClass"        COMMENT = "";
      Keyword "uiClass"        COMMENT = "";
      Keyword "Get"        COMMENT = "Reserved.";
      Keyword "Set"        COMMENT = "You may override the data type of an outlet pointing to an object of a ui file. See the manual for more information.";
                           EXAMPLE = ""
  ""
  "Outlet someWidgetInUIFile As myControl Set ' myControl is a widget class, which replaces the original class used by the ui file before it gets loaded\n"
  ""
  "";

    Keyword "UBound"        COMMENT = "UBound(VARIABLENAME [, Index])\n\nGetting upper bound of an array. LBound is used for the upper bound. ";
                             SEEALSO = "LBound";
                           EXAMPLE = ""
""
"Type book\n"
"  bkname As String \n"
"  isbn[1000] As Integer\n"
"End Type \n"
"\n"
"Type address\n"
"  books[50] As book\n"
"  age As Integer\n"
"  name As String \n"
"End Type \n"
"\n"
"Dim j[10] As book\n"
"\n"
"Sub Main()\n"
"  MsgBox(LBound(j, 1))\n"
"End Sub\n"
""
"";
    Keyword "LBound"        COMMENT = "LBound(VARIABLENAME [, Index])\n\nGetting lower bound of an array. LBound is used for the lower bound. ";
                             SEEALSO = "UBound";
                           EXAMPLE = ""
""
"Type book\n"
"  bkname As String \n"
"  isbn[1000] As Integer\n"
"End Type \n"
"\n"
"Type address\n"
"  books[50] As book\n"
"  age As Integer\n"
"  name As String \n"
"End Type \n"
"\n"
"Dim j[10] As book\n"
"\n"
"Sub Main()\n"
"  MsgBox(LBound(j, 1))\n"
"End Sub\n"
""
"";

    Keyword "ReDim"        COMMENT = "ReDim Preserve VARIABLENAME[ARRAY] [,VARIABLENAME[ARRAY]]... \n\nPreserve does not clear the array, when you change the size of the array by using ReDim. ";
                           EXAMPLE = ""
""
"Sub Main()\n"
"    \n"
"  Dim i[10] As Integer\n"
"  \n"
"  i[0] = 99\n"
"  i[1] = 88\n"
"  i[2] = 77\n"
"  i[3] = 66\n"
"  i[4] = 55\n"
"  i[5] = 44\n"
"  \n"
"  ReDim Preserve i[20]\n"
"  \n"
"  MsgBox(i[0])\n"
"  \n"
"End Sub\n"
""
"";
    Keyword "Preserve"        COMMENT = "ReDim Preserve VARIABLENAME[ARRAY] [,VARIABLENAME[ARRAY]]... \n\nPreserve does not clear the array, when you change the size of the array by using ReDim. ";
                             SEEALSO = "ReDim";
                           EXAMPLE = ""
""
"Sub Main()\n"
"    \n"
"  Dim i[10] As Integer\n"
"  \n"
"  i[0] = 99\n"
"  i[1] = 88\n"
"  i[2] = 77\n"
"  i[3] = 66\n"
"  i[4] = 55\n"
"  i[5] = 44\n"
"  \n"
"  ReDim Preserve i[20]\n"
"  \n"
"  MsgBox(i[0])\n"
"  \n"
"End Sub\n"
""
"";

    Keyword "Slot"        COMMENT = "Slot SLOTNAME(ARGUMENTS)...End Slot (Reserved.)";
    Keyword "Signal"        COMMENT = "Signal SIGNALNAME(ARGUMENTS)...End Signal\n\n The difference between events and signals is that events are overriding the super class event function, but signal uses the signal/slot feature of Qt to connect different objects.";

      Keyword "Outlet"        COMMENT = "Outlet variables point to objects of ui files. See the manual for more information.";

      Keyword "Module"        COMMENT = "Modules are usefull when you would like to organize functions and subs. A simple application can consist of only one form while the complete source code is in one form module. As your applications grow larger you probably would like to use the same code in different forms. To do so, place this code in a global module file as it is accessible by the entire application. You code is stored in classes or modules. You can archive your code within modules. Every module consists of the declaration part and the procedures you have inserted. A module can contain: Declarations - for variables, types, enumerations and constants; Procedures - which are not assigned to a special event or object.\nYou can create as many procedures as you want, e.g. sub-procedures without return value or function-procedures. You must not put several classes or modules in one file.\nSee the manual for more information. ";
                              SEEALSO = "Class";
                              EXAMPLE = ""
  ""
  "Dim Name As Type\n"
  "Public Name As Type\n"
  "Private Name As Type\n"
  "Const Name As Type\n"
  "Public Const Name As Type\n"
  "Private Const Name As Type\n"
  "...\n"
  "\n"
  "[Public | Private] \n"
  "Enum Name\n"
  "  Name As Type\n"
  "  ...\n"
  "End Enum\n"
  "...\n"
  "\n"
  "[Public | Private] \n"
  "Type Name\n"
  "  Name As Type\n"
  "  ...\n"
  "End Type\n"
  "...\n"
  "\n"
  "[Public | Private] \n"
  "Function Name([Arguments]) [As Type] [Throws Name, ...]\n"
  "  [Statements]\n"
  "End Function\n"
  "...\n"
  "\n"
  "[Public | Private] \n"
  "Sub Name([Arguments]) [Throws Name, ...]\n"
  "  [Statements]\n"
  "End Sub\n"
  "...\n"
  ""
  "";



    Keyword "True"        COMMENT = "The boolean literal used for the true value.";
                             SEEALSO = "False";

    Keyword "Enum"        COMMENT = "Enum ENUMNAME...End Enum\n\nIs a list of integer constants relating to the same subject.";
                           EXAMPLE = ""
""
"Enum Level\n"
"   Mo = -1\n"
"   Di = 0\n"
"   Fr = 1\n"
"   Sa = 1 + Fr And 2\n"
"End Enum\n"
"\n"
"Enum test\n"
"   Entry\n"
"   Entry2\n"
"   Security = Entry\n"
"End Enum\n"
"\n"
"Sub test()\n"
"  MsgBox(3 + Level.Mo)\n"
"  MsgBox(test.Entry)\n"
"  MsgBox(test.Security)\n"
"End Sub\n"
""
"";


    Keyword "Null"        COMMENT = "If a variable has the value 'Null', it points to nothing (no object). The data type 'id' is automatically used if you do not specifiy a data type for an argument, constant, procedure or variable. Variables of type 'id' can contain strings, dates, time values, boolean values or even numerical values. ";
                           EXAMPLE = ""
"Sub Main()\n"
"  Dim v As id\n"
"  v = Null\n"
"End Sub\n"
""
"";
    Keyword "False"        COMMENT = "The boolean literal used for the false value. ";
                             SEEALSO = "True";

    Keyword "Type"        COMMENT = "Type TYPENAME...End Type\n\nIs a way of storing many variables inside one variable. A user defined data type is very useful when object-orientated programming is not available. It is like a class, many different variables are held together but without methods. Many kind of data types are allowed inside a user defined data type, even other user defined data types can be included. ";
                           EXAMPLE = ""
""
"Type book\n"
"  bkname As String \n"
"  isbn[1000] As Integer\n"
"End Type \n"
"\n"
"Type address\n"
"  books[50] As book\n"
"  age As Integer\n"
"  name As String \n"
"End Type \n"
"\n"
"Dim j[10] As book\n"
"\n"
"Sub Main()\n"
"  MsgBox(LBound(j, 1))\n"
"End Sub\n"
""
"";

    Keyword "Property"        COMMENT = "Property Sub Name(Argument)...End Sub\nProperty Function Name()...End Function\n\nDefining a property is like defining a procedure. Most objects and controls have properties that you can think of as nothing more complicated than attributes. For example, a 'CommandButton' control has a property called 'Caption' that determines the text that appears in the button. Many other controls, such as the familiar 'Label' control, also have a 'Caption' property. Some properties are common whereas others are associated with only a single control or object. Those properties are built-in, but it is also possible to define your own properties within your user defined class.\nDefining a property is like defining a procedure. In fact, a property contains two property-procedures. One property-procedure reads the property (Get) and the other writes the property (Set). Additionally, you have to declare a variable that contains the value of the property. Why should I use a property, when I use a variable instead? It is easier to access a variable but it might be useful to check something when accessing a variable; with properties you are able to check values or conditions when you try to access the property. It is like data hiding. You can code so that the value of the property is always correct. ";
                              SEEALSO = "Class Sub Function";
                              EXAMPLE = ""
""
"' . operator     ! is direct access to dynamic properties of Qt\n"
"\n"
"Dim myVar2\n"
"Property Sub Set_myVar2(ToValue) \n"
"  MsgBox(\"Property Sub SetmyVar2(Set)\")\n"
"  myVar2 = ToValue\n"
"End Sub \n"
"\n"
"Property Function Get_myVar2() \n"
"  MsgBox(\"Property Function GetmyVar2()\")\n"
"  Return myVar2 \n"
"End Function \n"
""
"";

  Keyword "Class"        COMMENT = "Classes are needed, when you would like use (custom) objects. See the manual for more information.\n\nA simple application can contain a form, while all source code is inside the form module of that form. But if the application grows bigger and bigger it might be useful, to write source codes from different forms at one place, so you need a place to write the source codes down outside the forms. Here comes the classes. Create a class, which contains a methods, which is useful for your forms. You code is stored in classes or modules. You can archive your code within classes. Every class consists of the declaration part and the methods you have inserted. A class can contain:\n\nDeclarations - for variables, types, enumerations and constants;Methods (also called procedures) - which are not assigned to a special event or object. You can create as many procedures as you want, e.g. sub-procedures without return value or function-procedures;Signal/Slots-Methods - These are special methods;Events - Needed for overriding super class features;Properties - Are variables, which are accessed through two special methods (get and set method). Properties are accessable without the need to write braces, when you use them.\n\nYou must not put several classes or modules in one file.";
                           SEEALSO = "Module";
                           EXAMPLE = ""
""
"Dim Name As Type\n"
"Const Name As Type\n"
"\n"
"Public Name As Type\n"
"Private Name As Type\n"
"Public Const Name As Type\n"
"Private Const Name As Type\n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Enum Name\n"
"  Name As Type\n"
"  ...\n"
"End Enum\n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Type Name\n"
"  Name As Type\n"
"  ...\n"
"End Type\n"
"...\n"
"\n"
"\n"
"[Public | Private]  \n"
"Property Sub Name(Argument)\n"
"  [Statements]\n"
"End Sub\n"
"...\n"
"\n"
"[Public | Private]  \n"
"Property Function Name()\n"
"  [Statements]\n"
"End Function \n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Function Name([Arguments]) [As Type]\n"
"  [Statements]\n"
"End Function\n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Sub Name([Arguments])\n"
"  [Statements]\n"
"End Sub\n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Event Name([Arguments])\n"
"  [Statements]\n"
"End Event\n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Signal Name([Arguments])\n"
"  [Statements]\n"
"End Signal\n"
"...\n"
"\n"
"\n"
"[Public | Private] \n"
"Slot Name([Arguments])\n"
"  [Statements]\n"
"End Slot\n"
"...\n"
"\n"
""
"";

    Keyword "Alias"        COMMENT = "Declare statements: Used to extend the language and gain direct access to the Qt library or other C/C++ files of the current project.";
    Keyword "Declare"        COMMENT = "Used to extend the language and gain direct access to the Qt library or other C/C++ files of the current project.";


    Keyword "Event"        COMMENT = "Events are automatically called by the runtime. The difference between events and signals is that events are overriding the super class event function, but signal uses the signal/slot feature of Qt to connect different objects. ";
    Keyword "Dim"        COMMENT = "Dim VARIABLENAME[ARRAY] [As VARIABLETYPE] {[, VARIABLENAME[ARRAY] [As VARIABLETYPE]]}\n\n Before using variables, you must declare them. You must define the name and the data type of a variable. The 'Dim'-statement declares a variable. See the manual for more information.";
                             SEEALSO = "Const";

     Keyword "Exit"        COMMENT = "Exit For\n\nExplicit leave of for loop. Note: That Exit For works only within non-nested code. \n\nExit Do\n\nExplicit leave of do loop. Note: That Exit For works only within non-nested code. \n\nExit Sub\n\nExplicit leave of sub.\n\nExit Function\n\nExplicit leave of function.\n\nExit Event\n\nExplicit leave of event procedure.\n\nExit Signal\n\nExplicit leave of signal procedure.\n\nExit Slot\n\nExplicit leave of slot procedure. ";
                           EXAMPLE = ""
""
"Sub doingSomething()\n"
"  \n"
"  MsgBox(\"did something\")  \n"
"  \n"
"  Exit Sub\n"
"  \n"
"  MsgBox(\"end of sub\")\n"
"  \n"
"  For i As Integer = 1 To 11   \n"
"    Exit For\n"
"    MsgBox(\"xyz\")\n"
"  Next\n"
"\n"
"End Sub\n"
"\n"
"Function doingSomething2()\n"
"      \n"
"  MsgBox(\"did something\")\n"
"  \n"
"  Exit Function\n"
"  \n"
"  MsgBox(\"end of function\")\n"
"  \n"
"End Function\n"
""
"";
    Keyword "End"        COMMENT = "End Sub\nEnd Function\nEnd Type\nEnd Enum\nEnd Event\nEnd Type\nEnd Signal\nEnd Slot\nEnd If\nEnd Select\n\nIt is used to close the current sub, function or other language structure. See the list above. ";

    Keyword "Yes"        COMMENT = "The boolean literal used for the true value.";
                             SEEALSO = "No";

    Keyword "No"        COMMENT = "The boolean literal used for the false value.";
                             SEEALSO = "Yes";


  //addKeyword("Table"); achtung wenn keyword geht parser nicht mehr weil keyword anders gehandelt werden muss 
  //addKeyword("Query"); achtung wenn keyword geht parser nicht mehr weil keyword anders gehandelt werden muss 
  //addKeyword("Report");achtung wenn keyword geht parser nicht mehr weil keyword anders gehandelt werden muss  
  
    
    Keyword "Then"      COMMENT = "";


    Keyword "<string>"        COMMENT = "";
    Keyword "</string>"        COMMENT = "";
    Keyword "Super"        COMMENT = "Reserved.";
    Keyword "SuperClass"        COMMENT = "";
    

    Keyword "Is"        COMMENT = "Select Case EXPRESSION...Case Is OPERATOR EXPRESSION...End Select\n\nUsed in a select case statement for comparision.";



    Keyword "Const"        COMMENT = "Const NAME [As TYPE] = EXPRESSION\n\nDeclares a constants.\nConstants are similar to variables but they cannot change values. When you declare a constant you assign a value to it that annot be altered during lifetime of your program. ";
                           SEEALSO = "Dim";
                           EXAMPLE = ""
""
"Sub Namer() \n"
"  Const pi = 3.14 \n"
"  MsgBox(pi)  \n"
"End Sub\n"
"\n"
"Sub test\n"
"  Dim k As Integer\n"
"  \n"
"  k = 9 + 23\n"
"  MsgBox(k) \n"
"End Sub\n"
"\n"
"Const a = 123.88 * 2, bb = 6\n"
"Const k As Integer = 2 \n"
"\n"
"Sub test2()\n"
"  Dim i As Double\n"
"  i = bb\n"
"  test\n"
"  'a = i ' would cause a parser error\n"
"End Sub\n"
""
"";

    Keyword "As"        COMMENT = "Dim VARIABLENAME As VARIABLETYPE\nSub SUBNAME(ByRef VARIABLENAME As VARIABLETYPE)\n\n It is used whenever you declare variables. After As, you write the type of the variable you currently declare. See the manual for more information on this. ";
                           SEEALSO = "Dim";

    Keyword "Mid"        COMMENT = "Mid(STRINGVARIABLE, Position As Integer, Length As Integer) = {STRINGEXPRESSION | ASCII-Code}\n\nReplaces text inside a string by another text. ";
                           EXAMPLE = ""
""
"Sub Main()\n"
"  Dim txt As String, replacement As String, originaltxt As String\n"
"\n"
"  replacement = \"The power of Q7Basic\"\n"
"  originaltxt = \"***********************\"\n"
"   Dim i As Integer\n"
"   For i = 1 To Len(replacement)\n"
"    Mid(originaltxt, 2, i) = replacement\n"
"    MsgBox(originaltxt)\n"
"  Next\n"
"End Sub\n"
""
"";

    Keyword "Private"        COMMENT = "Private VARIABLENAME[ARRAY] [As VARIABLETYPE] [, VARIABLENAME[ARRAY] [As VARIABLETYPE]]\n\nBefore using variables, you must declare them. You must define the name and the data type of a variable. Use of the 'Private'-Statement Use the 'Private'-statement to declare private variables in module scope or class scope, making the variable accessible only from the same scope (module scope, all module procedures, class scope, all class methods)\nSee the manual for more information.";
                             SEEALSO = "Class Module Dim Public Global";

bool b = false;

b = true;


if (b){
    Keyword "GoTo"        COMMENT = "GoTo LABEL\n\nUnconditional jumping\nProgrammers can also use unconditional branches. This type of branching can be performed using the 'GoTo'-instruction. 'GoTo' forces program execution to branch to a specific line number or label. Because line numbers are now obsolete, you do not have to worry about how to use them. You may, however, want to use labels. 'GoTo' performs a unconditional jump. 'GoTo' is always executed, without a condition. ";
                           EXAMPLE = ""
""
"Sub test()\n"
"  Dim b As Integer\n"
"  Dim n As Integer\n"
"\n"
"  b = 45\n"
"  GoTo bernd\n"
"  b = 99999\n"
"  bernd:\n"
"\n"
"  n = 0\n"
"  ok:\n"
"  n = n + 1\n"
"  If n < 5 Then GoTo ok\n"
"End Sub\n"
""
"";
}

    Keyword "Public"        COMMENT = "Public VARIABLENAME[ARRAY] [As VARIABLETYPE] [, VARIABLENAME[ARRAY] [As VARIABLETYPE]]\n\nYou can use the 'Public'-statement to declare public variables in module scope or class scope, making the variable accessible from everywhere. \nSee the manual for more information.";
                             SEEALSO = "Class Module Dim Private Global";
    Keyword "Static"        COMMENT = "Static Dim VARIABLENAME[ARRAY] [As VARIABLETYPE] [, VARIABLENAME[ARRAY] [As VARIABLETYPE]]\n\nBefore using variables, you must declare them. You must define the name and the data type of a variable. Static is a modifier to declare variables with a special feature: Static outside a class, but inside a procedure (sub or function) or method. If you use a 'Static'-statement instead of a 'Dim'-statement, the variable is declared as local static variable. The variable, once it has been declared, it is not destroyed by leaving the procedure. The next time the procedure is entered, the value of the variable still exists. Therefore, a local static variable is only one time declared when using recursive calls of a procedure. ";
                           EXAMPLE = ""
""
"Sub test()\n"
"  Static Dim i As Integer = 0 \n"
"  MsgBox(i)\n"
"  i = i + 1 ' this value is not lost after the sub exited\n"
"End Sub\n"
"\n"
"Sub Main()\n"
"  test()\n"
"  test()\n"
"  test()\n"
"End Sub\n"
""
"";

    Keyword "Select"        COMMENT = "Select Case EXPRESSION...Case EXPRESSION...End Select\nSelect Case EXPRESSION...Case EXPRESSION To EXPRESSION...End Select\nSelect Case EXPRESSION...Case Is OPERATOR EXPRESSION...End Select\nSelect Case EXPRESSION...Case Else...End Select\n\n It is used for Select Case, which introduces a multi-line conditional selection statement. ";
                             SEEALSO = "Case";
                           EXAMPLE = ""
""
"Dim i As Double\n"
"Dim n As Integer\n"
"\n"
"i = 4\n"
"\n"
"Select Case i\n"
"Case 0\n"
"  n = 0\n"
"Case 1, 2\n"
"  n = 1122\n"
"Case 4 To 10\n"
"  n = 441000\n"
"Case Is = 9\n"
"  n = 9999\n"
"Case Else\n"
"  n = 999999\n"
"End Select\n"
""
"";

    Keyword "Case"        COMMENT = "Select Case EXPRESSION...Case EXPRESSION...End Select\nSelect Case EXPRESSION...Case EXPRESSION To EXPRESSION...End Select\nSelect Case EXPRESSION...Case Is OPERATOR EXPRESSION...End Select\nSelect Case EXPRESSION...Case Else...End Select\n\n It is used for Select Case, which introduces a multi-line conditional selection statement. ";
                             SEEALSO = "Select";
                           EXAMPLE = ""
""
"Dim i As Double\n"
"Dim n As Integer\n"
"\n"
"i = 4\n"
"\n"
"Select Case i\n"
"Case 0\n"
"  n = 0\n"
"Case 1, 2\n"
"  n = 1122\n"
"Case 4 To 10\n"
"  n = 441000\n"
"Case Is = 9\n"
"  n = 9999\n"
"Case Else\n"
"  n = 999999\n"
"End Select\n"
""
"";

    Keyword "Me"        COMMENT = "Use current instance or object. The keyword 'Me' references the current instance (or object) in which the code is currently executed. Normally it is the current class (user defined class or form class).";
    Keyword "Var"        COMMENT = "Var is an alias for Dim";
                             SEEALSO = "Var";


    Keyword "If"        COMMENT = "A single decision is used to execute a set of statements if a condition is set ('If'-statement). If the condition is 'True' then the statements after the 'Then' are executed and the statements after the 'Else' are skipped. If the condition is 'False', the statements after the 'Else' are executed.";
                             SEEALSO = "Then Else";
    Keyword "Then"        COMMENT = "If EXPRESSION Then...Else If EXPRESSION...Else...End If\n\nA single decision is used to execute a set of statements if a condition is set ('If'-statement). If the condition is 'True' then the statements after the 'Then' are executed and the statements after the 'Else' are skipped. If the condition is 'False', the statements after the 'Else' are executed. ";
                           EXAMPLE = ""
""
"Dim i As Integer\n"
"Dim n As Integer \n"
"\n"
"If i 1 Then \n"
"  n = 11111 \n"
"Else If i = 2 * 10 Then\n"
"  n = 22222 \n"
"Else \n"
"  n = 33333 \n"
"End If\n"
""
"";

    Keyword "Global"        COMMENT = "Global Dim VARIABLENAME [As VARIABLETYPE] [= EXPRESSION]\n\nUnlike other variables and procedures of a file, global variables and procedures can be access just by its name only.";
                             SEEALSO = "Dim Public";
    Keyword "Else"        COMMENT = "If EXPRESSION Then...Else If EXPRESSION...Else...End If\n\nA single decision is used to execute a set of statements if a condition is set ('If'-statement). If the condition is 'True' then the statements after the 'Then' are executed and the statements after the 'Else' are skipped. If the condition is 'False', the statements after the 'Else' are executed.";
                             SEEALSO = "If";
                           EXAMPLE = ""
""
"Dim i As Integer\n"
"Dim n As Integer \n"
"\n"
"If i 1 Then \n"
"  n = 11111 \n"
"Else If i = 2 * 10 Then\n"
"  n = 22222 \n"
"Else \n"
"  n = 33333 \n"
"End If\n"
""
"";


    Keyword "Iterate"        COMMENT = "Iterate For\n\nManually test loop condition for a 'For'-loop. Note: That Iterate For works only within non-nested code. \n\nIterate Do\n\nManually test loop condition of a 'Do'-loop. Note: That Iterate Do works only within non-nested code. ";

    Keyword "Sub"        COMMENT = "Sub SUBNAME(ARGUMENTS)...End Sub\n\nIs a part of your program containing commands. A sub-procedure can have arguments, variables, expressions, or constants that are given to the sub-procedure when calling it.  ";
                             SEEALSO = "Function";
                           EXAMPLE = ""
""
"' sub example\n"
"\n"
"Sub theMusic()\n"
"  MsgBox(\"represents cuba\")\n"
"  MsgBox(\"your hips make a shift...\")\n"
"  MsgBox(\"I'm the one to find you in the mood...\")\n"
"  MsgBox(\"CUBA!\")\n"
"  MsgBox(\"represents cuba\")\n"
"  MsgBox(\"represents cuba\")\n"
"End Sub\n"
"\n"
"Sub Main()\n"
"  theMusic() ' first use of sub \n"
"  theMusic() ' 2nd use \n"
"  theMusic() ' 3rd use \n"
"End Sub\n"
""
"";

    Keyword "Function"        COMMENT = "Function NAME([ARGUMENTS]) [As RETURNTYPE]...End Function\n\nIs a part of a program, returning a value depending on calculation inside the function. A function-procedure can have arguments, variables, expressions, or constants that are given to it when it get called. Function-procedures return values. ";
                             SEEALSO = "Sub";
                           EXAMPLE = ""
""
"' function example\n"
"\n"
"Function divide(dividend As Float, divisor As Float) As Float\n"
"  \n"
"  Return dividend / divisor\n"
"  \n"
"End Function\n"
"\n"
"Sub Main()\n"
"  MsgBox(divide(18, 9))\n"
"End Sub\n"
""
"";

    Keyword "Next"        COMMENT = "For VARIABLENAME = EXPRESSION To EXPRESSION [Step EXPRESSION]\nNext\n\nThe statements that control decisions and loops are called control structures. Normally every command is executed only one time but in many cases it may be useful to run a command several times until a defined state has been reached. Loops repeat commands depending upon a condition. Some loops repeat commands while a condition is 'True', other loops repeat commands while a condition is 'False'. There are other loops repeating a fixed number of times and some repeat for all elements of a collection. The For-Next loop is useful when you know how often statements should be repeated. For-Next defines a loop that runs a specified number of times. ";
                             SEEALSO = "For";
                           EXAMPLE = ""
""
"Dim ctr As Integer\n"
"\n"
"For ctr = 1 To 5 \n"
"  MsgBox(\"Z\", i) \n"
"Next\n"
""
"";

    Keyword "For"        COMMENT = "For VARIABLENAME = EXPRESSION To EXPRESSION [Step EXPRESSION]\nNext\n\nThe statements that control decisions and loops are called control structures. Normally every command is executed only one time but in many cases it may be useful to run a command several times until a defined state has been reached. Loops repeat commands depending upon a condition. Some loops repeat commands while a condition is 'True', other loops repeat commands while a condition is 'False'. There are other loops repeating a fixed number of times and some repeat for all elements of a collection. The For-Next loop is useful when you know how often statements should be repeated. For-Next defines a loop that runs a specified number of times. ";
                             SEEALSO = "Next";
                           EXAMPLE = ""
""
"Dim ctr As Integer\n"
"\n"
"For ctr = 1 To 5 \n"
"  MsgBox(\"Z\", i) \n"
"Next\n"
""
"";

    Keyword "To"        COMMENT = "For VARIABLENAME = EXPRESSION To EXPRESSION [Step EXPRESSION]\nNext\n\nThe statements that control decisions and loops are called control structures. Normally every command is executed only one time but in many cases it may be useful to run a command several times until a defined state has been reached. Loops repeat commands depending upon a condition. Some loops repeat commands while a condition is 'True', other loops repeat commands while a condition is 'False'. There are other loops repeating a fixed number of times and some repeat for all elements of a collection. The For-Next loop is useful when you know how often statements should be repeated. For-Next defines a loop that runs a specified number of times. ";
                           EXAMPLE = ""
""
"Dim ctr As Integer\n"
"\n"
"For ctr = 1 To 5 \n"
"  MsgBox(\"Z\", i) \n"
"Next\n"
""
"";

    Keyword "Step"        COMMENT = "Enables you to control the value of increment or decrement of a loop counter variable of a For-Next-Loop.";
    Keyword "Do"        COMMENT = "Do...Loop Until EXPRESSION\nDo While EXPRESSION...Loop\n\nLoop-statements\n\nThe statements that control decisions and loops in are called control structures. Normally every command is executed only one time but in many cases it may be useful to run a command several times until a defined state has been reached. Loops repeat commands depending upon a condition. Some loops repeat commands while a condition is 'True,' other loops repeat commands while a condition is 'False.' There are other loops repeating a fixed number of times and some repeat for all elements of a collection.\nThere are two different ways to use the keyword 'Do' in order to test a condition within a 'Do...Loop'-statement. You can test the condition before the commands inside the loop are executed or you can test the condition after the commands of the loop have been executed at least once. If the condition is 'True' ( in the following procedure 'SubBefore') the commands inside the loop execute. ";
                           EXAMPLE = ""
""
"Sub SubBefore()\n"
"  Counter = 0\n"
"  myNumber = 20\n"
"  Do While myNumber > 10\n"
"    myNumber = myNumber - 1\n"
"    Counter = Counter + 1\n"
"  Loop\n"
"  MsgBox(\"Loop has been executed \" & Counter & \" time(s).\")\n"
"End Sub\n"
"\n"
"Sub SubAfter()\n"
"  Counter = 0\n"
"  myNumber = 9\n"
"  Do\n"
"    myNumber = myNumber - 1\n"
"    Counter = Counter + 1\n"
"  Loop While myNumber > 10\n"
"  MsgBox(\"Loop has been executed \" & Counter & \" time(s).\")\n"
"End Sub\n"
""
"";

    Keyword "While"        COMMENT = "While...End While\n\nDo While EXPRESSION\nLoop\n\nLoop-statement. See Do fore more information.";
    Keyword "Until"        COMMENT = "Do\nLoop Until EXPRESSION\nDo While EXPRESSION\nLoop\n\nThe statements that control decisions and loops are called control structures. Normally every command is executed only one time but in many cases it may be useful to run a command several times until a defined state has been reached. Loops repeat commands depending upon a condition. Some loops repeat commands while a condition is 'True,' other loops repeat commands while a condition is 'False.' There are other loops repeating a fixed number of times and some repeat for all elements of a collection.\nUse the following loops when you are not sure how often a command should be repeated: 'Do', 'While', 'Loop'or 'Until'. There are two different ways to use the keyword 'While' in order to test a condition within a 'Do\nLoop'-statement. You can test the condition before the commands inside the loop are executed or you can test the condition after the commands of the loop have been executed at least once. If the condition is 'True' ( in the following procedure 'SubBefore') the commands inside the loop execute. ";
                           EXAMPLE = ""
"Sub SubBefore()\n"
"  Counter = 0\n"
"  myNumber = 20\n"
"  Do While myNumber > 10\n"
"    myNumber = myNumber - 1\n"
"    Counter = Counter + 1\n"
"  Loop\n"
"  MsgBox(\"Loop has been executed \" & Counter & \" time(s).\")\n"
"End Sub\n"
"\n"
"Sub SubAfter()\n"
"  Counter = 0\n"
"  myNumber = 9\n"
"  Do\n"
"    myNumber = myNumber - 1\n"
"    Counter = Counter + 1\n"
"  Loop While myNumber > 10\n"
"  MsgBox(\"Loop has been executed \" & Counter & \" time(s).\")\n"
"End Sub\n"
""
"";

    Keyword "Loop"        COMMENT = "Do\nLoop Until EXPRESSION\nDo While EXPRESSION\nLoop\n\nLoop-statements. See Do fore more information.";
    Keyword "Break"        COMMENT = "Immediatily leaves the current loop.";
    Keyword "Continue"        COMMENT = "Immediatily tests loop condition of the current loop.";
    Keyword "Return"        COMMENT = "Return [EXPRESSION]\n\nReturns a value (for functions only) and leaves the current function/sub.";
    Keyword "IIf"        COMMENT = "IIf(EXPRESSION, THENRETURNEXPRESSION, ELSERETURNEXPRESSION)\n\nIIf returns a value of two values depending on an expression.  ";
                           EXAMPLE = ""
""
"Function testing(Test1 As Integer) As String\n"
"  Return IIf(Test1 > 1000, \"big\", \"small\")\n"
"End Function\n"
"\n"
"Sub Main()\n"
"  MsgBox(testing(5))\n"
"  MsgBox(testing(5555))\n"
"End Sub\n"
""
"";

    Keyword "ByVal"        COMMENT = "Sub SUBNAME(ByVal VARIABLENAME As VARIABLETYPE)\n\nDefines the given variable to the sub or function, to be handled by value. This means, that chaning the value of this varialbe DOES NOT affect the original variable as well. See the manual for more information on this. ";
    Keyword "ByRef"        COMMENT = "Sub SUBNAME(ByRef VARIABLENAME As VARIABLETYPE)\n\nDefines the given variable to the sub or function, to be handled by reference. This means, that chaning the value of this varialbe affects the original variable as well. See the manual for more information on this.";

#ifdef BERND



  //addKeyword("BUG");

  //addKeyword("Debug");
  //addKeyword("File");
  //addKeyword("Info");
  //addKeyword("Type");
  //addKeyword("StatusItem");
  //addKeyword("DrawText");
 //addKeyword("Log");
  //addKeyword("Alert");


  addKeyword("Super");  
  addKeyword("Class");   

  addKeyword("Alias"); 
  addKeyword("Declare"); 

  addKeyword("Enum"); 


#endif 

    // ----------------------------------------------------------------------------------------------------------------------------
  }

  Me.keywords.sort();

}



#undef COMMENT
#undef EXAMPLE
#undef SEEALSO
#undef Keyword




#include "_Q7BCompiler.h"


#define COMMENT ;Parser::doComment(CLASS,SUPERCLASS,SUBFUNCTION,lAlias,sType,l,sGROUP,sSEEALSO,sCOMMENT,sCLASSCOMMENT,sEXAMPLE,bProperty,bEvent,bSignal,bDelegate,Me.comments_objects, Me.objects_properties,Me.objects_subsfunctions, Me.objects_events, Me.objects_signals, Me.objects_delegates, Me.objects_declare_events_signals_delegates, Me.objects_declarecast_events_signals_delegates, Me.objects_declarecode_events_signals_delegates, Me.objects_declaretype_events_signals_delegates, sDeclare, sCast, sCode);Me.comments_objects[CLASS][SUBFUNCTION]._COMMENT


#define CLASSCOMMENT ;Me.comments_objects[CLASS][""]._COMMENT

#define Property ;bProperty=true;SUBFUNCTION=
#define As ;sType=
#define Declare ;sCast="";sDeclare=
#define Cast ;sCast=
#define Code ;sCode=

#define Object ;SUPERCLASS="";CLASS=
#define End_Object ;Me.objects[CLASS]=SUPERCLASS;
#define SuperClass ;SUPERCLASS=

#define SEEALSO ;sSEEALSO
#define EXAMPLE ;sEXAMPLE

#define Function ;sType="";SUBFUNCTION=
#define Sub ;sType="";SUBFUNCTION=
#define Event ;bEvent=true;sType="";SUBFUNCTION=
#define Signal ;bSignal=true;sType="";SUBFUNCTION=
#define Delegate ;bDelegate=true;sType="";SUBFUNCTION=

#define ___ ;l<<Parser::SubFunction
#define As ;sType=
#define Alias ;lAlias<<

void Parser::CreateListOfObjects()
{    
  
  QString CLASS;
  QString SUPERCLASS;
  QString SUBFUNCTION;
  QStringList lAlias; 
  QString sType;
  QString sDeclare;
  QString sCast;
  QString sCode;
  QStringList l;

  QString sGROUP;
  QString sSEEALSO;
  QString sCOMMENT;
  QString sEXAMPLE;
  QString sCLASSCOMMENT;  

  bool bProperty = false;
  bool bEvent = false;
  bool bSignal = false;
  bool bDelegate = false;

  
  if (Me.objects_properties.size() == 0){    
    




    


    // ----------------------------------------------------------------------------------------------------------------------------

    Object "Global"

    End_Object

    

    Object "OS"

      Function "IsMac"___("") As "Boolean";   COMMENT = "";
      Function "IsWindows"___("") As "Boolean";   COMMENT = "";
      Function "IsLinux"___("") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "Debug" // this functions are fake functions and are handled by the parser 
  
      Function "Line"___("") As "String";   COMMENT = "";
      Function "ClassName"___("") As "String";   COMMENT = "";
      Function "SuperClassName"___("") As "String";   COMMENT = "";
      Function "File"___("") As "String";   COMMENT = "";
      Function "Scope"___("") As "String";   COMMENT = "";
      Function "Info"___("") As "String";   COMMENT = "";

    End_Object

    

    Object "File"
  
      Function "Size"___("FileName As String") As "Integer";   COMMENT = "";
      Function "Truncate"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "Create"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "Remove"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "Exists"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "DateTimeCreated"___("FileName As String") As "String";   COMMENT = "";
      Function "DateTimeUpdated"___("FileName As String") As "String";   COMMENT = "";
      Function "DateTimeRead"___("FileName As String") As "String";   COMMENT = "";
      Function "Owner"___("FileName As String") As "String";   COMMENT = "";
      Function "Group"___("FileName As String") As "String";   COMMENT = "";
      Function "IsHidden"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "IsFile"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "IsDir"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "IsRelative"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "IsSymLink"___("FileName As String") As "Boolean";   COMMENT = "";
      Function "WithNativeSeparators"___("FileName As String") As "String";   COMMENT = "";
      Function "WithoutNativeSeparators"___("FileName As String") As "String";   COMMENT = "";
      Function "SymLinkTarget"___("FileName As String") As "String";   COMMENT = "";

      Function "Resize"___("FileName As String, NewSize As Integer") As "Boolean";   COMMENT = "";
      Function "Link"___("SourceFileName As String, DestinationFileName As String") As "Boolean";   COMMENT = "";
      Function "IsReadable"___("FileName As String, Who As String") As "Boolean";   COMMENT = "";
      Function "IsWritable"___("FileName As String, Who As String") As "Boolean";   COMMENT = "";
      Function "IsExecutable"___("FileName As String, Who As String") As "Boolean";   COMMENT = "";

      Function "Copy"___("SourceFileName As String, DestinationFileName As String, Overwrite As Boolean = True") As "Boolean";   COMMENT = "";
      Function "Move"___("SourceFileName As String, DestinationFileName As String, Overwrite As Boolean = True") As "Boolean";   COMMENT = "";
      Function "Rename"___("SourceFileName As String, DestinationFileName As String, Overwrite As Boolean = True") As "Boolean";   COMMENT = "";

      Function "ReadString"___("FileName As String, Codec As String, AutoDetectUnicode As Boolean = True, GenerateByteOrderMark As Boolean = True") As "String";   COMMENT = "";
      Function "WriteString"___("Text As String, FileName As String, Append As Boolean = False, Codec As String = \"UTF-8\", AutoDetectUnicode As Boolean = True, GenerateByteOrderMark As Boolean = True") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "Preferences"
  
      Sub      "RemoveAll"___("");   COMMENT = "";
      Function "Ids"___("") As "List";   COMMENT = "";

      Function "Exists"___("PreferenceId As String") As "Boolean";   COMMENT = "";
      Function "Remove"___("PreferenceId As String") As "Boolean";   COMMENT = "";
      Function "Boolean"___("PreferenceId As String") As "Boolean";   COMMENT = "";
      Function "Integer"___("PreferenceId As String") As "Integer";   COMMENT = "";
      Function "String"___("PreferenceId As String") As "String";   COMMENT = "";
      Function "QStringList"___("PreferenceId As String") As "QStringList";   COMMENT = "";
      Function "Float"___("PreferenceId As String") As "String";   COMMENT = "";
      Function "QByteArray"___("PreferenceId As String") As "QByteArray";   COMMENT = "";

      Sub      "SetBoolean"___("PreferenceId As String, Value As Boolean");   COMMENT = "";
      Sub      "SetInteger"___("PreferenceId As String, Value As Integer");   COMMENT = "";
      Sub      "SetString"___("PreferenceId As String, Value As String");   COMMENT = "";
      Sub      "SetQStringList"___("PreferenceId As String, Value As QStringList");   COMMENT = "";
      Sub      "SetFloat"___("PreferenceId As String, Value As Float");   COMMENT = "";
      Sub      "SetQByteArray"___("PreferenceId As String, Value As QByteArray");   COMMENT = "";

    End_Object

    

    Object "CMath"
  
      Function "sin"___("Argument As Float") As "Float";   COMMENT = "";
      Function "cos"___("Argument As Float") As "Float";   COMMENT = "";
      Function "tan"___("Argument As Float") As "Float";   COMMENT = "";
      Function "asin"___("Argument As Float") As "Float";   COMMENT = "Result is in [-pi/2,pi/2]";
      Function "acos"___("Argument As Float") As "Float";   COMMENT = "Result is in [0,pi]";
      Function "atan"___("Argument As Float") As "Float";   COMMENT = "Result is in [-pi/2,pi/2]";
      Function "atan2"___("x As Float, y As Float") As "Float";   COMMENT = "Determines the arc tangent of y/x in [-pi,pi] using the sign of both arguments to determine the quadrant";
      Function "sinh"___("Argument As Float") As "Float";   COMMENT = "";
      Function "cosh"___("Argument As Float") As "Float";   COMMENT = "";
      Function "tanh"___("Argument As Float") As "Float";   COMMENT = "";
      Function "exp"___("Argument As Float") As "Float";   COMMENT = "";
      Function "log"___("Argument As Float") As "Float";   COMMENT = "";
      Function "log10"___("Argument As Float") As "Float";   COMMENT = "";
      Function "sqrt"___("Argument As Float") As "Float";   COMMENT = "";
      Function "ceil"___("Argument As Float") As "Float";   COMMENT = "";
      Function "floor"___("Argument As Float") As "Float";   COMMENT = "";
      Function "fabs"___("Argument As Float") As "Float";   COMMENT = "";
      Function "fmod"___("x As Float, y As Float") As "Float";   COMMENT = "";
      Function "pow"___("x As Float, y As Float") As "Float";   COMMENT = "Returns x raised to the power of y";

    End_Object

    

    Object "Dir"
  
      Function "RootPath"___("") As "String";   COMMENT = "";
      Function "TempPath"___("") As "String";   COMMENT = "";
      Function "ApplicationsPath"___("") As "String";   COMMENT = "";
      Function "HomePath"___("") As "String";   COMMENT = "";
      Function "DesktopPath"___("") As "String";   COMMENT = "";
      Function "Create"___("Path As String") As "Boolean";   COMMENT = "";
      Function "RecursiveCreate"___("Path As String") As "Boolean";   COMMENT = "";
      Function "Remove"___("Path As String") As "Boolean";   COMMENT = "";
      Function "RecursiveRemove"___("Path As String") As "Boolean";   COMMENT = "";
      Function "Exists"___("Path As String") As "Boolean";   COMMENT = "";
      Function "List"___("Path As String") As "List";   COMMENT = "";

      Function "FindFile"___("Path As String, NameFilter As List, Filter As Integer = Dir.NoFilter, Sorting As Integer = Dir.NoSort") As "List";   COMMENT = "";
      Function "RecursiveFindFile"___("Path As String, NameFilter As List, Filter As Integer = Dir.NoFilter, Sorting As Integer = Dir.NoSort") As "List";   COMMENT = "";
      Function "RecursiveList"___("Path As String") As "List";   COMMENT = "";
      Function "Copy"___("SourcePath As String, DestinationPath As String") As "List";   COMMENT = "";
      Function "Move"___("SourcePath As String, DestinationPath As String") As "List";   COMMENT = "";

      Function "DateTimeCreated"___("Path As String") As "String";   COMMENT = "";
      Function "DateTimeUpdated"___("Path As String") As "String";   COMMENT = "";
      Function "DateTimeRead"___("Path As String") As "String";   COMMENT = "";
      Function "Owner"___("Path As String") As "String";   COMMENT = "";
      Function "Group"___("Path As String") As "String";   COMMENT = "";

      Function "IsReadable"___("Path As String, Who As String") As "Boolean";   COMMENT = "";
      Function "IsWritable"___("Path As String, Who As String") As "Boolean";   COMMENT = "";
      Function "IsExecutable"___("Path As String, Who As String") As "Boolean";   COMMENT = "";
      Function "IsHidden"___("Path As String") As "Boolean";   COMMENT = "";
      Function "IsDir"___("Path As String") As "Boolean";   COMMENT = "";
      Function "Drives"___("") As "List";   COMMENT = "";

      Function "WithNativeSeparators"___("Path As String") As "String";   COMMENT = "";
      Function "WithoutNativeSeparators"___("Path As String") As "String";   COMMENT = "";
      Function "BundleName"___("Path As String") As "String";   COMMENT = "";
      Function "BundleName"___("Path As String") As "String";   COMMENT = "";
      Function "SymLinkTarget"___("Path As String") As "String";   COMMENT = "";

      Function "IsRoot"___("Path As String") As "Boolean";   COMMENT = "";
      Function "IsRelative"___("Path As String") As "Boolean";   COMMENT = "";
      Function "IsSymLink"___("Path As String") As "Boolean";   COMMENT = "";
      Function "IsBundle"___("Path As String") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "Database" SuperClass "QObject"
  
      Function "MySQL"___("") As "String";   COMMENT = "";
      Function "PostgreSQL"___("") As "String";   COMMENT = "";
      Function "SQLite"___("") As "String";   COMMENT = "";

      Function "LocalHost"___("") As "String";   COMMENT = "";
      Function "DefaultPort"___("") As "String";   COMMENT = "";
      Function "DefaultOptions"___("") As "String";   COMMENT = "";
      Function "SetCurrentDatabase"___("Name As String") As "Boolean";   COMMENT = "";
      Function "CurrentDatabase"___("") As "String";   COMMENT = "";

      Function "Exists"___("Driver As String, Name As String, User As String, Password As String, Host As String = Database.LocalHost, Options As String = Database.DefaultOptions, Port As String = Database.DefaultPort") As "Boolean";   COMMENT = "";
      Function "Create"___("Driver As String, Name As String, User As String, Password As String, Host As String = Database.LocalHost, Options As String = Database.DefaultOptions, Port As String = Database.DefaultPort") As "Boolean";   COMMENT = "";
      Function "TestConnection"___("Driver As String, User As String, Password As String, Host As String = Database.LocalHost, Options As String = Database.DefaultOptions, Port As String = Database.DefaultPort") As "String";   COMMENT = "";
      Function "Empty"___("Driver As String, Name As String, User As String, Password As String, Host As String = Database.LocalHost, Options As String = Database.DefaultOptions, Port As String = Database.DefaultPort") As "Boolean";   COMMENT = "";
      Function "Drop"___("Driver As String, Name As String, User As String, Password As String, Host As String = Database.LocalHost, Options As String = Database.DefaultOptions, Port As String = Database.DefaultPort") As "Boolean";   COMMENT = "";

      Function "OpenSQLite"___("Name As String") As "Boolean";   COMMENT = "";

      Function "Open"___("Driver As String, Name As String, User As String, Password As String, Host As String = Database.LocalHost, Options As String = Database.DefaultOptions, Port As String = Database.DefaultPort") As "Boolean";   COMMENT = "";
      Function "Close"___("Name As String = \"\"") As "Boolean";   COMMENT = "";
      Function "IsOpen"___("Name As String = \"\"") As "Boolean";   COMMENT = "";

      Function "LastSQLError"___("Name As String = \"\"") As "Boolean";   COMMENT = "";
      Function "LastSQLCommands"___("Name As String = \"\"") As "Boolean";   COMMENT = "";
      Function "LastSQLCommandFailed"___("Name As String = \"\"") As "Boolean";   COMMENT = "";

      Function "IsTransactionSupported"___("Name As String = \"\"") As "Boolean";   COMMENT = "";
      Function "Transaction"___("Name As String = \"\"") As "Boolean";   COMMENT = "";
      Function "Commit"___("Name As String = \"\"") As "Boolean";   COMMENT = "";
      Function "Rollback"___("Name As String = \"\"") As "Boolean";   COMMENT = "";

      Function "Tables"___("Name As String = \"\"") As "List";   COMMENT = "";
      Function "Drivers"___() As "List";   COMMENT = "";

    End_Object

    

    Object "Table" SuperClass "QObject"
  
      Function "Exists"___("Table As String") As "Boolean";   COMMENT = "";
      Function "Exists2"___("Database As String, Table As String") As "Boolean";   COMMENT = "";

      Function "Create"___("Table As String, Fields As Dictionary") As "Boolean";   COMMENT = "";
      Function "Create2"___("Database As String, Table As String, Fields As Dictionary") As "Boolean";   COMMENT = "";

      Function "Empty"___("Table As String") As "Boolean";   COMMENT = "";
      Function "Empty2"___("Database As String, Table As String") As "Boolean";   COMMENT = "";

      Function "Drop"___("Table As String") As "Boolean";   COMMENT = "";
      Function "Drop2"___("Database As String, Table As String") As "Boolean";   COMMENT = "";

      Function "Delete"___("Table As String, Where As Dictionary") As "Boolean";   COMMENT = "";
      Function "Delete2"___("Database As String, Table As String, Where As Dictionary") As "Boolean";   COMMENT = "";

      Function "Update"___("Table As String, Update As Dictionary, Where As Dictionary") As "Boolean";   COMMENT = "";
      Function "Update2"___("Database As String, Table As String, Update As Dictionary, Where As Dictionary") As "Boolean";   COMMENT = "";

      Function "Insert"___("Table As String, Insert As Dictionary") As "Boolean";   COMMENT = "";
      Function "Insert2"___("Database As String, Table As String, Insert As Dictionary") As "Boolean";   COMMENT = "";

      Function "FieldNames"___("Table As String") As "List";   COMMENT = "";
      Function "FieldNames2"___("Database As String, Table As String") As "List";   COMMENT = "";

      Function "PrimaryKeyName"___("Table As String") As "String";   COMMENT = "";
      Function "PrimaryKeyName2"___("Database As String, Table As String") As "String";   COMMENT = "";

    End_Object

    

    Object "Records" SuperClass "QObject"
  
      Function "Open"___("TableOrSql As String") As "String";   COMMENT = "";
      Function "Open2"___("Database As String, TableOrSql As String") As "String";   COMMENT = "";
      Function "Open3"___("DTable As String, Where As Dictionary") As "String";   COMMENT = "";
      Function "Open4"___("Database As String, Table As String, Where As Dictionary") As "String";   COMMENT = "";
      Function "Open5"___("Table As String, Where As Dictionary, OrderBy As Dictionary") As "String";   COMMENT = "";
      Function "Open6"___("Database As String, Table As String, Where As Dictionary, OrderBy As Dictionary") As "String";   COMMENT = "";

      Function "Close"___("RecordsId As String") As "Boolean";   COMMENT = "";
      Function "Requery"___("RecordsId As String") As "Boolean";   COMMENT = "";

      Function "First"___("RecordsId As String") As "Boolean";   COMMENT = "";
      Function "Next"___("RecordsId As String") As "Boolean";   COMMENT = "";
      Function "Previous"___("RecordsId As String") As "Boolean";   COMMENT = "";
      Function "Last"___("RecordsId As String") As "Boolean";   COMMENT = "";
      Function "GoTo"___("RecordsId As String, Position As Integer") As "Boolean";   COMMENT = "";

      Function "Length"___("RecordsId As String") As "Integer";   COMMENT = "";
      Function "Position"___("RecordsId As String") As "Integer";   COMMENT = "";

      Function "FieldNames"___("RecordsId As String") As "List";   COMMENT = "";
      Function "Value"___("RecordsId As String, Field As String") As "id";   COMMENT = "";

    End_Object

    

    Object "Query" SuperClass "QObject"
  
      Function "Run"___("QueryNameOrSql As String") As "Boolean";   COMMENT = "";
      Function "Run2"___("Database As String, QueryNameOrSql As String") As "Boolean";   COMMENT = "";

      Function "Command"___("Command As String") As "Dictionary";   COMMENT = "";
      Function "Command2"___("Database As String, Command As String") As "Dictionary";   COMMENT = "";

    End_Object

    

    Object "Desktop"
  
      Function "DesktopLocation"___("") As "String";   COMMENT = "";

    End_Object

    // ----------------------------------------------------------------------------------------------------------------------------

    Object "Application" SuperClass "QApplication"

    #include "qApplication.h" 

    End_Object

    

    Object "qApp" SuperClass "QApplication"

    #include "qApplication.h" // definitions

    End_Object

    // ----------------------------------------------------------------------------------------------------------------------------

    Object "StatusBar" SuperClass "QWidget"
  
      Sub      "ClearMessage"___("");   COMMENT = "";
      Sub      "ShowMessage"___("Message As String");   COMMENT = "";
      Sub      "ShowMessage2"___("Message As String, TimeOutInMilliSeconds As Integer");   COMMENT = "";
      Sub      "AddPermanentWidget"___("Widget As QWidget");   COMMENT = "";

    End_Object

    

    Object "Sounds" SuperClass "QObject"
  
      Function "Play"___("SoundId As String") As "Boolean";   COMMENT = "";
      Function "Load"___("SoundId As String, FileName As String") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "Pixmaps" SuperClass "QObject"
  
      Function "Load"___("PixmapId As String, FileName As String") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "Colors" SuperClass "QObject" // TODO
  
      Function "White"___("") As "String = \"Color.White\"";   COMMENT = "";
      Function "Black"___("") As "String = \"Color.Black\"";   COMMENT = "";
      Function "Red"___("") As "String = \"Color.Red\"";   COMMENT = "";
      Function "DarkRed"___("") As "String = \"Color.DarkRed\"";   COMMENT = "";
      Function "Green"___("") As "String = \"Color.Green\"";   COMMENT = "";
      Function "DarkGreen"___("") As "String = \"Color.DarkGreen\"";   COMMENT = "";
      Function "Blue"___("") As "String = \"Color.Blue\"";   COMMENT = "";
      Function "DarkBlue"___("") As "String = \"Color.DarkBlue\"";   COMMENT = "";
      Function "Cyan"___("") As "String = \"Color.Cyan\"";   COMMENT = "";
      Function "DarkCyan"___("") As "String = \"Color.DarkCyan\"";   COMMENT = "";
      Function "Magenta"___("") As "String = \"Color.Magenta\"";   COMMENT = "";
      Function "DarkMagenta"___("") As "String = \"Color.DarkMagenta\"";   COMMENT = "";
      Function "Yellow"___("") As "String = \"Color.Yellow\"";   COMMENT = "";
      Function "DarkYellow"___("") As "String = \"Color.DarkYellow\"";   COMMENT = "";
      Function "Gray"___("") As "String = \"Color.Gray\"";   COMMENT = "";
      Function "DarkGray"___("") As "String = \"Color.DarkGray\"";   COMMENT = "";
      Function "LightGray"___("") As "String = \"Color.LightGray\"";   COMMENT = "";
      Function "Color0"___("") As "String = \"Color.Color0\"";   COMMENT = "";
      Function "Color1"___("") As "String = \"Color.Color1\"";   COMMENT = "";
      Function "Transparent"___("") As "String = \"Color.Transparent\"";   COMMENT = "";

    End_Object

    

    Object "Fonts" SuperClass "QObject"
  
      Function "Set"___("FontId As String, Name As String, Size As Integer, Italic As Boolean, Bold As Boolean, Underline As Boolean") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "ToolBar" SuperClass "QWidget"
  
      Sub "AddPermanentWidget"___("Widget As QWidget, BeforeAction As QAction");   COMMENT = "";

    End_Object

    

    Object "SystemTrayIcon" SuperClass "QObject"
  
      Property "ContextMenu" As "QMenu";    COMMENT = "";
      Property "Icon" As "QIcon";    COMMENT = "";
      Property "ToolTip" As "String";    COMMENT = "";
      Property "Visible" As "Boolean";    COMMENT = "";

      Function "IsSystemTrayAvailable"___("") As "Boolean";   COMMENT = "";
      Function "IsMessageBoxSupported"___("") As "Boolean";   COMMENT = "";

      Sub "Show"___("");   COMMENT = "";
      Sub "Hide"___("");   COMMENT = "";
      Sub "ShowOrHide"___("");   COMMENT = "";

      Sub "MessageBox"___("Text As String");   COMMENT = "";
      Sub "MessageBox2"___("Text As String, Title As String");   COMMENT = "";
      Sub "MessageBox3"___("Text As String, Title As String, MessageBoxIcon As Integer");   COMMENT = "";
      Sub "MessageBox4"___("Text As String, Title As String, MessageBoxIcon As Integer, TimeOut As Integer");   COMMENT = "";

      Signal "activated"___("Text As String") Declare "void activated(QSystemTrayIcon::ActivationReason reason)"   COMMENT = "";
      Signal "messageClicked"___("") Declare "void messageClicked()"   COMMENT = "";

    End_Object

    

    Object "MainWindow" SuperClass "QMainWindow"
  
    End_Object
  
    // ----------------------------------------------------------------------------------------------------------------------------

    Object "OpenFileDialog" SuperClass "QObject"
  
      Function "GetFile"___("") As "String";   COMMENT = "";
      Function "GetFiles"___("") As "List";   COMMENT = "";

      Function "GetDirectory"___("") As "String";   COMMENT = "";
      Function "GetDirectory2"___("WindowTitle As String, Directory As String") As "String";   COMMENT = "";

      Function "GetFile2"___("WindowTitle As String, Directory As String, Filter As String") As "String";   COMMENT = "";
      Function "GetFiles2"___("WindowTitle As String, Directory As String, Filter As String") As "List";   COMMENT = "";

    End_Object

    

    Object "SaveFileDialog" SuperClass "QObject"
  
      Function "GetFile"___("") As "String";   COMMENT = "";
      Function "GetDirectory"___("") As "String";   COMMENT = "";

      Function "GetDirectory2"___("WindowTitle As String, Directory As String") As "String";   COMMENT = "";

      Function "GetFile2"___("WindowTitle As String, Directory As String, Filter As String") As "String";   COMMENT = "";

    End_Object

    

    Object "ColorDialog" SuperClass "QObject"
  
      Function "GetColor"___("") As "Boolean";   COMMENT = "";

      Function "Red"___("") As "Integer";   COMMENT = "";
      Function "Green"___("") As "Integer";   COMMENT = "";
      Function "Blue"___("") As "Integer";   COMMENT = "";
      Function "Alpha"___("") As "Integer";   COMMENT = "";

      Function "GetColor2"___("Red As Integer, Green As Integer, Blue As Integer, Alpha As Integer") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "FontDialog" SuperClass "QObject"
  
      Function "GetFont"___("") As "Boolean";   COMMENT = "";

      Function "Name"___("") As "String";   COMMENT = "";
      Function "Size"___("") As "Integer";   COMMENT = "";
      Function "Bold"___("") As "Boolean";   COMMENT = "";
      Function "Italic"___("") As "Boolean";   COMMENT = "";
      Function "Underline"___("") As "Boolean";   COMMENT = "";

      Function "GetFont2"___("Name As String, Size As Integer, Bold As Boolean, Italic As Boolean, Underline As Boolean") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "ProgressDialog" SuperClass "QObject"

      Property "WindowTitle" As "String";    COMMENT = "";
      Property "CancelText" As "String";    COMMENT = "";
      Property "Value" As "Integer";    COMMENT = "";
      Property "Minimum" As "Integer";    COMMENT = "";
      Property "Maximum" As "Integer";    COMMENT = "";
      Property "Wait" As "Integer";    COMMENT = "";

      Sub "Hide"___("");   COMMENT = "";
      Sub "Show"___("");   COMMENT = "";
      Function "Canceled"___("") As "Boolean";   COMMENT = "";

      Function "Show2"___("WindowTitle As String, CancelText As String") As "Boolean";   COMMENT = "";

    End_Object

    

    Object "InputDialog" SuperClass "QObject"

      Function "Ok"___("") As "Boolean";   COMMENT = "";
      Function "GetString"___("WindowTitle As String, Text As String = \"\", Value As String = \"\", EchoMode As Integer = InputDialog.Normal") As "String";   COMMENT = "";
      Function "GetFloat"___("WindowTitle As String, Text As String = \"\", Value As Float = 0, Minimum As Float = -2147483647, Maximum As Float = 2147483647, Decimals As Integer = 1") As "Float";   COMMENT = "";
      Function "GetInteger"___("WindowTitle As String, Text As String = \"\", Value As Integer = 0, Minimum As Integer = -2147483647, Maximum As Integer = 2147483647, Step As Integer = 1") As "Integer";   COMMENT = "";

    End_Object

    

    Object "MessageBox" SuperClass "QObject"

      Function "Critical"___("WindowTitle As String, Text As String = \"\", Buttons As Integer = MessageBox.Ok, DefaultButton As Integer = MessageBox.NoButton") As "Integer";   COMMENT = "";
      Function "Information"___("WindowTitle As String, Text As String = \"\", Buttons As Integer = MessageBox.Ok, DefaultButton As Integer = MessageBox.NoButton") As "Integer";   COMMENT = "";
      Function "Question"___("WindowTitle As String, Text As String = \"\", Buttons As Integer = MessageBox.Ok, DefaultButton As Integer = MessageBox.NoButton") As "Integer";   COMMENT = "";
      Function "Warning"___("WindowTitle As String, Text As String = \"\", Buttons As Integer = MessageBox.Ok, DefaultButton As Integer = MessageBox.NoButton") As "Integer";   COMMENT = "";

    End_Object

    

  }

}


#undef COMMENT
#undef CLASSCOMMENT
#undef Property
#undef Function
#undef Sub
#undef Event
#undef Signal
#undef Delegate
#undef As
#undef Declare
#undef Cast
#undef Object
#undef SuperClass
#undef End_Object
#undef SEEALSO
#undef EXAMPLE
#undef ___
#undef As
#undef Alias



#include "_Q7BCompiler.h"


#define COMMENT ;Me.operators<<sOperator;Me.comments_operators[sOperator]._COMMENT

#define Operator ;sOperator=


void Parser::CreateListOfOperators()
{      
  QString sOperator;
    
  if (Me.operators.size() == 0){    
    
    
    
    Operator "'"      COMMENT = "";
    Operator "("      COMMENT = "";
    Operator ")"      COMMENT = "";
    Operator "."      COMMENT = "";
    Operator "!"      COMMENT = "";
    Operator "==="      COMMENT = "";
    Operator "=="      COMMENT = "";
    Operator "="      COMMENT = "";
    Operator "="      COMMENT = "";
    Operator "Not"      COMMENT = "";
    Operator "<>"      COMMENT = "";
    Operator ">="      COMMENT = "";
    Operator "<="      COMMENT = "";
    Operator "Mod"      COMMENT = "";
    Operator "AndAlso"      COMMENT = "";
    Operator "OrElse"      COMMENT = "";
    Operator "And"      COMMENT = "And operator";
    Operator "Or"      COMMENT = "";
    Operator "Xor"      COMMENT = "";
    Operator "Flip"      COMMENT = "";
    Operator "Shl"      COMMENT = "";
    Operator "Shr"      COMMENT = "";
    Operator "&"      COMMENT = "";
    Operator "*"      COMMENT = "";
    Operator "/"      COMMENT = "";
    Operator "^"      COMMENT = "";
    Operator "\\"      COMMENT = "";
    Operator ":"      COMMENT = "";
    Operator "$"      COMMENT = "";
    Operator "+"      COMMENT = "";
    Operator "-"      COMMENT = "";






    
  }

  Me.operators.sort();

}

bool Parser::parseMulDivMod(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseFactor(Expression)){
    
    _statements Statements = Expression.Statements;

    do {
      QString sOperator;

      if (parseTerm("*")) sOperator = "MUL";
      else if (parseTerm("/")) sOperator = "DIV";
      else if (parseTerm("\\")) sOperator = "IDIV";
      else if (parseTerm("Mod")) sOperator = "MOD";
      else break;

      _expressions Expression2;

      if (!parseFactor(Expression2)){ error(""); return false; }

      if (!typeCompatible(Expression.sType, Expression2.sType, sOperator)){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      Statements = Compiler::pushOperator(sOperator, Statements, Expression2.Statements);

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;

    return true;
  }
  return false;
}

bool Parser::parseAddSub(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseMulDivMod(Expression)){
    _statements Statements = Expression.Statements;
    QString sReturnType0 = Expression.sType;
    do {
      QString sOperator;

      if (parseTerm("+")) sOperator = "ADD";
      else if (parseTerm("&")){
        sOperator = "CONCAT";
      }
      else if (parseTerm("-")) sOperator = "SUB";

      else break;

      _expressions Expression2;

      if (!parseMulDivMod(Expression2)){ error(""); return false; }

      if (!typeCompatible(sReturnType0, Expression2.sType, sOperator)){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      Statements = Compiler::pushOperator(sOperator, Statements, Expression2.Statements);
      

      

      if (sOperator == ("CONCAT")){
        sReturnType0 = "String";
      }
    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = sReturnType0;

    

    return true;
  }
  return false;
}

bool Parser::parseExponent(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseAddSub(Expression)){
    _statements Statements = Expression.Statements;
    do {
      QString sOperator;
    
      if (parseTerm("^")) sOperator = "POWER";
      else break; 

      _expressions Expression2;

      if (!parseAddSub(Expression2)){ error(""); return false; }

      if (!typeCompatible(Expression.sType, Expression2.sType, sOperator)){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      Statements = Compiler::pushOperator(sOperator, Statements, Expression2.Statements);

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}

bool Parser::parseShift(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseExponent(Expression)){
    _statements Statements = Expression.Statements;
    do {
      QString sOperator;
    
      if (parseTerm("Shl")) sOperator = "SHR";
      else if (parseTerm("Shr")) sOperator = "SHL";
      else break; 

      _expressions Expression2;

      if (!parseExponent(Expression2)){ error(""); return false; }

      if (!typeCompatible(Expression.sType, Expression2.sType, sOperator)){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      Statements = Compiler::pushOperator(sOperator, Statements, Expression2.Statements);

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}

bool Parser::parseComparision(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseShift(Expression)){
    _statements Statements = Expression.Statements;
    do {
      QString sOperator;            

      if (parseTerm("=")){ sOperator = "EQUAL"; }
      else if (parseTerm("==")){
        sOperator = "EQUALEQUAL"; 
      } else if (parseTerm("===")){ 
        sOperator = "EQUALEQUALEQUAL"; } 

      else if (parseTerm("<>")){ sOperator = "UNEQUAL"; } 
      else if (parseTerm(">")){ sOperator = "GREATER"; } 
      else if (parseTerm("<")){ sOperator = "SMALLER"; } 
      else if (parseTerm(">=")){ sOperator = "GREATEREQUAL"; }
      else if (parseTerm("<=")){ sOperator = "SMALLEREQUAL"; }
      else break;
#ifdef ASDFADSFWERBERND 
       } //sReturnType = "Boolean"; }

      else if (parseTerm("<>")){ sOperator = "UNEQUAL"; } //sReturnType = "Boolean"; }
      else if (parseTerm(">")){ sOperator = "GREATER"; } //sReturnType = "Boolean"; }
      else if (parseTerm("<")){ sOperator = "SMALLER"; } //sReturnType = "Boolean"; }
      else if (parseTerm(">=")){ sOperator = "GREATEREQUAL"; } //sReturnType = "Boolean"; }
      else if (parseTerm("<=")){ sOperator = "SMALLEREQUAL"; } //sReturnType = "Boolean"; }
      else return true;

      */
    #endif 
      _expressions Expression2;

      if (!parseShift(Expression2)){ 
        

        error(""); return false; 
      }
    
      if (!typeCompatible(Expression.sType, Expression2.sType, sOperator)){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      Statements = Compiler::pushOperator(sOperator, Statements, Expression2.Statements);
      Expression.sType = "Boolean";

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}

bool Parser::parseAnd(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseComparision(Expression)){
    _statements Statements = Expression.Statements;
    do {

      if (parseTerm("And")){

        _expressions Expression2;

        if (!parseComparision(Expression2)){ error(""); return false; }

        if (!typeCompatible(Expression.sType, Expression2.sType, "AND")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

        Statements = Compiler::pushOperator("AND", Statements, Expression2.Statements);

      }  
      else break;

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}

bool Parser::parseOr(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseAnd(Expression)){
    _statements Statements = Expression.Statements;
    do {

      if (parseTerm("Or")){
        
        _expressions Expression2;

        if (!parseAnd(Expression2)){ error(""); return false; }

        if (!typeCompatible(Expression.sType, Expression2.sType, "OR")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

        Statements = Compiler::pushOperator("OR", Statements, Expression2.Statements);

      } else if (parseTerm("Xor")){
        
        _expressions Expression2;

        if (!parseAnd(Expression2)){ error(""); return false; }

        if (!typeCompatible(Expression.sType, Expression2.sType, "XOR")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

        Statements = Compiler::pushOperator("XOR", Statements, Expression2.Statements);

      } else break;

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}

bool Parser::parseAndAlso(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseOr(Expression)){
    _statements Statements = Expression.Statements;
    do {

      if (parseTerm("AndAlso")){

        _expressions Expression2;

        if (!parseOr(Expression2)){ error(""); return false; }

        Statements = Compiler::pushOperator("ANDALSO", Statements, Expression2.Statements);

      } else break;

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}

bool Parser::parseOrElse(_expressions & ReturnExpression)
{  
  _expressions Expression;
  if (parseAndAlso(Expression)){
    _statements Statements = Expression.Statements;
    do {

      if (parseTerm("OrElse")){
        
        _expressions Expression2;

        if (!parseAndAlso(Expression2)){ error(""); return false; }

        Statements = Compiler::pushOperator("ORELSE", Statements, Expression2.Statements);

      } else break;

    } while(Me.bError == false);

    ReturnExpression.Statements << Statements;
    ReturnExpression.sType = Expression.sType;
    return true;
  }
  return false;
}


#undef COMMENT
#undef Operator






#include "_Q7BCompiler.h"

QString ARG(QStringList l){ 
  if (l.count() < 2) return ""; l.removeFirst(); 
  return l.join(", "); 
}



#define End_Function l.prepend(sType);sAlias="";lAlias.sort();if(lAlias.count()>0){sAlias=lAlias.join(",")+","+SUBFUNCTION;}do{if(i==0){sGROUP=Me.comments_subsfunctions[SUBFUNCTION]._GROUP;sSEEALSO=Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO;sCOMMENT=Me.comments_subsfunctions[SUBFUNCTION]._COMMENT;sEXAMPLE=Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE;}else{Me.comments_subsfunctions[SUBFUNCTION]._GROUP=sGROUP;Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO=sSEEALSO;Me.comments_subsfunctions[SUBFUNCTION]._COMMENT=sCOMMENT;Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE=sEXAMPLE;}Me.comments_subsfunctions[SUBFUNCTION]._RETURN=sType;Me.subsfunctions[SUBFUNCTION]=l;Me.subsfunctions_aliasrealname[SUBFUNCTION]=sAliasRealname;Me.comments_subsfunctions[SUBFUNCTION]._ARGUMENTS=ARG(l);Me.comments_subsfunctions[SUBFUNCTION]._ALIAS=sAlias;SUBFUNCTION="";if(lAlias.size()>0&&i<lAlias.size())SUBFUNCTION=lAlias.at(i);}while(i++<lAlias.size());i=0;sType="";lAlias.clear();l.clear();
#define End_FakeFunction l.prepend(sType);sAlias="";lAlias.sort();if(lAlias.count()>0){sAlias=lAlias.join(",")+","+SUBFUNCTION;}do{if(i==0){Me.comments_subsfunctions[SUBFUNCTION]._Isfake="true"; sGROUP=Me.comments_subsfunctions[SUBFUNCTION]._GROUP;sSEEALSO=Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO;sCOMMENT=Me.comments_subsfunctions[SUBFUNCTION]._COMMENT;sEXAMPLE=Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE;}else{Me.comments_subsfunctions[SUBFUNCTION]._GROUP=sGROUP;Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO=sSEEALSO;Me.comments_subsfunctions[SUBFUNCTION]._COMMENT=sCOMMENT;Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE=sEXAMPLE;}Me.comments_subsfunctions[SUBFUNCTION]._RETURN=sType;Me.subsfunctions_aliasrealname[SUBFUNCTION]=sAliasRealname;Me.comments_subsfunctions[SUBFUNCTION]._ARGUMENTS=ARG(l);Me.comments_subsfunctions[SUBFUNCTION]._ALIAS=sAlias;SUBFUNCTION="";if(lAlias.size()>0&&i<lAlias.size())SUBFUNCTION=lAlias.at(i);}while(i++<lAlias.size());i=0;sType="";lAlias.clear();l.clear();

#define End_Sub l.prepend(sType);sAlias="";lAlias.sort();if(lAlias.count()>0){sAlias=lAlias.join(",")+","+SUBFUNCTION;}do{if(i==0){sGROUP=Me.comments_subsfunctions[SUBFUNCTION]._GROUP;sSEEALSO=Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO;sCOMMENT=Me.comments_subsfunctions[SUBFUNCTION]._COMMENT;sEXAMPLE=Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE;}else{Me.comments_subsfunctions[SUBFUNCTION]._GROUP=sGROUP;Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO=sSEEALSO;Me.comments_subsfunctions[SUBFUNCTION]._COMMENT=sCOMMENT;Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE=sEXAMPLE;}Me.comments_subsfunctions[SUBFUNCTION]._RETURN=sType;Me.subsfunctions[SUBFUNCTION]=l;Me.subsfunctions_aliasrealname[SUBFUNCTION]=sAliasRealname;Me.comments_subsfunctions[SUBFUNCTION]._ARGUMENTS=ARG(l);Me.comments_subsfunctions[SUBFUNCTION]._ALIAS=sAlias;SUBFUNCTION="";if(lAlias.size()>0&&i<lAlias.size())SUBFUNCTION=lAlias.at(i);}while(i++<lAlias.size());i=0;sType="";lAlias.clear();l.clear();
#define End_FakeSub l.prepend(sType);sAlias="";lAlias.sort();if(lAlias.count()>0){sAlias=lAlias.join(",")+","+SUBFUNCTION;}do{if(i==0){Me.comments_subsfunctions[SUBFUNCTION]._Isfake="true";sGROUP=Me.comments_subsfunctions[SUBFUNCTION]._GROUP;sSEEALSO=Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO;sCOMMENT=Me.comments_subsfunctions[SUBFUNCTION]._COMMENT;sEXAMPLE=Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE;}else{Me.comments_subsfunctions[SUBFUNCTION]._GROUP=sGROUP;Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO=sSEEALSO;Me.comments_subsfunctions[SUBFUNCTION]._COMMENT=sCOMMENT;Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE=sEXAMPLE;}Me.comments_subsfunctions[SUBFUNCTION]._RETURN=sType;Me.subsfunctions[SUBFUNCTION]=l;Me.subsfunctions_aliasrealname[SUBFUNCTION]=sAliasRealname;Me.comments_subsfunctions[SUBFUNCTION]._ARGUMENTS=ARG(l);Me.comments_subsfunctions[SUBFUNCTION]._ALIAS=sAlias;SUBFUNCTION="";if(lAlias.size()>0&&i<lAlias.size())SUBFUNCTION=lAlias.at(i);}while(i++<lAlias.size());i=0;sType="";lAlias.clear();l.clear();

#define GROUP Me.comments_subsfunctions[SUBFUNCTION]._GROUP
#define SEEALSO Me.comments_subsfunctions[SUBFUNCTION]._SEEALSO

#define COMMENT Me.comments_subsfunctions[SUBFUNCTION]._COMMENT
#define EXAMPLE Me.comments_subsfunctions[SUBFUNCTION]._EXAMPLE
#define OLDBASIC Me.comments_subsfunctions[SUBFUNCTION]._OLDBASIC=true;

#define FakeFunction ;sAliasRealname=SUBFUNCTION=
#define FakeSub sType="";sAliasRealname=SUBFUNCTION=
#define Function ;sAliasRealname=SUBFUNCTION=
#define Sub sType="";sAliasRealname=SUBFUNCTION=
#define ___ ;l<<SubFunction
#define As ;sType=
#define Alias ;lAlias<<


void Parser::AddFunction(QString _sName, QString _sArguments, QString _sType, QString sGroup, QString sSeeAlso, QString sComment, QString sExample, bool bAppend)
{
  int i = 0;

  QString sKey;
  QStringList l; 
  QStringList lAlias; 
  QString sType;
  QString SUBFUNCTION;

  QString sGROUP;
  QString sSEEALSO;
  QString sCOMMENT;
  QString sEXAMPLE;

  QString sAlias;
  QString sAliasRealname;

  if (bAppend == false){
    Function _sName ___(_sArguments) As _sType;

      GROUP   = sGroup;
      SEEALSO = sSeeAlso;
      COMMENT = sComment;
      EXAMPLE = sExample;

    End_Function

  } else {
    SUBFUNCTION = _sName;
    Me.comments_subsfunctions[SUBFUNCTION]._ARGUMENTS        += _sArguments;

    GROUP   = sGroup;
    SEEALSO += sSeeAlso;
    COMMENT += sComment;
    EXAMPLE += sExample;

  }
}

void Parser::CreateListOfSubsFunctions()
{   

  int i = 0;

  QString sKey;
  QStringList l; 
  QStringList lAlias; 
  QString sType;
  QString SUBFUNCTION;

  QString sGROUP;
  QString sSEEALSO;
  QString sCOMMENT;
  QString sEXAMPLE;

  QString sAlias;
  QString sAliasRealname;

  //VERSION = "1.0"; // only if not 1.0
    
  if (Me.subsfunctions.size() == 0){    
    
    
    



    // ----------------------------------------------------------------------------------------------------------------------------

    Function "Oct"___("EXPRESSION") As "String";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Returns a string giving the octal (base 8) representation of ?number?.  ";
      EXAMPLE = "";
	  OLDBASIC

    End_Function

    

    Function "AddressOf"___("Variable") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Returns the phyiscal address of the variable in memory. This is useful for DLL or SO calls. ";
      EXAMPLE = "";

    End_Function

    

    Function "StrComp"___("STRINGEXPRESSION, STRINGEXPRESSION [, ComparisionMode As Integer]") As "Integer";

      GROUP =   "String";
      SEEALSO = "";      
      COMMENT = "";
      EXAMPLE = "";
	  OLDBASIC

    End_Function




	
    

    FakeFunction "LOF"___("[#]FILENNO") As "Integer";

      GROUP =   "File";
      SEEALSO = "";      
      COMMENT = "NOT IMPLEMENTED YET. Returns the length of a file in bytes. It returns -1 if the file is not available. ";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "MessageBox"___("Icon As Integer, Title As String, Text As String, InformativeText As String, DetailedText As String, {StandardButton As Integer | List(Text As String, Role As Integer), ...}") As "Integer";

      GROUP =   "ui";
      SEEALSO = "InputBox";
      COMMENT = "The order of the buttons is determined by the button role. The return value is for StandardButtons one of their integer const values or the order number of the user defined button.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
		
    

    Function "IsError"___("Expression") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function
	
    

    Sub "Peek"___("");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Sub
	
    

    Sub "Poke"___("");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Sub
	
    

    Function "IsLeapYear"___("Expression") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function

    

    Function "IsMissing"___("Expression") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function

    

    Function "IsNumeric"___("Expression") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function
	
    

    Function "IsObject"___("Expression") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function
	
    

    Function "IsVariant"___("Expression") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function

    

    Function "Sgn"___("Expression") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_Function
	
    

    FakeSub "Seek"___("#FileNo, RecordPosition As Integer");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeFunction "VarType"___("VARIABLE") As "Integer"; 

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
	 

    FakeFunction "TypeName"___("VARIABLE") As "String"; 

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Tab"___("Integer") As "String"; 

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Spc"___("Integer") As "String"; 

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeSub "RmDir"___("String");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeSub "ChDir"___("String");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeSub "MkDir"___("String");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeSub "ChDrive"___("String");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeSub "Write"___("[#]FileNo As Integer, EXPRESSION, EXPRESSION?");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeSub "Line Input"___("[#]FilenNo As Integer, VARIABLENAME");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "NOT IMPLEMENTED YET. Reads line of text from file into variable. Provided for backward compatibility. ";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeFunction "Loc"___("[#]FileNo As Integer"); As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeSub "Circle"___("ARGUMENTS");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeFunction "CurDir"___("[Drive As String]") As "String";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Erl"___("") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Err"___("") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "FileDateTime"___("FileName As String") As "DateTime";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "FileLen"___("FileName As String") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Error"___("EXPRESSION") As "String";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "FileAttr"___("[#]FileNo As Integer, ReturnType As Integer") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "CVErr"___("EXPRESSION") As "id";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Command"___("") As "String";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeSub "Files"___("");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeSub "Reset"___("");

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeFunction "RGB"___("Red As Integer, Green As Integer, Blue As Integer") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Get"___("[#]FileNo As Integer[, RecordNo As Integer], Variable As AnyType") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Put"___("[#]FileNo As Integer[, RecordNo As Integer], Variable As AnyType") As "Boolean";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "GetAttr"___("Path As String") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Inkey"___("") As "String";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeSub "Input"___("[;][STRINGEXPRESSION{;,}] VARIABLENAME[,VARIABLENAME?]") As "String";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeSub
	
    

    FakeFunction "Fre"___("EXPRESSION") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Array"___("ARGUMENTS") As "List";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "Very old basic command. Not supported yet.";
      EXAMPLE = "";
	  OLDBASIC

    End_FakeFunction
	
    

    Function "SizeOf"___("Variable") As "Integer";

      GROUP =   "";
      SEEALSO = "";      
      COMMENT = "NOT IMPLEMENTED YET! Returns the size of the variable in bytes. ";
      EXAMPLE = "";

    End_Function
	
    

    FakeFunction "Switch"___("EXPRESSION, RETURNEXPRESSION[, EXPRESSION, RETURNEXPRESSION, ? ]") As "id";

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "NOT IMPLEMENTED YET! ?Switch? returns a value depending on an expression. ";
      EXAMPLE = ""
"Dim s As String\n"
"Dim i As Integer\n"
"i = 1 \n"
"s = Switch(i = 1, \"Bible\", i = 2, \"Casanova\")\n"
"MsgBox(s)\n"
	  "";
	  OLDBASIC

    End_FakeFunction
	
    

    FakeFunction "Choose"___("Index, Select - 1 [, Select - 2, ? [, Select - n]]") As "id";

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "NOT IMPLEMENTED YET! Returns one value from a list of values depending on the index. ";
      EXAMPLE = ""
"Dim s As String\n"
"s = Choose(1, \"un\", \"deux\", \"troi\")\n"
"MsgBox(s)\n"
	  "";
	  OLDBASIC

    End_FakeFunction




	
    

    Function "PSQL"___("SQL As String") As "id";

      GROUP =   "SQL";
      SEEALSO = "PSQLConnect";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "PSQLConnect"___("Name As String, User As String, Password As String [, Host As String [, ConnectOptions As String [, Port As Integer]]]") As "id";

      GROUP =   "SQL";
      SEEALSO = "PSQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    FakeSub "Open"___("FILENAME For [Input|Output|Append|Binary|Random] Access [Read|Write|Read Write] As [#]FILENO [LEN = RECORDLEN]");

      GROUP =   "File";
      SEEALSO = "Close";      
      COMMENT = "";
      EXAMPLE = "";
      OLDBASIC

    End_FakeSub
  
    

    FakeSub "Close"___("[ [#]FILENO ] {[ , [#]FILENO ]}");

      GROUP =   "File";
      SEEALSO = "Open, Reset";      
      COMMENT = "Closes the specified file(s). ";
      EXAMPLE = ""
""
"Dim I, filename\n"
"For I = 1 To 3 ' repeat loop 3 times\n"
"  filename = \"TEST\" & I ' create filename\n"
"  Open filename For Output As #I ' open file\n"
"  Print #I, \"Ein Test.\" ' write string into file\n"
"Next I\n"
"Close ' close all 3 opened files\n"
""
"";
      OLDBASIC

    End_FakeSub

    

    FakeSub "Line"___("Input [#]FILENNO, VARIABLENAME");

      GROUP =   "File";
      SEEALSO = "";      
      COMMENT = "Reads line of text from file into variable. Provided for QBasic compatibility.";
      EXAMPLE = ""
""
"Dim text2 As String\n"
" \n"
"Open \"test.txt\" For Input As #1	' open file\n"
"Do While Not EOF(1)	' loop until end of file\n"
"	Line Input #1, text2	' read line into variable\n"
"	MsgBox(text2)\n"
"Loop\n"
"Close #1\n"
""
"";
      OLDBASIC

    End_FakeSub

    

    FakeFunction "EOF"___("[#]FILENNO") As "Boolean";

      GROUP =   "File";
      SEEALSO = "";      
      COMMENT = "$(...) returns true if end of file has been reached. In other words, it checks if end of file has been reached and return true if it has happened.";
      EXAMPLE = ""
""
"  Dim data\n"
"  Open \"file1\" For Input As #1 ' open file for reading\n"
"  Do While Not EOF(1) ' test for end of file\n"
"    Line Input #1, data ' get the data from file\n"
"    Print data \n"
"  Loop\n"
"  Close #1 ' close file\n"
""
"";
      OLDBASIC

    End_FakeFunction

    

    Function "FreeFile"___("[Range As Integer]") As "Integer";

      GROUP =   "File";
      SEEALSO = "";      
      COMMENT = "It returns the next free available file handle. ";
      EXAMPLE = ""
""
"Dim Index1, filehandle\n"
"For Index1 = 1 To 5\n"
"\n"
"  filehandle = FreeFile ' next free available file handle \n"
"\n"
"  Open \"TEST\" & Index1 For Output As #filehandle\n"
"  Write #filehandle, \"example text.\"\n"
"  Close #filehandle \n"
"Next\n"
""
"";
      OLDBASIC

    End_Function

    

    Sub "PSQLDisconnect"___("");

      GROUP =   "SQL";
      SEEALSO = "PSQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Function "MySQL"___("SQL As String") As "id";

      GROUP =   "SQL";
      SEEALSO = "MySQLConnect";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "MySQLConnect"___("Name As String, User As String, Password As String [, Host As String [, ConnectOptions As String [, Port As Integer]]]") As "id";

      GROUP =   "SQL";
      SEEALSO = "MySQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Sub "MySQLDisconnect"___("");

      GROUP =   "SQL";
      SEEALSO = "MySQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Function "MD5"___("Argument As String") As "Integer";

      GROUP =   "SQL";
      SEEALSO = "";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "PSQLLastInsertId"___("Table As String") As "Integer";

      GROUP =   "SQL";
      SEEALSO = "PSQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "MySQLLastInsertId"___("") As "Integer";

      GROUP =   "SQL";
      SEEALSO = "PSQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SQLiteLastInsertId"___("") As "Integer";

      GROUP =   "SQL";
      SEEALSO = "PSQL";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SQLite"___("SQL As String, FilePath As String = \"default.sdb\"") As "id";

      GROUP =   "SQL";
      SEEALSO = "";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Sub "ReconnectSignals"___("Argument As id");

      GROUP =   "";
      SEEALSO = "MySQL";      
      COMMENT = ""
"$(...) e.g. you have a QButtonGroup or any control which connects to signal automatically, do this in the code file, it is declared, so if you declare a QButtonGroup in SUBSFUNCTIONS.QObject.q7b, it is expected to have a \n"
"\n"
"Signal on_MYCONTROL_buttonClicked(ky As QAbstractButton) \n"
"End Signal\n"
"\n"
"Cannot change this behaviour, but I can provide a built-in function, which could be called, before controls are used.\n"
"";

      EXAMPLE = "";

    End_Sub


    

    Function "IsDecimal"___("Argument As id") As "Boolean" Alias "IsCurrency";

      GROUP =   "Conversion";
      SEEALSO = "";
      COMMENT = "Returns true if a variable represents a Decimal type. ";
      EXAMPLE = ""
""
"Dim c As Decimal \n"
"\n"
"c = 23.67D ' decimal literal\n"
"\n"
"MsgBox(IsDecimal(c))\n"
""
"";
    End_Function

    

    Function "IsDateTime"___("Argument As id") As "Boolean" Alias "IsDate";
	

      GROUP =   "Conversion";
      SEEALSO = "";
      COMMENT = "Returns true if a variable represents a datetime type. ";
      EXAMPLE = "";

    End_Function

    

    FakeFunction "BLOB"___("Argument As id") As "String";

      GROUP =   "SQL";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_FakeFunction

    

    FakeFunction "BOOLEAN"___("Argument As id") As "String";

      GROUP =   "SQL";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_FakeFunction

    

    FakeFunction "INTEGER"___("Argument As id") As "String";

      GROUP =   "SQL";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_FakeFunction

    

    FakeFunction "FLOAT"___("Argument As id") As "String";

      GROUP =   "SQL";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_FakeFunction

    

    FakeFunction "TEXT"___("Argument As id") As "String";

      GROUP =   "SQL";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_FakeFunction


    

    Sub "ExecAfterMSec"___("MilliSeconds As Integer, SignalProcedureName As String, CallInObject As QObject = Me") Alias "Call";

      SEEALSO = "Random";
      COMMENT = "The given signal is raised after the given milli seconds. If there is no such signal, nothing happens.";
      EXAMPLE = ""
""
"Signal on_ProjectOpen() \n"
"   MsgBox(\"Hello\")\n"
"End Signal\n"
"\n"
"Event Init()\n"
"  ExecAfterMSec(100, \"on_ProjectOpen\") \n"
"End Event\n"
""
"";

    End_Sub

    

    Sub "Wait"___("MilliSeconds As Integer");

      GROUP =   "";
      SEEALSO = "Sleep";
      COMMENT = "Blocks the app (current thread). Events are not processed. ";
      EXAMPLE = "";

    End_Sub


    

    Function "LoadUI"___("uiName As String") As "QWidget";

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "Does not work on Mac OS X yet.";
      EXAMPLE = "";

    End_Function

    

    Sub "OpenTextWindow"___("Text As String");

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "OpenHtmlWindow"___("Text As String");

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "OpenWebWindow"___("Text As String");

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "SetFocusMDI"___("Widget As QWidget");

      GROUP =   "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Function "ListMDI"___("") As "List";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "FocusMDI"___("") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Sub "SetFocusWindow"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "SetFocus"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Function "FocusWindow"___("") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "Focus"___("") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Sub "Hide"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "ShowScreen"___("");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "HideScreen"___("");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "CLS"___("");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "On the terminal screen, CLS will clear the screen and returns the cursor to the upper left corner (line 1, column 1).";
      EXAMPLE = ""
""
"  ' CLS clearing the terminal screen\n"
"  ' with a new background color\n"
"\n"
"  Dim keypressed\n"
"  Print \"This is to show the CLS command\"\n"
"  Input \"To clear the screen, press [Return]\", keypressed\n"
"\n"
"  ' changes the background color:\n"
"  Color(2, 4)\n"
"  CLS\n"
"  Print \"This is green text on a blue screen!\"\n"
""
"";
      OLDBASIC

    End_Sub

    

    Sub "PrintScreen"___("PrintDialog As Boolean");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "Prints the screen. If PrintDialog = True, the print dialog appears before printing. ";
      EXAMPLE = "";
      OLDBASIC

    End_Sub

    

    FakeSub "Line"___("[(x1 As Integer, y1 As Integer)] - (x2 As Integer, y2 As Integer) [, Color As Integer] ]");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "Draws a line on the screen. Color might be a value between 0?255. Provided for QBasic compatibility. ";
      EXAMPLE = ""
""
"CLS\n"
"\n"
"Dim a As Integer\n"
"For a = 1 To 15\n"
"  Line(10, a * 80) - (1000, a * 80), 15\n"
"Next\n"
""
"";
      OLDBASIC

    End_FakeSub

    

    FakeSub "PSet"___("x As Integer, y As Integer [, Color As Integer] ]");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "Draws a point on screen. Step is not supported. Provided for QBasic backward compatibility. ";
      EXAMPLE = ""
""
"Dim x, y\n"
"For y = 0 To 200\n"
"  For x = 0 To 320\n"
"    PSet(x, y)\n"
"  Next\n"
"Next\n"
""
"";
      OLDBASIC

    End_FakeSub

    

    Function "CSRLin"___("") As "Integer";

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "It returns the current line of the cursor in the terminal screen. ";
      EXAMPLE = ""
""
"  Dim s\n"
"\n"
"  Print CSRLin()\n"
"\n"
"  Print \"row = \" + Pos()\n"
"\n"
"  Input s\n"
"\n"
"  Print \"line = \" + CSRLin\n"
"\n"
"  Input s\n"
""
"";
      OLDBASIC

    End_Function

    

    Function "Pos"___("") As "Integer";

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "$(...) returns the current cursor position in the line. Provided for QBasic backward compatibility.";
      EXAMPLE = ""
""
"Dim s\n"
"MsgBox(Pos())\n"
"Input s\n"
"\n"
"MsgBox(CSRLin())\n"
"\n"
"MsgBox(s)\n"
"\n"
""
"";
      OLDBASIC

    End_Function

    

    Sub "Color"___("[ForeColor As Integer], [BackColor As Integer]");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "Calling it will set the color of either the foreground and optionally the background. Passing only one integer will change the fore color. Passing 2 will change both the fore and background color.";
      EXAMPLE = ""
""
"  Color(5)\n"
"  Print \"Hi\"\n"
"  Color(15, 1)\n"
"  Print \"Nadja\"\n"
"";
      OLDBASIC

    End_Sub

    

    Sub "Locate"___("[Y As Integer] [, X As Integer]");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "Sets the cursor position on screen. Provided for QBasic backward compatibility. ";
      EXAMPLE = ""
""
"CLS\n"
"Dim row, column\n"
"\n"
"Locate 5, 5\n"
"row = CSRLin\n"
"column = Pos(0)\n"
"Print \"position 1 (press any key)\"\n"
"Do\n"
"Loop While Inkey$ = ""\n"
"Locate (row + 2), (column + 2)\n"
"Print \"position 2\"\n"
""
"";
      OLDBASIC

    End_Sub

    

    FakeSub "Print"___("Text As id");

      GROUP =  "Screen";
      SEEALSO = "";
      COMMENT = "Provided for QBasic backward compatibility.  ";
      EXAMPLE = ""
""
"Print \"Hello baby!\"; \":-)\", \"----\"\n"
"Dim s As String = \"1\"\n"
"Dim s2 As String = \"2\"\n"
"Dim s3 As String = \"3\"\n"
"Print s, s2, s3\n"
""
"";
      OLDBASIC

    End_FakeSub

    

    Sub "Show"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "ShowNormal"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "ShowMaximized"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "ShowMinimized"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Sub "ShowOrHide"___("Widget As QWidget");

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Sub

    

    Function "CloseWidget"___("Widget As QWidget") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "UnloadUI"___("uiWidget As QWidget") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function


    

    Function "OpenWindow"___("uiName As String") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "OpenDialog"___("uiName As String") As "Integer";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "OpenToolWindow"___("uiName As String") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "OpenMDI"___("uiName As String") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "OpenSDI"___("uiName As String") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "OpenDockWidget"___("uiName As String") As "QWidget";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "CloseWindow"___("uiName As String") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "CloseDockWidget"___("uiName As String") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "CloseToolWindow"___("uiName As String") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "CloseMDI"___("Widget As QWidget") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "CloseAllMDI"___("") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "OpenEmail"___("SenderEmail As String, Subject As String, Body As String") As "Boolean";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function


    

    Function "UBound"___("theArray As id, DimensionToLookFor As Integer = -1") As "Integer";

      GROUP =  "Array";
      SEEALSO = "";
      COMMENT = "$(...) return the count of dimension (upper boundary index) of an array declared with [].";
      EXAMPLE = "";

    End_Function

    

    Function "LBound"___("theArray As id, DimensionToLookFor As Integer = -1") As "Integer";

      GROUP =  "Array";
      SEEALSO = "";
      COMMENT = "$(...) return the lower boundary index of an array declared with [], which is always 0 in Q7Basic.";
      EXAMPLE = "";

    End_Function

    

    Function "LeftJustified"___("Argument As String, Width As Integer, Fill As String = \" \", Truncate As Boolean = False") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) returns a string of size width that contains this string padded by the fill character.";
      EXAMPLE = "";

    End_Function

    

    Function "RightJustified"___("Argument As String, Width As Integer, Fill As String = \" \", Truncate As Boolean = False") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) returns a string of size() width that contains the fill character followed by the string. ";
      EXAMPLE = "";

    End_Function

    

    Function "ReadList"___("FilePathOrURL As String") As "List";

      GROUP =  "List";
      SEEALSO = "";
      COMMENT = "$(...) loads an entire file from a path or on a website into a list.";
      EXAMPLE = "";

    End_Function

    

    Function "WriteList"___("Argument As List, FilePathOrURL As String") As "Boolean";

      GROUP =  "List";
      SEEALSO = "";
      COMMENT = "$(...) saves the entire List in a file to a given path.";
      EXAMPLE = "";

    End_Function


    

    Function "ReadRegistry"___("RegistryPath As String, RegistryKey As String") As "String";

      GROUP =  "";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "ReadLines"___("FilePathOrURL As String [, Encoding As String]") As "List";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) loads an entire text file from a path or on a website and returns it as a list of strings (each line is a string). The file is expected to be encoded in UTF-8.";
      EXAMPLE = "";

    End_Function

    
    
    Function "WriteLines"___("theLines As QStringList, FileName As String [, Encoding As String]") As "List";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) writes a list (each element is one separate line) to a text file.";
      EXAMPLE = "";

    End_Function 

    

    Function "ReadCString"___("FilePathOrURL As String") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) loads an entire file from a path or on a website into a string. The file is expected to be encoded in ISO 8859-1.";
      EXAMPLE = "";

    End_Function

    

    Function "WriteCString"___("Argument As String, FilePathOrURL As String") As "Boolean";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) saves the entire string in a file to a given path. URL is not supported yet. The file is encoded in ISO 8859-1.";
      EXAMPLE = "";

    End_Function

    

    Function "LTrim"___("Argument As String") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) removes the source string's leading spaces, from the beginning of the source string. ";
      EXAMPLE = ""
""
"Dim x As String\n"
"x = \"     My house is on fire.\"\n"
"MsgBox(LTrim(x))\n"
"\n"
"' Output:\n"
"' My house is on fire.\n"
""
"";

    End_Function

    

    Function "RTrim"___("Argument As String") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) removes the source string's trailing spaces, from the end of the source string. ";
      EXAMPLE = ""
""
"MsgBox(\"test...\" & \"  bedazzeled  \" & \"...test\")\n"
"MsgBox(\"test...\" & RTrim(\"  bedazzeled  \") & \"...test\")\n"
""
"";

    End_Function

    

    Function "Drives"___("") As "List";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "Decimal"___("Expression As id, Locale As Boolean = False") As "Decimal" Alias "CDec" Alias "CCur";

      GROUP =  "Conversion";
      SEEALSO = "";
      COMMENT = "Tries to convert an expression to a Decimal. Locale is ignored for now. ";
      EXAMPLE = ""
""
"MsgBox(Str(239.546))\n"
""
"";

    End_Function

    

    Function "DateTime"___("Expression As id, Locale As Boolean = False") As "DateTime" Alias "CDate";

      GROUP =  "Conversion";
      SEEALSO = "";
      COMMENT = "Tries to convert an expression to a DateTime. Locale is ignored for now. ";
      EXAMPLE = "";

    End_Function

    

    Function "InputBox"___("Prompt As String [, Title As String] [, Default As String]") As "String";

      GROUP =  "ui";
      SEEALSO = "";
      COMMENT = "Get a string from the user using an input box on screen. ";
      EXAMPLE = ""
""
"Dim Msg, Titel, default2, val1\n"
"\n"
"Msg = \"Input value between 1 and 3\"\n"
"Titel = \"InputBox-Demo\"\n"
"default2 = \"1\"\n"
"\n"
"val1 = InputBox(Msg)\n"
"\n"
"MsgBox(\"You have inputted: \" + val1)\n"
""
"";
    End_Function

    

    Sub "Quit"___("");

      GROUP =  "";
      SEEALSO = "";
      COMMENT = "The Quit function is implemented using the Qt function qcoreapplication.html#quit.";
      EXAMPLE = "";

    End_Sub

    

    Sub "Beep"___("");

      GROUP =  "";
      SEEALSO = "";
      COMMENT = "Produces a sound. Depends on the system if it works. The Beep function is implemented using the Qt function qapplication.html#beep.\nYou may use Application.PlaySound(String) instead.";
      EXAMPLE = "";

    End_Sub

    

    Function "Date"___("") As "String";

      GROUP =  "DateTime";
      SEEALSO = "Time";
      COMMENT = "Returns the current system date as string. Setting the date is not possible with this function. Format is yyyy-MM-dd.";
      EXAMPLE = "";

    End_Function

    

    Function "Time"___("") As "String";

      GROUP =  "DateTime";
      SEEALSO = "Date";
      COMMENT = "Returns the current date as string. Setting the time is not possible with this function.";
      EXAMPLE = "";

    End_Function

    

    Function "Now"___("") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the current date and time as date time. ";
      EXAMPLE = ""
""
"MsgBox(Now())\n"
""
"";
    End_Function

    

    Function "TimeValue"___("String") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns a time given in a string expression as a date.  ";
      EXAMPLE = ""
""
"Dim Time1 \n"
"Time1 = TimeValue(\"4:35:17\") ' return time string as datetime\n"
""
"";
    End_Function

    

    Function "TimeSerial"___("Hour As Integer, Minute As Integer, Second As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns a time as a integer.  ";
      EXAMPLE = ""
""
"Dim Time1 \n"
"Time1 = TimeSerial(16, 35, 17) ' in integer format --> 16:35:17\n"
""
"";
    End_Function

    

    Function "FormatDateTime"___("DateTime, Format As String = \"yyyy-MM-dd hh:mm:ss\"") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "DateValue"___("String") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Converts a date given in a string into a date type. ";
      EXAMPLE = ""
""
"Dim Date1 As DateTime\n"
"Date1 = DateValue(\"1979-02-03\")\n"
""
"";

    End_Function

    

    Function "DateSerial"___("Year As Integer, Month As Integer, Day As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Converts a date given by year, month and day into a big number. ";
      EXAMPLE = ""
""
"Dim Date1 As DateTime\n"
"Date1 = DateSerial(1969, 2, 12)' return Date1\n"
""
"";

    End_Function

    

    Function "DatePart"___("DateTime, Interval As String") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "DateAdd DatePart DateSerial DateValue";
      COMMENT = "Returns the desired part of a date. \n\ninterval values:\n"
"    yyyy year\n"
"    q quarter\n"
"    M month\n"
"    y day of year\n"
"    d day\n"
"    w weekday\n"
"    ww week\n"
"    h hour\n"
"    n minute\n"
"    s second\n"
"";
      EXAMPLE = ""
""
"Dim Date1 As DateTime\n"
"Dim Msg\n"
"Date1 = InputBox(\"Input a date:\")\n"
"Msg = \"quarter: \" & DatePart(\"q\", Date1)\n"
"MsgBox(Msg)\n"

""
"";

    End_Function

    

    Function "DateDiff"___("DateTime, DateTime, Interval As String") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "DateAdd DatePart DateSerial DateValue";
      COMMENT = "Returns the number of interval laying between date1 and date2. \n\ninterval values:\n"
"    yyyy year\n"
"    q quarter\n"
"    M month\n"
"    y day of year\n"
"    d day\n"
"    w weekday\n"
"    ww week\n"
"    h hour\n"
"    n minute\n"
"    s second\n"
"";
      EXAMPLE = "";

    End_Function

    

    Function "DateAdd"___("DateTimeToChange As DateTime, Interval As String, Number As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "DatePart DateSerial DateValue";
      COMMENT = "Adds something to a date. \n\ninterval values:\n"
"    yyyy year\n"
"    q quarter\n"
"    M month\n"
"    y day of year\n"
"    d day\n"
"    w weekday\n"
"    ww week\n"
"    h hour\n"
"    n minute\n"
"    s second\n"
"";
      EXAMPLE = ""
""
"Dim Date1 As DateTime\n"
"Dim Interval As String\n"
"Dim Number As Integer\n"
"Dim Msg\n"
"Interval = \"m\"\n"
"Date1 = InputBox(\"Input the date\") ' #yyyy-MM-dd#\n"
"Number = Val(InputBox(\"Input the number of months to add\"))\n"
"Msg = \"New date: \" & DateAdd(Interval, Number, Date1)\n"
"MsgBox(Msg)\n"
""
"";

    End_Function

    

    Function "DiffSeconds"___("DateTime, DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "DiffDays"___("DateTime, DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "WeekNumber"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "MonthName"___("DateTime, LongMonthName As Boolean = True") As "String";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Format may be short or long. If no Format is given, LongMonthName is used.";
      EXAMPLE = ""
""
"Dim strMonatsname \n"
"strMonatsname = MonthName(1)  ' January\n"
"strMonatsname = MonthName(1, True)  ' Jan\n"
""
"";

    End_Function

    

    Function "DaysInYear"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "DaysInMonth"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "DayOfYear"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "DayOfWeek"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "DayName"___("DateTime, LongDayName As Boolean = True") As "String" Alias "WeekdayName";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the name of the given weekday. ";
      EXAMPLE = "";

    End_Function

    

    Function "Second"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the second part of a datetime expression. ";
      EXAMPLE = "";

    End_Function

    

    Function "Minute"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the minute part of a datetime expression. ";
      EXAMPLE = "";

    End_Function

    

    Function "Hour"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the hour part of a datetime object. ";
      EXAMPLE = "";

    End_Function

    

    Function "Month"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the month part of a date expression. ";
      EXAMPLE = "";

    End_Function

    

    Function "Year"___("DateTime") As "Integer";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the year of a date. ";
      EXAMPLE = "";

    End_Function

    

    Function "Day"___("DateTime") As "Integer" Alias "Weekday";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "Returns the day part of an date expression. ";
      EXAMPLE = ""
""
"Dim Date1, Day1\n"
"Date1 = DateValue(\"1979-02-12\")\n"
"Day1 = Day(Date1) ' --> 12\n"
""
"";

    End_Function

    

    Function "IsDateTimeValid"___("DateTime") As "Boolean";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "IsDateValid"___("DateTime") As "Boolean";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "IsTimeValid"___("DateTime") As "Boolean";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SubYears"___("DateTime, Years As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SubSeconds"___("DateTime, Seconds As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SubMonths"___("DateTime, Months As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SubMinutes"___("DateTime, Minutes As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SubHours"___("DateTime, Hours As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "SubDays"___("DateTime, Days As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "AddYears"___("DateTime, Years As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "AddSeconds"___("DateTime, Seconds As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "AddMonths"___("DateTime, Months As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "AddMinutes"___("DateTime, Minutes As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "AddHours"___("DateTime, Hours As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "AddDays"___("DateTime, Days As Integer") As "DateTime";

      GROUP =  "DateTime";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Sub "DoEvents"___("[MaxTime As Integer]");

      GROUP =   "";
      SEEALSO = "";
      COMMENT = "DoEvents() processes GUI events of the application.";
      EXAMPLE = "";

    End_Sub

    

    FakeFunction "MsgBox"___("[Title As id,] Message As id [, Buttons As Integer] VB6 compatibility mode: Prompt As String [, VBButtons As Integer [, Title As String]]") As "Integer"; Alias "Alert";

      GROUP =  "ui";
      SEEALSO = "InputBox";
      COMMENT = ""
"Prints a message in a GUI dialog box. \n"
"\n"
"VB6 compatibility mode - buttons:\n"
"\n"
"    vbOKOnly 0 show only [OK].\n"
"    vbOKCancel 1 show [OK] and [Cancel]\n"
"    vbAbortRetryIgnore 2\n"
"    vbYesNoCancel 3\n"
"    vbYesNo 4\n"
"    vbRetryCancel 5\n"
"    vbCritical 16 Stop symbol\n"
"    vbQuestion 32 question mark symbol\n"
"    vbExclamation 48 exclamation mark symbol\n"
"    vbInformation 64 information mark symbol\n"
"    vbDefaultButton1 0\n"
"    vbDefaultButton2 256\n"
"    vbDefaultButton3 512\n"
"\n"
"VB6 compatibility mode - return values:\n"
"\n"
"    vbOK 1 OK\n"
"    vbCancel 2 Cancel\n"
"    vbAbort 3 Abort\n"
"    vbRetry 4 Retry\n"
"    vbIgnore 5 Ignore\n"
"    vbYes 6 Yes\n"
"    vbNo 7 No\n"
"";

      EXAMPLE = ""
""
"' text in richtext is possible as well\n"
"'n = MsgBox(\"<b>message</b> or <i>not</i>\", vbOKOnly, \"title text\")\n"
"'n = MsgBox(\"message\", vbOKOnly, \"title text\")\n"
"'n = MsgBox(\"message\", vbOKCancel, \"title text\")\n"
"'n = MsgBox(\"message\", vbAbortRetryIgnore, \"title text\")\n"
"'n = MsgBox(\"message\", vbYesNoCancel, \"title text\")\n"
"'n = MsgBox(\"message\", vbYesNo, \"title text\")\n"
"'n = MsgBox(\"message\", vbRetryCancel, \"title text\")\n"
"'    \n"
"'n = MsgBox(\"message\", vbOKOnly Or vbCritical, \"title text\")\n"
"'n = MsgBox(\"message\", vbOKOnly Or vbQuestion, \"title text\")\n"
"'n = MsgBox(\"message\", vbOKCancel Or vbExclamation, \"title text\")\n"
"'n = MsgBox(\"message\", vbOKOnly Or vbInformation, \"title text\")\n"
"'    \n"
"'n = MsgBox(\"message\", vbYesNoCancel Or vbDefaultButton1, \"title text\")\n"
"'n = MsgBox(\"message\", vbYesNoCancel Or vbDefaultButton2, \"title text\")\n"
"'n = MsgBox(\"message\", vbAbortRetryIgnore Or vbDefaultButton3, \"title text\")\n"
"'\n"
"n = MsgBox(\" to save succeeding generations from the scourge of war, which twice in our lifetime\", vbOKOnly, \"WE THE PEOPLES\")\n"
""
"";
    End_FakeFunction

    

    Function "Section"___("Argument As String, Separator As String, Start As Integer, End As Integer = -1, SectionFlags As Integer = SectionDefault") As "String";

      GROUP =  "String";
      SEEALSO = "";
      COMMENT = "$(...) returns a section of the string (section flags are: SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps).";
      EXAMPLE = "";

    End_Function

            

            Function "Launch"___("FilePath As String, Arguments As List, WorkingDirectory As String = \"\", Wait As Boolean = False") As "Integer";

              GROUP =   "File";
              SEEALSO = "Run";
              COMMENT = "If Wait = True, the executed command blocks until the command finished execution. If blocking works depends on the application started.";
              EXAMPLE = "";

            End_Function

                    

                    Function "Split"___("Argument As String, Separator As String, CaseSensitive As Boolean = True") As "List";

                      GROUP =  "String";
                      SEEALSO = "";
                      COMMENT = "$(...) returns a list containing string objects from the given string, which have been separated by a string pattern. This works a little different than the VB6 Split function, because the return value is not String() - but a list of String.";
                      EXAMPLE = "";

                    End_Function


                            

                            Function "Run"___("FilePath As String, Arguments As List") As "String";

                              GROUP =   "File";
                              SEEALSO = "Launch";
                              COMMENT = "";
                              EXAMPLE = "";

                            End_Function


                                    

                                    Function "ReadString"___("FilePathOrURL As String [, Encoding As String]") As "String";

                                      GROUP =  "String";
                                      SEEALSO = "";
                                      COMMENT = "$(...) loads an entire file from a path or on a website into a string. The file is expected to be encoded in UTF-8.";
                                      EXAMPLE = "";

                                    End_Function

                                    

                                    Function "WriteString"___("Argument As String, FilePathOrURL As String [, Encoding As String]") As "Boolean";

                                      GROUP =  "String";
                                      SEEALSO = "";
                                      COMMENT = "$(...) saves the entire string in a file to a given path. URL is not supported yet. The file is encoded in UTF-8.";
                                      EXAMPLE = "";

                                    End_Function

                                            

                                            Function "Join"___("Argument As List, Separator As String") As "String";

                                              GROUP =  "String";
                                              SEEALSO = "";
                                              COMMENT = "$(...) returns a string, which consists of all elements of a list changed to a string. Between each of them is a given separator string.";
                                              EXAMPLE = "";

                                            End_Function


                                                    

                                                    FakeSub "stdout"___("Argument As id [, ...]") Alias "Log";

                                                      GROUP =   "";
                                                      SEEALSO = "MsgBox";
                                                      COMMENT = "$(...) writes information to the standard output channel.\nVery useful for debugging during application development.\nIts output is visible in the log window in the IDE of Q7Basic.";
                                                      EXAMPLE = "";

                                                    End_FakeSub

                                                    

                                                    FakeSub "stderr"___("Argument As id [, ...]");

                                                      GROUP =   "";
                                                      SEEALSO = "MsgBox";
                                                      COMMENT = "$(...) writes information to the standard error channel.";
                                                      EXAMPLE = "";

                                                    End_FakeSub


                                                            

                                                            Function "IsNull"___("Expression As id") As "Boolean";

                                                              GROUP =   "id";
                                                              SEEALSO = "";
                                                              COMMENT = "Returns true if the expression represents null.";
                                                              EXAMPLE = ""
                                                        ""
                                                        "Dim o As Object\n"
                                                        "\n"
                                                        "o = Null\n"
                                                        "\n"
                                                        "MsgBox(IsNull(o))\n"
                                                        ""
                                                        "";

                                                            End_Function
    

    Function "Left"___("Argument As String, Position As Integer") As "String"; //Alias "test" Alias "test2";

      GROUP   = "String";
      SEEALSO = "Right, Mid";
      COMMENT = "$(...) returns the leftmost part of a string containing 'Position' number of characters. ";
      EXAMPLE = ""
""
"Dim src As String\n"
"src = \"What a nice day\"\n"
"MsgBox(Left(src, 4))\n"
"";

    End_Function

    

    Function "IsEqualObject"___("Argument As id, 2ndArgument As id") As "Boolean";

      GROUP =   "";
      SEEALSO = "IsEqualClass, IsEqualValue";
      COMMENT = "Returns a Boolean '''value''' that indicates whether both objects are equal.";
      EXAMPLE = "";

    End_Function

    

    Function "IsEqualClass"___("Argument As id, 2ndArgument As id") As "Boolean";

      GROUP =   "";
      SEEALSO = "IsEqualObject, IsEqualValue";
      COMMENT = "Returns a Boolean '''value''' that indicates both objects are of the same class type.";
      EXAMPLE = "";

    End_Function

    

    Function "IsEqualValue"___("Argument As id, 2ndArgument As id") As "Boolean";

      GROUP =   "";
      SEEALSO = "IsEqualClass, IsEqualObject";
      COMMENT = "Returns a Boolean value that indicates whether both objects variables point to the same object.";
      EXAMPLE = "";

    End_Function

    

    Function "ClassName"___("Expression As id") As "String";

      GROUP =   "id";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

      
    End_Function




    

    Function "FileName"___("Argument As String") As "String";

      GROUP =   "String";
      SEEALSO = "";      
      COMMENT = "$(...) is useful if you have to deal with filename in a string. It returns only the parts of the string, which are the name of the file name of a given string leaving out the full path.";
      EXAMPLE = "";

    End_Function

            

            Function "FileExtension"___("Argument As String") As "String";

              GROUP =   "String";
              SEEALSO = "";
              COMMENT = "$(...) returns the name of the file extension of a given string, which is expected to contain a file name.";
              EXAMPLE = "";

            End_Function

            

            Function "FilePath"___("Argument As String") As "String";

              GROUP =   "String";
              SEEALSO = "";
              COMMENT = "$(...) returns the path information of a given string, which is expected to contain a path with a file name.";
              EXAMPLE = "";

            End_Function



    // ----------------------------------------------------------------------------------------------------------------------------

    Function "PlaySound"___("FileName As String") As "String";

      GROUP =   "";
      SEEALSO = "PlayMovie";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "PlayMovie"___("FileName As String") As "String";

      GROUP =   "";
      SEEALSO = "PlaySound";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "FileBaseName"___("Argument As String") As "String";

      GROUP =   "String";
      SEEALSO = "";      
      COMMENT = "$(...) is useful if you have to deal with filename in a string. It returns only the parts of the string, which are the name of the file name without the extension of a given string leaving out the full path.";
      EXAMPLE = "";

    End_Function


    

    Function "IsDir"___("Argument As String") As "Boolean";

      GROUP =   "File";
      SEEALSO = "IsFile";      
      COMMENT = "$(...) returns true if the given filename points to a directory.";
      EXAMPLE = "";

    End_Function

    

    Function "IsList"___("Argument As id") As "Boolean";

      GROUP =   "Conversion";
      SEEALSO = "";      
      COMMENT = "Returns true if a variable or an expression represents a list type. ";
      EXAMPLE = ""
""
"Dim i As List\n"
"Dim x As String\n"
"\n"
"MsgBox(IsList(i))\n"
"MsgBox(IsList(x))\n"
""
"";
    End_Function

    

    Function "IsBoolean"___("Argument As id") As "Boolean";

      GROUP =   "Conversion";
      SEEALSO = "";      
      COMMENT = "Returns true if a variable represents a boolean type";
      EXAMPLE = ""
""
"Dim x As Boolean\n"
"\n"
"Print IsBoolean(x)\n"
""
"";

    End_Function

    

    Function "IsInteger"___("Argument As id") As "Boolean" Alias "IsByte" Alias "IsShort" Alias "IsInt8" Alias "IsInt16" Alias "IsInt32" Alias "IsInt64";

      GROUP =   "Conversion";
      SEEALSO = "";      
      COMMENT = "Returns true if a variable represents an integer (Byte, Short...) type.";
      EXAMPLE = ""
"\n"
"Dim i As Byte \n"
"Dim x As String\n"
"\n"
"Print IsByte(i) \n"
"Print IsByte(x)\n"
""
""
"Dim x As Boolean\n"
"\n"
"Print IsBoolean(x)\n"
"";

    End_Function

    

    Function "IsFloat"___("Argument As id") As "Boolean" Alias "IsSingle" Alias "IsDouble";

      GROUP =   "Conversion";
      SEEALSO = "";      
      COMMENT = "Returns true if a variable represents a float type. ";
      EXAMPLE = ""
""
"Dim i As Float\n"
"Dim x As String\n"
"\n"
"Print IsFloat(i) \n"
"Print IsFloat(x)\n"
""
"";

    End_Function

    
    
    Function "IsString"___("Argument As id") As "Boolean";

      GROUP =   "Conversion";
      SEEALSO = "";      
      COMMENT = "Returns true if expression represents a string value. ";
      EXAMPLE = ""
""
"Dim i As Integer\n"
"Dim k As String\n"
"\n"
"MsgBox(IsString(i))\n"
"MsgBox(IsString(k))\n"
""
"";

    End_Function


    
      
    Sub "Randomize"___("");

      GROUP =   "Math";
      SEEALSO = "Random";      
      COMMENT = "$() restarts the internal random number generator based on the current local system time. Using it only makes sense, if you want to use the Random() function as well.";
      EXAMPLE = "";

    End_Sub



            // ----------------------------------------------------------------------------------------------------------------------------

            Function "Shell"___("Command As String") As "Integer";

              GROUP =   "File";
              SEEALSO = "Run";
              COMMENT = "Sends a command to the shell of the underlying operating system (internally uses the C function system(...)).";
              EXAMPLE = "";

            End_Function

            

            Function "OpenURL"___("PathOrURL As String") As "Boolean";

              GROUP =  "ui";
              SEEALSO = "";
              COMMENT = "";
              EXAMPLE = "";

            End_Function




    
        
    Function "Random"___("[Argument As Float]") As "Float" Alias "RND";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) returns a float pseudo-random number. If an argument is given random values between 0 and the argument are returned only. If no argument is given, the next random number in the list is created and returned. If you use $(...) the first time and you have not called Randomize() before, it is automatically called and new random numbers are created.";
      EXAMPLE = ""
""
"Randomize\n"
"Dim x, y\n"
"x = Int(Random(6)) + 1 \n"
"y = Int(Random(6)) + 1 \n"
"MsgBox(\"2 turns with one dice: turn 1 = \" & x & \" and turn 2 = \" & y)\n"
""
"";

    End_Function

    
        
    Function "BitClr"___("Value As Integer, Position As Integer") As "Integer";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) lets you set a single bit of an integer value to 0.";
      EXAMPLE = "";

    End_Function

    
        
    Function "BitSet"___("Value As Integer, Position As Integer") As "Integer";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) lets you set a single bit of an integer value to 1.";
      EXAMPLE = "";

    End_Function

    
        
    Function "BitTst"___("Value As Integer, Position As Integer") As "Integer";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) lets you retrieve a single bit of an integer value.";
      EXAMPLE = "";

    End_Function

    
        
    Function "Abs"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Atn";      
      COMMENT = "$(...) returns the absolute value of the given argument.";
      EXAMPLE = "";
      
    End_Function

    
        
    Function "Atn"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Atn";      
      COMMENT = "$(...) returns the principal arc tangent of x, in the interval [-pi/2,+pi/2] radians.";
      EXAMPLE = "";

    End_Function

    
        
    Function "Cos"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) returns the cosine of the argument in radians.";
      EXAMPLE = ""
""
"  Const PI = 3.141592654\n"
"  Print Atn(Tan(PI / 4.0)), PI / 4.0 'result: .7853981635 .7853981635\n"
"  Print (Cos(180 * (PI / 180))) 'result: -1\n"
"  Print (Sin(90 * (PI / 180))) 'result: 1\n"
"  Print (Tan(45 * (PI / 180))) 'result: 1.000000000205103\n"
""
"";

    End_Function

    
        
    Function "Sin"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) returns the sine of the argument 'number' in radians.";
      EXAMPLE = ""
""
"  Const PI = 3.141592654\n"
"  Print Atn(Tan(PI / 4.0)), PI / 4.0 'result: .7853981635 .7853981635\n"
"  Print (Cos(180 * (PI / 180))) 'result: -1\n"
"  Print (Sin(90 * (PI / 180))) 'result: 1\n"
"  Print (Tan(45 * (PI / 180))) 'result: 1.000000000205103\n"
""
"";

    End_Function

    
        
    Function "Exp"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Log10";      
      COMMENT = "$(...) returns the base-e exponential function of x, which is the e number raised to the power x.";
      EXAMPLE = ""
""
"MsgBox(Exp(0), Exp(1)) 'result: 1 2.718282\n"
"MsgBox(Log10(1), Log10(Exp(1))) 'result: 0 1\n"
""
"";

    End_Function

	
	



    
        
    Function "Ln"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Log10";      
      COMMENT = "$(...) returns the natural logarithm of the given argument. The Ln function calculates the base 'e' (or natural) logaritm of a number. Input number must be a positive (i.e. > 0). ";
      EXAMPLE = ""
""
"Dim x As Integer\n"
"x = 12\n"
"MsgBox(Ln(x))\n"
""
"";

    End_Function

    
    
    Function "Log10"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Ln";      
      COMMENT = "$(...) returns the common (base-10) logarithm of the given argument (calculates the ten-based logarithmic of a number). Input number must be a positive (i.e. > 0).";
      EXAMPLE = "";

    End_Function

    
    
    Function "Fix"___("Argument As Float") As "Integer";

      GROUP =  "Math";
      SEEALSO = "Int, CInt, CLng";      
      COMMENT = "$(...) removes the fraction part of a real number and returns the Integer portion only.";
      EXAMPLE = ""
""
"MsgBox(Fix(12.49), Fix(12.54)) ' both results are : 12 \n"
""
"";

    End_Function

    
    
    Function "Int"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Fix CInt";      
      COMMENT = "$(...) returns the largest integer value that is not greater than the given argument (returns the next integer number <= given number). ";
      EXAMPLE = ""
""
"Dim n As Integer\n"
"\n"
"n = Int(12.54)\n"
"MsgBox(n)\n"
"\n"
"n = Int(-99.4)\n"
"MsgBox(n)\n"
""
"";

    End_Function

    
    
    Function "Sqr"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Fix CInt";      
      COMMENT = "$(...) returns the square root of the argument 'number'.";
      EXAMPLE = ""
""
"MsgBox(Sqr(25), Sqr(2)) 'results: 5 1.414214\n"
""
"";

    End_Function

    
    
    Function "Tan"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) returns the tangent of the argument 'number' in radians.";
      EXAMPLE = "";

    End_Function

    
    
    Function "Min"___("Value1 As Float, Value2 As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Max";      
      COMMENT = "$(...) compares two values and returns the smaller one. Both values are treated as Float values.";
      EXAMPLE = "";

    End_Function

    
    
    Function "Max"___("Value1 As Float, Value2 As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "Min";      
      COMMENT = "$(...) compares two values and returns the bigger one. Both values are treated as Float values.";
      EXAMPLE = ""
""
"MsgBox(44, 4)\n"
""
"";

    End_Function

    
    
    Function "Fact"___("Argument As Float") As "Float";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) is implemented as follows:";
      EXAMPLE = ""
""
"Function test()\n"
"  Dim x As Float\n"
"  Dim y As Float\n"
"\n"
"  y = 1\n"
"  For x = 1 To argument\n"
"    y = y * x\n"
"  Next\n"
"  Return y\n"
"End Function\n"
""
"";

    End_Function


    
    
    Function "Round"___("Argument As Float, Precision As Integer") As "Float";

      GROUP =  "Math";
      SEEALSO = "";      
      COMMENT = "$(...) rounds a value, while Precision determines the number of digits after the decimal point.";
      EXAMPLE = ""
""
"MsgBox(Round(34.45D, 2))\n"
"MsgBox(Round(34.456D, 2))\n"
"MsgBox(Round(34.451D, 2))\n"
"MsgBox(Round(34.4567D, 2))\n"
"MsgBox(Round(34.4561D, 2))\n"
"MsgBox(Round(34.4517D, 2))\n"
"\n"
"MsgBox(Round(34.4567D, 3))\n"
"MsgBox(Round(34.4517D, 3))\n"
"MsgBox(Round(34.4567D, 4))\n"
"MsgBox(Round(34.4561D, 4))\n"
""
"";
    End_Function

    
    
    Function "Nz"___("Argument As id, ReturnValue As id = \"\"") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) checks for null and returns an empty string (nullstring), if needed. ";
      EXAMPLE = ""
""
"Function test()\n"
"  Return Null  \n" 
"End Function\n"
"\n"
"MsgBox(\"'_\" + Nz(test()) + \"_'\" ' --> \"\")\n"
""
"";
    End_Function


            

            Function "Space"___("Count As Integer, FillWith As String = \" \"") As "String";

              GROUP =  "String";
              SEEALSO = "";
              COMMENT = "$(...) function creates a string consisting of spaces (or other characters) based on x length.";
              EXAMPLE = ""
        ""
        "MsgBox(\"*\" + Space(5) + \"*\")\n"
        "\n"
        "' Output:\n"
        "' * *\n"
        "\n"
        "MsgBox(Space$(4.3 + 2))\n"
        "\n"
        "MsgBox(\"*\" + Space(5) + \"*\")\n"
        ""
        "";
            End_Function




    // ----------------------------------------------------------------------------------------------------------------------------
    
    Function "Truncate"___("Argument As String, Position As Integer") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) cut off the string at the given position index and returns it.";
      EXAMPLE = "";

    End_Function

            

            Function "IsEmpty"___("Argument As String") As "Boolean";

              GROUP =  "String";
              SEEALSO = "";
              COMMENT = "$(...) returns true if a string contains any character.";
              EXAMPLE = "";

            End_Function

    

    Function "ReadArray"___("FilePathOrURL As String") As "Array";

      GROUP =  "Array";
      SEEALSO = "";
      COMMENT = "$(...) loads an entire file from a path or on a website into an array. NOT IMPLEMENTED YET.";
      EXAMPLE = "";

    End_Function

    

    Function "WriteArray"___("Argument As Array, FilePathOrURL As String") As "Boolean";

      GROUP =  "Array";
      SEEALSO = "";
      COMMENT = "$(...) saves the entire Array in a file to a given path. NOT IMPLEMENTED YET.";
      EXAMPLE = "";

    End_Function

    
    
    Function "ReadDictionary"___("FilePathOrURL As String") As "Dictionary";

      GROUP =  "Dictionary";
      SEEALSO = "";      
      COMMENT = "$(...) loads an entire file from a path or on a website into a Dictionary. You may even read html webpages with this function.";
      EXAMPLE = "";

    End_Function

    
    
    Function "WriteDictionary"___("Argument As Dictionary, FilePathOrURL As String") As "Boolean";

      GROUP =  "Dictionary";
      SEEALSO = "";      
      COMMENT = "$(...) saves the entire Dictionary in a file to a given path. ";
      EXAMPLE = "";

    End_Function


    
    
    Function "Len"___("Argument As String") As "Integer" Alias "Length";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns the length of a string.";
      EXAMPLE = "";

    End_Function

    
    
    Function "Reversed"___("Argument As String") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a given string reversed.";
      EXAMPLE = "";

    End_Function

    
    
    Function "At"___("Argument As String, Index As Integer") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a single character from a given string as a string with the length 1 starting at the specified index argument.";
      EXAMPLE = "";

    End_Function

    
    
    Function "Unicode"___("Argument As String [, Index As Integer]") As "Integer" Alias "Asc";

      GROUP =  "String";
      SEEALSO = "Chr";      
      COMMENT = "$(...) returns the unicode integer value of an character at the given position inside a string.";
      EXAMPLE = "";

    End_Function



    // ----------------------------------------------------------------------------------------------------------------------------

    FakeFunction "File"___("FilePath As String") As "Boolean";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_FakeFunction

    

    Function "Dir"___("FilePath As String [, Create As Boolean]") As "Boolean";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "Unlike the VB6 Dir function this function, tests if a directory exists. Look at the Dir object for directory listening.";
      EXAMPLE = "";

    End_Function

    

    Function "Copy"___("SourceFilePath As String, DestinationFilePath As String") As "Boolean";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "CopyDir"___("SourceFilePath As String, DestinationFilePath As String") As "Boolean";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "Move"___("SourceFilePath As String, DestinationFilePath As String") As "Boolean" Alias "Rename" Alias "Name";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    

    Function "Delete"___("FilePath As String") As "Boolean" Alias "Kill";

      GROUP =  "File";
      SEEALSO = "";
      COMMENT = "";
      EXAMPLE = "";

    End_Function

    
    
    Function "Float"___("Expression As id, Locale As Boolean = False") As "Float" Alias "CDbl" Alias "CSng";

      GROUP =  "Conversion";
      SEEALSO = "CSng, CInt, CLng";      
      COMMENT = "Tries to convert an expression to a Float. Locale is ignored for now.";
      EXAMPLE = "";

    End_Function

    
    
    Function "Boolean"___("Expression As id, Locale As Boolean = False") As "Boolean" Alias "CBool";

      GROUP =  "Conversion";
      SEEALSO = "";      
      COMMENT = "Tries to convert an expression to a boolean. Locale is ignored for now.";
      EXAMPLE = "";

    End_Function

    
    
    Function "String"___("Expression As id, Locale As Boolean = False") As "String" Alias "Str";

      GROUP =  "Conversion";
      SEEALSO = "";      
      COMMENT = "Converts a number to a string. Locale is ignored for now.";
      EXAMPLE = ""
""
"MsgBox(Str(239.546))\n"
""
"";

    End_Function

    
    
    Function "QStringList"___("Expression As id, Locale As Boolean = False") As "QStringList";

      GROUP =  "Conversion";
      SEEALSO = "";      
      COMMENT = "";
      EXAMPLE = "";

    End_Function


    
    
    Function "Integer"___("Expression As id, Locale As Boolean = False") As "Integer" Alias "CByte" Alias "CInt" Alias "CLng" Alias "CShort";

      GROUP =  "Conversion";
      SEEALSO = "";      
      COMMENT = "Tries to convert an expression to an integer type. This will remove any precision from a float value. Locale is ignored for now.";
      EXAMPLE = "";

    End_Function

    
    
    FakeFunction "Mid"___("Argument As String, Index As Integer, Length As Integer = -1") As "String";

      GROUP =  "String";
      SEEALSO = "Trim , InStr";      
      COMMENT = "$(...) returns a specific part of a string beginning at 'Index' for 'Length' number of charaters. ";
      EXAMPLE = ""
""
"Dim text\n"
"text = \"The dog bites the cat\"\n"
"\n"
"text = Mid$(text, 10, 1)\n"
"\n"
"MsgBox(text)\n"
"\n"
""
"";
    End_FakeFunction

    
    
    Function "StrReverse"___("Argument As String") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a all parts of a string mirrored. ";
      EXAMPLE = ""
""
"Dim s = \"Mondscheinsonate by Beethoven\"\n"
"MsgBox(StrReverse(s)) ' --> nevohteeB yb etanosniehcsdnoM\n"
""
"";
    End_Function

    
// nur tempror?r q7b only


    Function "Fill"___("Argument As String, Character As String, Length As Integer = -1") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) set characters of a string to some value. If Length is different from -1 (the default), the string is resized to size beforehand. ";
      EXAMPLE = "";

    End_Function
    
    
    
    Function "Insert"___("Argument As String, Position As Integer, StringToInsert As String") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) set characters of a string to some value.";
      EXAMPLE = "";

    End_Function

            

            Function "Simplified"___("Argument As String") As "String";

              GROUP =  "String";
              SEEALSO = "";
              COMMENT = "$(...) returns a string that has whitespace removed from the start and the end, and that has each sequence of internal whitespace replaced with a single space.";
              EXAMPLE = "";

            End_Function
            
    
    Function "Right"___("Argument As String, Position As Integer") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns the rightmost part of a string beginning at 'Position' (returns a string containing the last characters of a string).";
      EXAMPLE = ""
""
"MsgBox(Right(\"I'm living in Germany\", 7))\n"
"'MsgBox(Right(\"I'm living in Germany\", Len(\"Germany\")))\n"
""
"";

    End_Function




    
    
    Function "Trim"___("Argument As String") As "String" Alias "Trimmed";

      GROUP =  "String";
      SEEALSO = "LTrim , RTrim";      
      COMMENT = "$(...) returns a string, in which all whitespace characters at the beginning and end have been removed (removes the source string's leading and trailing spaces and other non-printable characters).";
      EXAMPLE = ""
""
"Dim x As String\n"
"x = \"   My house is on fire.   \"\n"
"MsgBox( \"test...\" & Trim( x ) & \"...test\")\n"
"\n"
"' Output:\n"
"' test...My house is on fire....test\n"
""
"";

    End_Function 


    
    
    Function "InStr"___("Argument As String, Search As String, Index As Integer = 0, CaseSensitive As Boolean = True") As "Integer" Alias "IndexOf";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns the position of the first occurrence of a given string inside another string starting from the beginning. It returns -1, if the string could not be found. First position in Source is referenced as 0.";
      EXAMPLE = ""
""
"Dim s As String\n"
"\n"
"s = \"Bernd Noetscher's Q7Basic\"\n"
"MsgBox( \"string position = \" & InStr(1, s, \"Q7Basic\") )\n"
""
"";

    End_Function 

    
    
    Function "InStrRev"___("Argument As String, Search As String, Index As Integer = -1, CaseSensitive As Boolean = True") As "Integer" Alias "LastIndexOf";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns the position of the first occurrence a given string inside another string starting from the end. It returns -1, if the string could not be found.";
      EXAMPLE = ""
""
"Dim x As String, y As String\n"
"\n"
"x = \"This is a string\"\n"
"y = \"s\"\n"
"\n"
"MsgBox(InStRev(x, y))\n"
""
"";

    End_Function 

    
    
    Function "Contains"___("Argument As String, Search As String, CaseSensitive As Boolean = True") As "Boolean";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) finds out if a given string is inside another string. Returns true if this Argument string contains an occurrence of the string Search; otherwise returns false.";
      EXAMPLE = "";

    End_Function 

    
    
    Function "Append"___("Argument As String, Append As String") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a new string as a combination of both given strings.";
      EXAMPLE = "";

    End_Function 

    
    
    Function "Prepend"___("Argument As String, Prepend As String") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a new string as a combination of both given strings.";
      EXAMPLE = "";

    End_Function 

    
    
    Function "LCase"___("Argument As String") As "String" Alias "Lower";

      GROUP =  "String";
      SEEALSO = "UCase";      
      COMMENT = "$(...) changes all characters of a string to lowercase. It then returns a copy of the string. ";
      EXAMPLE = ""
""
"Dim src As String\n"
"src = \"Mr. Big was HERE\"\n"
"MsgBox(LCase(src))\n"
"\n"
"' Output:\n"
"' mr. big was here\n"
""
"";

    End_Function 

    
    
    Function "UCase"___("Argument As String") As "String" Alias "Upper";

      GROUP =  "String";
      SEEALSO = "UCase";      
      COMMENT = "$(...) changes all characters of a string to uppercase (contains the source string converted to all upper case).";
      EXAMPLE = ""
""
"Dim src As String\n"
"src = \"Mr. Big was HERE\"\n"
"MsgBox(UCase( src ))\n"
"\n"
"' Output:\n"
"' MR. BIG WAS HERE\n"
""
"";

    End_Function 

    
    
    Function "Compare"___("Argument As String, Compare As String, CaseSensitive As Boolean = True") As "Integer";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) lexically compares this string with the other string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.";
 
      EXAMPLE = "";

    End_Function 

    
    
    Function "Replace"___("Argument As String, Search As String, Replace As String, CaseSensitive As Boolean = True") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) changes all occurrences of a string inside another string to a new string.";
      EXAMPLE = ""
""
"Dim s = \"Das ist alles was wir brauchen. Fang nochmal von vorne an.\"\n"
"Dim search = \"vorne\"\n"
"Dim replace = \"hinten\"\n"
"MsgBox(Replace(s, search, replace))\n"
""
"";

    End_Function 




    // ----------------------------------------------------------------------------------------------------------------------------
    
    Function "Remove"___("Argument As String, Position As Integer, Length As Integer") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) deletes n characters from the string, starting at the given position index and returns it.";
      EXAMPLE = "";

    End_Function 

            
    
    Function "Count"___("Argument As String, Search As String, CaseSensitive As Boolean = True") As "Integer";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) finds out how often a given string is inside another string.";
      EXAMPLE = "";

    End_Function 

    
    
    Function "StartsWith"___("Argument As String, Search As String, CaseSensitive As Boolean = True") As "Boolean";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) finds out if a given string starts with another string.";
      EXAMPLE = "";

    End_Function 

    
    
    Function "EndsWith"___("Argument As String, Search As String, CaseSensitive As Boolean = True") As "Boolean";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) finds out if a given string ends with another string. Returns true if the string Argument ends with Search; otherwise returns false.";
      EXAMPLE = "";

    End_Function 




    // ----------------------------------------------------------------------------------------------------------------------------
    
    Function "Bin"___("Argument As Integer") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "Bin returns a string giving the binary (base 2) representation. The return string has as many characters as necessary to represent the integer in binary.";
      EXAMPLE = ""
""
"MsgBox(Bin(128))\n"
""
"";

    End_Function 

            
    
    FakeFunction "Concat"___("Argument As id [, ...]") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) lets you join two or more strings.";
      EXAMPLE = "";

    End_FakeFunction

    
    
    Function "Character"___("Argument As Integer") As "String" Alias "Chr";

      GROUP =  "String";
      SEEALSO = "Asc";      
      COMMENT = "$(...) returns a unicode character as string for a given integer unicode value. (Or returns the ASCII character corresponding to the value of Val. Argument must be a numerical expression.)";
      EXAMPLE = "";

    End_Function 




    // ----------------------------------------------------------------------------------------------------------------------------
    
    Function "Value"___("Argument As String") As "Integer" Alias "Val";

      GROUP =  "String";
      SEEALSO = "Str";      
      COMMENT = "$(...) returns the numerical value of a string. ";
      EXAMPLE = ""
""
"MsgBox(Value(\"344\")) ' --> 344\n"
"MsgBox(Val(\"21st day\")) ' --> 21\n"
"MsgBox(Val(\"BASIC\")) ' --> 0\n"
""
"";
    End_Function 

            
    
    Function "Hex"___("Argument As Integer") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a string representing a long value as hexadecimal.";
      EXAMPLE = ""
""
"'Characters of Hex (0 - 9, A - F)\n"
"'\n"
"'Hexadecimal -> Decimal\n"
"'0 -> 0\n"
"'1 -> 1\n"
"'2 -> 2\n"
"'3 -> 3\n"
"'4 -> 4\n"
"'5 -> 5\n"
"'6 -> 6\n"
"'7 -> 7\n"
"'8 -> 8\n"
"'9 -> 9\n"
"'A -> 10\n"
"'B -> 11\n"
"'C -> 12\n"
"'D -> 13\n"
"'E -> 14\n"
"'F -> 15\n"
"'10 -> 16\n"
"Dim v = InputBox(\"Please type in a number: \")\n"
"MsgBox(\"The hexadecimal representation is \", Hex(v))\n"
""
"";

    End_Function 

    
    
    Function "Format"___("Argument As id, Locale As Boolean = False") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "$(...) returns a value as string formatted. The argument is usally a number. It is useful for formatting numbers. Locale is ignored for now.";
      EXAMPLE = "";

    End_Function 

    
    
    Function "FormatFloat"___("Argument As Float, Locale As Boolean = False, DecimalPlaceLength As Integer = 2") As "String";

      GROUP =  "String";
      SEEALSO = "";      
      COMMENT = "Rounds decimal place (5 - 9 round up, else no round up). Locale and DecimalPlaceLength is ignored for now. ";
      EXAMPLE = "";

    End_Function 
    
 }
  

}

bool Parser::parseBuiltinSubFunction(_expressions & ReturnExpression)
{    
  _BEGIN_

  QString sIdentifier;




  if (parseTerm("UBound")){
    sIdentifier = "UBound";
    goto ok;
  }

  if (parseTerm("LBound")){
    sIdentifier = "LBound";
    goto ok;
  }

  if (parseTerm("Mid")){
    sIdentifier = "Mid";
    goto ok;
  }

  if (Me.nLine == 352){
    Me.nLine = Me.nLine;
  }
  if (parseIdentifier(&sIdentifier) && !peekTerm(".")){
ok:
    if (sIdentifier == "QStringList"){
      sIdentifier = sIdentifier;
    }

  
    if (Me.subsfunctions.contains(sIdentifier) && !Me.subsfunctions_inits.contains(sIdentifier) && Me.comments_subsfunctions[sIdentifier]._Isfake.isEmpty()){
      
      

      _expressions Arguments;
      if (parseBuiltin_Procedure(sIdentifier, Me.subsfunctions[sIdentifier], Arguments)){

       
        //QString sdf = Compiler::decode(Arguments.Statements);


        QString sFunctionRealName;
        if (Me.subsfunctions_aliasrealname.contains(sIdentifier)) sFunctionRealName = Me.subsfunctions_aliasrealname[sIdentifier];
        else sFunctionRealName = sIdentifier;



        ReturnExpression.Statements << Compiler::pushBuiltinSubFunctionWithArguments(sFunctionRealName, ReturnExpression.bReturn, Arguments.Statements);

        
        //QString sdf55 = Compiler::decode(ReturnExpression.Statements);

        if (!ReturnExpression.bReturn){ 
           ReturnExpression.Statements << Compiler::push(";");
        }

         ReturnExpression.sType = Me.subsfunctions[sIdentifier][0];

     
     //   QString sjhdf = Compiler::decode(Arguments.Statements);

        return true;
      } else {
        if (ReturnExpression.bReturn){
          goto _init;
        }
        _END_
      }

    }



    if (sIdentifier == "MessageBox"){

      if (!parseTerm("(")){ _END_ } 
      
      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression;
      if (!parseExpressionInteger(Expression)){ error(""); return false; }

      if (!parseTerm(",")){ error(", expected"); _END_ }

      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression2;
      if (!parseExpressionString(Expression2)){ error(""); return false; }

      if (!parseTerm(",")){ error(", expected"); _END_ }

      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression3;
      if (!parseExpressionString(Expression3)){ error(""); return false; }

      if (!parseTerm(",")){ error(", expected"); _END_ }

      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression4;
      if (!parseExpressionString(Expression4)){ error(""); return false; }

      if (!parseTerm(",")){ error(", expected"); _END_ }

      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression5;
      if (!parseExpressionString(Expression5)){ error(""); return false; }

      if (!parseTerm(",")){ error(", expected"); _END_ }

      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression6;
      if (!parseExpressionid(Expression6)){ error(""); return false; }

      _expressions Expressions;
    
      while (parseTerm(",")){

        if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
        _expressions Expression7;
        if (!parseExpressionid(Expression7)){ error(""); return false; }
        Expressions.Statements << Compiler::pushExpression(Expression7.Statements);
     
      }


      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("MESSAGEBOX", ReturnExpression.bReturn, Expression.Statements, Expression2.Statements, Expression3.Statements, Expression4.Statements, Expression5.Statements, Expression6.Statements, Expressions.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");
      
	    if (!parseTerm(")")){ error(""); _END_ }     

      ReturnExpression.sType = "Integer";
      return true;
    }
  
    else if (sIdentifier == "Open"){
      if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

      bool bBC;
      if ((bBC = parseTerm("(")));

      _expressions Expression;
      if (!parseExpressionString(Expression)){ error(""); _END_ }        

      if (!parseTerm("For")){ error("'For' expected"); _END_ }         

      QString sMode;
      if (!parseIdentifier(&sMode)){ error("file mode expected"); _END_ }  
      if (sMode != "Input" && sMode != "Output" && sMode != "Append" && sMode != "Binary" && sMode != "Random"){ error("file mode invalid"); _END_ }  

      if (!parseIdentifier("Access")){ error("'Access' expected"); _END_ }  

      QString sAccess;
      if (!parseIdentifier(&sAccess)){ error("access mode expected"); _END_ }  
      if (sAccess != "Read" && sAccess != "Write" && sAccess != "ReadWrite"){ error("access mode invalid"); _END_ }  

      if (!parseTerm("As")){ error("'As' expected"); _END_ }         
      
      if (parseTerm("#")){} 

      _expressions Expression2;
      if (!parseExpressionInteger(Expression2)){ error(""); _END_ }          

      _expressions Expression3;
      if (parseIdentifier("Len")){
        if (!parseTerm("=")){ error("'=' expected"); _END_ }         

        if (!parseExpressionInteger(Expression3)){ error(""); _END_ }        
      } else Expression3.Statements = Compiler::pushInteger(-1);

      if (bBC && !parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("OPEN", ReturnExpression.bReturn, Expression.Statements, Compiler::pushString(sMode), Expression2.Statements, Expression3.Statements);
//      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("OPEN", Expression.Statements, Compiler::pushString(sMode), Expression2.Statements, Compiler::pushPointer(Expression3.Statements));
      if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      return true;
    }
    
    else if (sIdentifier == "Close"){
      if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

      bool bBC;
      if ((bBC = parseTerm("(")));

      if (parseTerm("#")){} 
      
      bool bEmpty = true;
      _expressions Expression;
      while (parseExpressionInteger(Expression)){
        ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("CLOSEFILE", ReturnExpression.bReturn, Expression.Statements);        
         if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

        if (parseTerm("#")){} 
      }

      if (bEmpty){
        ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("CLOSEALLFILES", ReturnExpression.bReturn);
         if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");
      }
      
      return true;
    }

    else if (sIdentifier == "Line"){
      if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

      if (!parseIdentifier("Input")){ goto screenline; }  

      bool bBC;
      if ((bBC = parseTerm("(")));

      if (parseTerm("#")){} 
      
      _expressions Expression;
      if (!parseExpressionInteger(Expression)){ error(""); _END_ }        

      if (!parseTerm(",")){ error(", expected"); _END_ }         

      _expressions Expression2;
      if (!parseExpressionid(Expression2)){ error(""); _END_ }        
 
      
     // QString safd = Compiler::decode(Compiler::pushCode("&") + Expression2.Statements);

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("LINEINPUT", ReturnExpression.bReturn, Expression.Statements, Compiler::pushCode("&") +Expression2.Statements);
      if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      return true;
    }

    if (sIdentifier == "EOF"){
      if (!ReturnExpression.bReturn){ _END_ } 

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
      if (!parseExpressionInteger(Expression)){ error(""); _END_ }        

      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("EOF", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "Boolean";
      return true;
    }

    else if (sIdentifier == "BLOB"){
      if (!ReturnExpression.bReturn){ _END_ } 

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
      if (!parseExpressionid(Expression)){ error(""); _END_ }        

      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("SQLBLOB", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
    }

    else if (sIdentifier == "BOOLEAN"){
      if (!ReturnExpression.bReturn){ _END_ } 

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
      if (!parseExpressionid(Expression)){ error(""); _END_ }        

      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("SQLBOOLEAN", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
    }
    else if (sIdentifier == "INTEGER"){
      if (!ReturnExpression.bReturn){ _END_ } 

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
      if (!parseExpressionid(Expression)){ error(""); _END_ }        

      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("SQLINTEGER", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
    }
    else if (sIdentifier == "FLOAT"){
      if (!ReturnExpression.bReturn){ _END_ } 

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
      if (!parseExpressionid(Expression)){ error(""); _END_ }        

      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("SQLFLOAT", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
    }
    else if (sIdentifier == "TEXT"){
      if (!ReturnExpression.bReturn){ _END_ } 

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
      if (!parseExpressionid(Expression)){ error(""); _END_ }        

      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("SQLTEXT", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
    }

      else if (sIdentifier == "Line"){
        if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

screenline:

                bool bTerm_STEP = false;
                bool bTerm_STEP2 = false;
                bool bTerm_COMMA = false;
                bool bEXPRESSION = false;
                bool bEXPRESSION2 = false;

                bool color = false;
                bool b = false;
                bool bf = false;
                bool style = false;

          bool bTerm_ = false;

                bool bTerm_SYM_BR_OP;
                bool bTerm_SYM_BR_CL;

          _expressions Expression;
          _expressions Expression2;
          _expressions Expression3;
          _expressions Expression4;
          _expressions Color;
          _expressions Style;

          if ((bTerm_STEP = parseTerm("Step"))){}

          if ((bTerm_SYM_BR_OP = parseTerm("("))){

            if (!(bEXPRESSION = parseExpressionInteger(Expression))){ error("integer expression missing"); _END_ }

            if (!(bTerm_COMMA = parseTerm(","))){ error(", missing"); _END_ }

            if (!(bEXPRESSION = parseExpressionInteger(Expression2))){ error("integer expression missing"); _END_ }

                  if (!(bTerm_SYM_BR_OP && (bTerm_SYM_BR_CL = parseTerm(")")))){ error(""); _END_ }

          } else if (bTerm_STEP){
            { error("x1, y1 missing"); _END_ }
          }

          if (!(bTerm_ = parseTerm("-"))){ error("- missing"); _END_ }

          if ((bTerm_STEP2 = parseTerm("Step"))){}

          if ((bTerm_SYM_BR_OP = parseTerm("("))){

            if (!(bEXPRESSION2 = parseExpressionInteger(Expression3))){ error("integer expression missing"); _END_ }

            if (!(bTerm_COMMA = parseTerm(","))){ error(", missing"); _END_ }

            if (!(bEXPRESSION2 = parseExpressionInteger(Expression4))){ error("integer expression missing"); _END_ }

                  if (!(bTerm_SYM_BR_OP && (bTerm_SYM_BR_CL = parseTerm(")")))){ error(""); _END_ }

          }

          if ((bTerm_COMMA = parseTerm(","))){
            if ((color = parseExpressionInteger(Color))){} else Color.Statements = Compiler::pushInteger(15);
          } else Color.Statements = Compiler::pushInteger(15);

          if ((bTerm_COMMA = parseTerm(","))){
            QString s;

            if (parseIdentifier(&s)){
              if (s == "B"){
                b = true;
              } else if (s == "BF"){
                bf = true;
              } else {
                { error("B or BF missing"); _END_ }
              }
            }
          }

          if ((bTerm_COMMA = parseTerm(","))){
            if ((style = parseExpressionInteger(Style))){}
          }

          if (bTerm_STEP || bTerm_STEP2) { error("STEP is not supported yet"); _END_ }
          if (style) { error("STYLE is not supported yet"); _END_ }

          ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("LINE", ReturnExpression.bReturn, Expression.Statements, Expression2.Statements, Expression3.Statements, Expression4.Statements, Compiler::pushBoolean(color), Color.Statements);
           if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

         return true;
      }

      else if (sIdentifier == "PSet"){
        if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

                bool bTerm_COMMA = false;
                bool bEXPRESSION = false;


                bool color = false;


//	        bool bTerm_SYM_BR_CL;

          _expressions Expression;
          _expressions Expression2;
          _expressions Color;

         bool bBC;
         if ((bBC = parseTerm("(")));

          if (!(bEXPRESSION = parseExpressionInteger(Expression))){ error("integer expression missing"); _END_ }

          if (!(bTerm_COMMA = parseTerm(","))){ error(", missing"); _END_ }

          if (!(bEXPRESSION = parseExpressionInteger(Expression2))){ error("integer expression missing"); _END_ }

          if ((bTerm_COMMA = parseTerm(","))){
            if ((color = parseExpressionInteger(Color))){} else Color.Statements = Compiler::pushInteger(15);
          } else Color.Statements = Compiler::pushInteger(15);

          if (bBC && !parseTerm(")")){ error(""); _END_ }

          ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("PSET", ReturnExpression.bReturn, Expression.Statements, Expression2.Statements, Compiler::pushBoolean(color), Color.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

         return true;
      }

      else if (sIdentifier == "Print"){ 
        if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

         bool bBC;
         if ((bBC = parseTerm("(")));
         _expressions Expression;

         if (!parseExpressionid(Expression)){ error(""); return false; }

         ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("PRINT", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

         if (bBC && !parseTerm(")")){ error(""); _END_ }

         return true;
      }


    if ((sIdentifier == "stdout" || sIdentifier == "Log" || sIdentifier == "stderr")){
        if (ReturnExpression.bReturn){ error(sIdentifier + " must not be used within an expression"); return false; }

        int nCount = 1;

        bool b = false;
        b = parseTerm("(");
        _expressions Expression;

        Expression.Statements << Compiler::pushCode(".arg(Q7B_toString2(");
        if (!parseExpressionid(Expression)){ error(""); return false; }

        Expression.Statements << Compiler::pushCode("))");

        _expressions expressions;
        
        while (parseTerm(",")){
          _expressions Expression2;
          if (!parseExpressionid(Expression2)){ error(""); return false; }
          nCount++;

          expressions.Statements << Compiler::pushCode(".arg(Q7B_toString2(");

          expressions.Statements << Compiler::pushExpression(Expression2.Statements);


          expressions.Statements << Compiler::pushCode("))");
        }                 

        

        if (b && !parseTerm(")")){ error(""); return false; }
        
         QString s;

         s += "QString(\"%1";
        for (int i = 1; i < nCount; i++){

            s += " %" + QString("%1").arg(i + 1);
        }

        s += "\")";

      //  QString sdf = Compiler::decode(Compiler::pushBuiltinSubFunction("STDOUT", Compiler::pushCode(PREFIX + "ID(") << Compiler::pushCode(s) << Expression.Statements << expressions.Statements << Compiler::pushCode(")")));
      
       // QString s788877df = Compiler::decode(expressions.Statements);
        

        ReturnExpression.Statements << Compiler::pushBuiltinSubFunction(sIdentifier == "stderr" ? "STDERR" : "STDOUT", ReturnExpression.bReturn, Compiler::pushCode(PREFIX + "ID(") << Compiler::pushCode(s) << Expression.Statements << expressions.Statements << Compiler::pushCode(")"));
        if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");
    
        return true;
      }



      else if (sIdentifier == "MsgBox" || sIdentifier == "Alert" || sIdentifier == "MsgBoxTODO"){

       if (sIdentifier == "MsgBoxTODO"){
         sIdentifier = sIdentifier;
       }

     //  if (parseTerm("$")){} // just provided for backward compatibility
       if (!parseTerm("(")){ _END_ } 

        if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
        _expressions Expression;
        if (!parseExpressionid(Expression)){ error(""); return false; }

        Me.bVB6MsgBox = false;
        if (parseTerm(",")){        
          if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
          _expressions Expression2;
          if (!parseExpressionid(Expression2)){ error(""); return false; }
          if (parseTerm(",")){ 
            if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
            _expressions Expression3;
            if (!parseExpressionid(Expression3)){ error(""); return false; }
            if (!parseTerm(")")){ error(""); _END_ }
                        
             ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("__MSGBOX", ReturnExpression.bReturn, Expression.Statements, Expression2.Statements, Expression3.Statements, Compiler::pushBoolean(Me.bVB6MsgBox));
             if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

          } else {
            if (!parseTerm(")")){ error(""); _END_ }
            
            ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("MSGBOX", ReturnExpression.bReturn, Expression.Statements, Expression2.Statements, Compiler::pushBoolean(Me.bVB6MsgBox));
            if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

          }
          
        } else {
          if (!parseTerm(")")){ error(""); _END_ }          
          
          

          ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("_MSGBOX", ReturnExpression.bReturn, Expression.Statements);
          if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

         
         // sdfs = sdfs;

          
        }

          

        ReturnExpression.sType = "Integer";
		
        return true;
      }

    else if (sIdentifier == "File"){
      if (!peekTerm(".")){
        if (!ReturnExpression.bReturn){ _END_ }
      }

      if (!parseTerm("(")){ _END_ } 
      _expressions Expression;
//      _expressions Expression2;

      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      if (!parseExpressionString(Expression)){ error(""); _END_ }        
      
      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("FILE", ReturnExpression.bReturn, Expression.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "Boolean";
      return true;
    }

    else if (sIdentifier == "Mid"){
      if (!ReturnExpression.bReturn){ _END_ }

      if (parseTerm("$")){} 
      if (!parseTerm("(")){ _END_ } // built-in name could be used as var
      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression;
      if (!parseExpressionString(Expression)){ error(""); _END_ }        
      if (!parseTerm(",")){ error(", expected"); _END_ }
      if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
      _expressions Expression2;
      if (!parseExpressionInteger(Expression2)){ error(""); _END_ }     
      
      _expressions Expression3;
      if (parseTerm(",")){ 
        if (peekTerm(":=", 1)){ QString sDummy; if (parseIdentifier(&sDummy)){ if (!parseTerm(":=")){ error(""); return false; } } }
        if (!parseExpressionInteger(Expression3)){ error(""); _END_ }        
      } else Expression3.Statements = Compiler::pushInteger(-1);
      
      if (!parseTerm(")")){ error(""); _END_ }

      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("MID", ReturnExpression.bReturn, Expression.Statements, Expression2.Statements, Expression3.Statements);
       if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
    }

    else  if (sIdentifier == "Concat"){
      if (!ReturnExpression.bReturn){ _END_ }

      if (parseTerm("$")){} 
      if (!parseTerm("(")){ _END_ } // built-in name could be used as var

      QList<_statements> expressions;
      
      do {
        _expressions Expression2;
        if (!parseExpressionid(Expression2)){ error(""); return false; }
        expressions << Compiler::pushExpression(Expression2.Statements);
      } while (parseTerm(","));
                 

      
      if (!parseTerm(")")){ error(""); _END_ }

      _statements Statements = expressions.at(0);

      for (int i = 1; i < expressions.size(); i++){
   //     ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("CONCAT", ReturnExpression.bReturn, Expression.Statements, expressions.at(i));
        Statements = Compiler::pushOperator("CONCAT", Statements, expressions.at(i));
      }

      ReturnExpression.Statements << Statements;
     

     // Concat(1, 2, 3, "t", 99.3)
      if (!ReturnExpression.bReturn) ReturnExpression.Statements << Compiler::push(";");

      ReturnExpression.sType = "String";
      return true;
      
  } else if (ReturnExpression.bReturn){
_init:

    QString sTypeL;
    QString sTypeR;

    _expressions Expression;

    //Me.sVarNameForOnAction = "this";
    QString sVariable;
    bool bType = false;
    _array Array;

    if (Me.nLine == 254){
      Me.nLine = Me.nLine;
    }

    bool bParseBrackets = false;
    bool bMustMatch = false;
   
    if (autoInitForType(Expression.Statements, sVariable, sIdentifier, sTypeL, sTypeR, &bType, Array, &bMustMatch, &bParseBrackets)){ 
      if (bParseBrackets == false || parseTerm("(")){ 
        if (bParseBrackets && !parseTerm(")")){
          _END_  
          //error(""); _END_ 
        }
      
        ReturnExpression.Statements << Expression.Statements;
        ReturnExpression.sType = sIdentifier;
        return true; 
      }
    }
    
  }





// TODO2 neuer befehl DebugList(List), DebugDictionary zeigt eine table mit allen inhalten in qtableview an mit parent = 0 ?hnlich msgbox


// TODO2 kbasics bin fkt
 // TODO2 sub EmitSignal(name(args))  -> emit ... und signal in *.h








  

  }

  _END_
}

void Parser::CreateListOfInitFunctions()
{
  {
    QMapIterator<QString, QString> i(Me.classes);
    while (i.hasNext()) {
       i.next();

       if (
         i.key() == "Dictionary"
         || i.key() == "List"
         || i.key() == "QStringList"
         )
       {
         
         continue;
       }
       
       if ( 
       //  i.key() == "Class"
       //  || i.key() == "Module"
       //  || i.key() == "uiClass"  

         
          //i.key() == "QPainter"  
        
         i.key().contains("Abstract")
         || i.key().contains("Event")
         || i.key().contains("Layout")
         ) continue;

       QString sName = i.key();
       QString sArguments;
       QString sType = i.key();
       QString sGroup = "Init";
       QString sSeeAlso;
       QString sComment = "Creates and returns a new object based on the class '" + i.key() + "'.";
       QString sExample;

       if (sName == "QIcon"){
         sArguments = "NameOrFileName As String";
       } else if (sName == "QPixmap"){
         sArguments = "NameOrFileName As String";
       } else if (sName == "QMenu"){
         sArguments = "[Title As String]";
       }

       AddFunction(sName, sArguments, sType, sGroup, sSeeAlso, sComment, sExample);
       Me.subsfunctions_inits[sName] = true;
    }  
  }

  {
    QMapIterator<QString, QString> i(Me.controls);
    while (i.hasNext()) {
       i.next();

       QString sName = i.key();
       QString sArguments;
       QString sType = i.key();
       QString sGroup = "Init";
       QString sSeeAlso;
       QString sComment = "Creates and returns a new object based on the class '" + i.key() + "'.";
       QString sExample;

       AddFunction(sName, sArguments, sType, sGroup, sSeeAlso, sComment, sExample);
       Me.subsfunctions_inits[sName] = true;
    }  
  }
  
  {
    for (int i = 0; i < Me.types.size(); i++){  
       QString sName = Me.types.at(i);
       QString sArguments;
       QString sType = Me.types.at(i);
       QString sGroup = "Init";
       QString sSeeAlso;
       QString sComment = "Creates and returns a new object of type '" + Me.types.at(i) + "'.";
       QString sExample;

       if (sName == "DateTime"){
         sArguments = "{Year As Integer, Month As Integer, Day As Integer} | {Hour As Integer, Minute As Integer, Second As Integer, MSecond As Integer} | {Year As Integer, Month As Integer, Day As Integer, Hour As Integer, Minute As Integer, Second As Integer, MSecond As Integer}";
       } else if (sName == "List"){
         sArguments = "Argument As id [, ...]";
         sComment += " Up to 20 arguments may be used to initialize the list.";
       } else if (sName == "Dictionary"){
         sArguments = "Key As String := Value As id [, ...] | Keys As List, Values As List";
         sComment += " Up to 20 arguments may be used to initialize the dictionary.";
       }
      
       if (Me.subsfunctions.contains(sName)){
         if (sComment.startsWith("Creates")){
           sComment = "<br>Or c" + sComment.mid(1);                  
         }
         if (sArguments.isEmpty()){
           sArguments = sArguments + "<br>| no arguments";
         } else {
           sArguments = "<br>| " + sArguments;
         }
         AddFunction(sName, sArguments, sType, sGroup, sSeeAlso, sComment, sExample, true);
       } else {
         AddFunction(sName, sArguments, sType, sGroup, sSeeAlso, sComment, sExample);
         Me.subsfunctions_inits[sName] = true;
       }
    }      
  }
  
}



#undef End_Function
#undef End_Sub
#undef End_FakeFunction
#undef End_FakeSub
#undef GROUP
#undef SEEALSO
#undef COMMENT
#undef EXAMPLE
#undef OLDBASIC
#undef FakeFunction
#undef FakeSub
#undef Function
#undef Sub
#undef ___
#undef As
#undef Alias




#include "_Q7BCompiler.h"

#define COMMENT ;Me.types<<sType;Me.comments_types[sType]._COMMENT

#define Type ;sType=


void Parser::CreateListOfTypes()
{      
  QString sType;
    
  if (Me.types.size() == 0){    
    
    


    Type "Boolean"        COMMENT = "It is internally a bool object.";
    Type "String"      COMMENT = "It is internally a QString object. Unicode support is built-in. You need to have installed Unicode support (e.g. Asian language and character sets) for Windows for this feature.";

    Type "Integer"        COMMENT = "It is internally a qint64 object.";
    Type "Float"        COMMENT = "It is internally a qreal object.";

    Type "DateTime"        COMMENT = "A DateTime object is internally a QDateTime object.";
    Type "Decimal"        COMMENT = "It is internally a Q7Basic custom object based storing its value in a qint64.";
    Type "Object"        COMMENT = "An alias for id.";
    Type "Variant"        COMMENT = "Reserved.";

    Type "Byte"        COMMENT = "It is internally a qint64 object. If needed it gets converted to unsigned 8-bit.";
    Type "Short"        COMMENT = "It is internally a qint64 object. If needed it gets converted to 16-bit.";
    Type "Int8"        COMMENT = "It is internally a qint64 object. If needed it gets converted to signed 8-bit.";
    Type "Int16"        COMMENT = "It is internally a qint64 object. If needed it gets converted to signed 16-bit.";
    Type "Int32"        COMMENT = "It is internally a qint64 object. If needed it gets converted to signed 32-bit.";
    Type "Int64"        COMMENT = "An alias for Integer.";
    Type "Long"        COMMENT = "Reserved.";

    Type "Single"        COMMENT = "It is internally a qreal object. If needed it gets converted to 32-bit float (single).";
    Type "Double"        COMMENT = "An alias for Float.";

    Type "CString"        COMMENT = "It is internally a QString object. If needed it gets converted to a CString.";

    Type "List"        COMMENT = "It is internally a QList<id>.";
    Type "Dictionary"        COMMENT = "It is internally a QMap<QString, id>.";


    
    
    Type "id"        COMMENT = "";

    
  }

  Me.types.sort();


}


#undef COMMENT
#undef Type




#include "_Q7BCompiler.h"





QString getType(QString sType)
{

  return sType;
}

void CompilerError()
{
  int i = 0;
  i++;
}



QString Compiler::decode(_statements & _AllStatements, bool bFirst, QString *s2ndOutput, QString *s3ndOutput)
{
  
  //if (sReturn == 0) sReturn = &sReturn2;

  QMap<QString, QList<int> > gotos_VM;
  QMap<QString, int> labels_VM;

  _statements *AllStatements;
  _statements AllStatements2;
  if (bFirst){
    AllStatements2 = _AllStatements;
    AllStatements = &AllStatements2;
  } else {
    AllStatements = &_AllStatements;
  }  
  bool bVM = false;
  QString s;
  if (CONFIG["VM"] == "true" && AllStatements->size() > 0){
    bVM = true;
    //s += "_bytecodes Q7BV;\n";
  }


  for (int i = 0; AllStatements->size() > 0 && i <= AllStatements->size(); i++){
    i = 0;
    
    _statement v = AllStatements->at(i);

    QString id = v.id;


    if (id == "Call" || id == "DeclareCall"){

      bool bDeclare = id == "DeclareCall";

      if (bDeclare){
        bDeclare = bDeclare;
      }

      QString sId;
      _statements Identifier;
      _statements GlobalClass;
      _statements Return;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier) && (bDeclare || popExpression(*AllStatements, &GlobalClass)) && (bDeclare || popExpression(*AllStatements, &Return))){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);
        QString sGlobalClass;
        if (bDeclare == false){
          sGlobalClass = decode(GlobalClass, false, s2ndOutput);
          if (!sGlobalClass.isEmpty()){
            s += QString("%1::").arg(sGlobalClass);
          }
        }
        QString sReturn = decode(Return, false, s2ndOutput);
        bool bReturn = sReturn == "true";


        
        if (bVM){          

          int n = 0;
          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
            s += decode(Expression, false, s2ndOutput);     
            n++;
          }
          s += " Q7BV << \"Call\"; Q7BV << \"" + sIdentifier + "\"; Q7BV << " + (bReturn ? "true" : "false") + "; Q7BV << " + QString("%1").arg(n) + "; ";
//          s += " Q7BV << \"Call\"; Q7BV << \"" + Parser::getClassName(Me.sFileName) + "\"; Q7BV << \"" + sIdentifier + "\"; Q7BV << " + (bReturn ? "true" : "false") + "; Q7BV << " + QString("%1").arg(n) + "; ";

        } else {
          bool bWorkaround = !s.endsWith("->");
          if (bDeclare && bWorkaround){
            s += PREFIX + "ID("; 
          }
          s += QString("%1").arg(sIdentifier);
          s += "(";

          _statements Expression;
          bool bFirst = true;
          while (popExpression(*AllStatements, &Expression)){
            if (bFirst == false){
              s += ", ";
            }
            if (bFirst) bFirst = false;
            s += decode(Expression, false, s2ndOutput);
          }
          s += ")";
          if (bDeclare && bWorkaround){
            s += ")"; 
          }
        }


      } else {
        CompilerError();
      }

    } else if (id == "Class Singleton"){

      QString sId;
      _statements Identifier;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);

        

        if (bVM){
          s += " Q7BV << \"Class Singleton\"; Q7BV << \"" + sIdentifier + "\";";
        } else {
          s += QString(PREFIX + "%1_Object()").arg(sIdentifier);
        }               

      } else {
        CompilerError();
      }

    } else if (id == "Object"){

      QString Object;
      if (popObject(*AllStatements, &Object)){        


        if (bVM){
          s += " Q7BV << \"Object\"; Q7BV << \"" + Object + "\";";
        } else {
          s += PREFIX + Object + "_Object()";
        }        

      } else {
        CompilerError();
      }

    } else if (id == "Alloc"){

      QString Alloc;
      if (popAlloc(*AllStatements, &Alloc)){


          

      } else {
        CompilerError();
      }

    } else if (id == "AllocInit"){

      QString AllocInit;
      if (popAllocInit(*AllStatements, &AllocInit)){


          

      } else {
        CompilerError();
      }
    } else if (id == "ObjectRef"){

      QString Object;
      _statements Statements;
      if (popObjectRef(*AllStatements, &Object) && popExpression(*AllStatements, &Statements)){

        QString sStatements = decode(Statements, false, s2ndOutput);


        if (bVM){
          s += sStatements;
        } else {
          s += PREFIX + Object + "_Class(" + sStatements + ")";
        }        

      } else {
        CompilerError();
      }

    } else if (id == "ObjectRefDirectCast"){

      QString Object;
      _statements Statements;
      if (popObjectRefDirectCast(*AllStatements, &Object) && popExpression(*AllStatements, &Statements)){

        QString sStatements = decode(Statements, false, s2ndOutput);


        if (bVM){
          s += sStatements;
        } else {
          s += "((" + Object + "* )(" + sStatements + ")->ref)";
        }        

      } else {
        CompilerError();
      }


    } else if (id == "BuiltinSubFunction"){

      QString sName;
      bool bReturn;
      if (popBuiltinSubFunction(*AllStatements, &sName, &bReturn)){
 
        if (sName == "UBound"){
          sName = sName;
        }

        if (bVM){
          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
            s += decode(Expression, false, s2ndOutput);     
          }
          s += " Q7BV << \"BuiltinSubFunction\"; Q7BV << \"" + PREFIX + sName + "\"; Q7BV << " + (bReturn ? "true" : "false") + ";";

        } else {
          s += PREFIX + sName.toUpper() + "(";

          _statements Expression;
          bool bFirst = true;
          while (popExpression(*AllStatements, &Expression)){
            if (bFirst == false){
              s += ", ";
            }
            if (bFirst) bFirst = false;
            s += decode(Expression, false, s2ndOutput);     
          }

          s += ")";
        }     

      } else {
        CompilerError();
      }

    } else if (id == "->"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){          
        } else {
          s += "->";
        }             

      } else {
        CompilerError();        
      }

    } else if (id == "."){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){          
        } else {
          s += ".";
        }          
        
      } else {
        CompilerError();        
      }

    } else if (id == ";"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        s += ";\n";

      } else {
        CompilerError();        
      }

    } else if (id == "Return"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){
          s += " Q7BV << \"Return\";";
        } else {
          s += "return;\n";
        }

      } else {
        CompilerError();        
      }

    } else if (id == "Return ?"){

      QString sId;
      _statements Expression;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Expression)){

        if (bVM){
          s += decode(Expression, false, s2ndOutput);
          s += " Q7BV << \"Return ?\";";
        } else {
          s += "return " + PREFIX + "ID(" + decode(Expression, false, s2ndOutput) + ");\n";
        }
        

      } else {
        CompilerError();        
      }

    } else if (id == "Exit Function"){

      QString sId;

      if (pop(*AllStatements, &sId)){

        if (bVM){
          s += " Q7BV << \"String\"; "; 
          s += " Q7BV << \"" + PREFIX + Me.SubFunction.sName + "\"; "; 
          s += " Q7BV << \"Local Variable\"; "; 
          s += " Q7BV << \"Return ?\";";
        } else {
          s += "return " + PREFIX + Me.SubFunction.sName + ";\n";
        }        

      } else {
        CompilerError();        
      }      

    } else if (id == "ExitFunctionVariable"){

      QString sId;

      if (pop(*AllStatements, &sId)){

        if (bVM){
          s += " Q7BV << \"String\"; "; 
          s += " Q7BV << \"" + PREFIX + Me.SubFunction.sName + "\"; "; 
          s += " Q7BV << \"Local Dim\"; "; 
          s += " Q7BV << \"String\"; "; 
          s += " Q7BV << \"" + PREFIX + Me.SubFunction.sName + "\"; "; 
          s += " Q7BV << \"Local Variable\"; "; 
        } else {
          s += PREFIX + Me.SubFunction.sName;
        }

      } else {
        CompilerError();        
      }      

    } else if (id == "IIf"){

      QString sId;
      _statements Condition;
      _statements Statements;
      _statements Statements2;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Condition) && popExpression(*AllStatements, &Statements) && popExpression(*AllStatements, &Statements2)){


        if (bVM){
          QString sCondition = decode(Condition, false, s2ndOutput);
          QString sStatements = decode(Statements, false, s2ndOutput);
          QString sStatements2 = decode(Statements2, false, s2ndOutput);

          s += sCondition;
          
          s += " Q7BV << \"IIF\"; "; 
          s += " Q7BV << " + QString("%1").arg(2 + sStatements.count("<<")) + "; "; 
          
          s += sStatements;
          
          s += " Q7BV << \"JMP\"; "; 
          s += " Q7BV << " + QString("%1").arg(sStatements2.count("<<")) + "; "; 
          
          s += sStatements2;

        } else {
          s += PREFIX + "CBOOL(" + decode(Condition, false, s2ndOutput) + QString(") ? %1 : %2").arg(decode(Statements, false, s2ndOutput)).arg(decode(Statements2, false, s2ndOutput));
        }

      } else {
        CompilerError();        
      }
     
    } else if (id == "Argument" || id == "Local Variable" || id == "Class Variable"){

      QString sId;
      _statements Identifier;
      _statements Return;


      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier)){

        QString sReturn;
        if (popExpression(*AllStatements, &Return)){ sReturn = decode(Return, false, s2ndOutput); }     

        QString sIdentifier = decode(Identifier, false, s2ndOutput);

        if (bVM){

          s += " Q7BV << \"String\"; "; 
          s += " Q7BV << \"" + sIdentifier + "\"; "; 
          s += " Q7BV << \"" + id + "\"; "; 
        } else {
          s += QString("%1").arg(sIdentifier);
        }           

      } else {
        CompilerError();        
      }
     
    } else if (id == "Global Variable"){

      QString sId;
      _statements Identifier;
      _statements Class;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier) && popExpression(*AllStatements, &Class)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);
        QString sClass = decode(Class, false, s2ndOutput);

        s += QString("%1::%2").arg(sClass).arg(sIdentifier);

      } else {
        CompilerError();        
      }

    } else if (id == "Assignment"){

      QString sId;
      _statements Identifier;
      _statements Expression;
      _statements Type;


      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);

        if (sIdentifier == "k"){
           sIdentifier = sIdentifier;
        }

        if (popExpression(*AllStatements, &Expression) && popExpression(*AllStatements, &Type)){
        
        QString sExpression = decode(Expression, false, s2ndOutput);
        QString sType = decode(Type, false, s2ndOutput);



        if (bVM){

          s += sExpression + "; "; 
          s += sIdentifier; 
          s += " Q7BV << \"Assignment\"; "; 

        } else {

          QString s1 = "&";
          if (sIdentifier.startsWith("*q7b_type_get")){
            s1 = "";
            sIdentifier = sIdentifier.mid(1); 
          }
          QString s2 = "&";

          QString s3;
          if (!Parser::existsUDFType(sType)){
            s3 = PREFIX + "_" + sType.toUpper();
          }

          s += PREFIX + QString("ASSIGNMENT(%1%2, %3%4)").arg(s1).arg(sIdentifier).arg(s2).arg(s3 + "(" + sExpression + ")");
        }

      } else {
        CompilerError();        
      }

      } else {
        CompilerError();        
      }

    } else if (id == "MidAssignment"){

      QString sId;
      _statements Identifier;
      _statements MidFromExpression;
      _statements MidToExpression;
      _statements Expression;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier) && popExpression(*AllStatements, &MidFromExpression) && popExpression(*AllStatements, &MidToExpression) && popExpression(*AllStatements, &Expression)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);
        QString sMidFromExpression = decode(MidFromExpression, false, s2ndOutput);
        QString sMidToExpression = decode(MidToExpression, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);


        s += PREFIX + QString("MIDASSIGNMENT(&%1, %2, %3, %4)").arg(sIdentifier).arg(sMidFromExpression).arg(sMidToExpression).arg(sExpression);

      } else {
        CompilerError();        
      }

    } else if (id == "Array ReDim"){

      QString sId;
      _statements Variable;
      _statements Preserve;      
      _statements FieldIndex;      

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Variable) && popExpression(*AllStatements, &Preserve) && popExpression(*AllStatements, &FieldIndex)){

        QString sVariable = decode(Variable, false, s2ndOutput);
        QString sPreserve = decode(Preserve, false, s2ndOutput);
        QString sFieldIndex = decode(FieldIndex, false, s2ndOutput);
       
        s += "q7b_array_redim(" + sVariable + ", " + sPreserve + ", " + sFieldIndex + ")";

      } else {
        CompilerError();        
      }
     
    } else if (id == "Type Get"){

      QString sId;
      _statements Variable;
      _statements FieldIndex;      

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Variable) && popExpression(*AllStatements, &FieldIndex)){

        QString sVariable = decode(Variable, false, s2ndOutput);
        QString sFieldIndex = decode(FieldIndex, false, s2ndOutput);
       
        s += "*q7b_type_get(" + sVariable + ", " + sFieldIndex + ")";

      } else {
        CompilerError();        
      }

    } else if (id == "Array At"){

      QString sId;
      _statements Variable;
      _statements Expression;      

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Variable) && popExpression(*AllStatements, &Expression)){

        QString sVariable = decode(Variable, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);
       
        s += "*q7b_array_at(" + sVariable + ", " + sExpression + ")";

      } else {
        CompilerError();        
      }

    } else if (id == "Array Get"){

      QString sId;
      _statements Variable;
      _statements Expression;      

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Variable) && popExpression(*AllStatements, &Expression)){

        QString sVariable = decode(Variable, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);
       
        s += "*q7b_array_get(" + sVariable + ", " + sExpression + ")";

      } else {
        CompilerError();        
      }

    } else if (id == "QObjectPropertyOrKVCAssignment"){

      QString sId;
      _statements Identifier;
      _statements QObjectPropertyOrKVC;
      _statements Expression;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier) && popExpression(*AllStatements, &QObjectPropertyOrKVC) && popExpression(*AllStatements, &Expression)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);
        QString sQObjectPropertyOrKVC = decode(QObjectPropertyOrKVC, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);

        if (bVM){
          s += sIdentifier;
          s += sQObjectPropertyOrKVC;
          s += sExpression;
          s += " Q7BV << \"QObjectPropertyOrKVCAssignment\";";
        } else {
          s += PREFIX + QString("PROPERTY(%1, %2, %3)").arg(sIdentifier).arg(sQObjectPropertyOrKVC).arg(sExpression);
        }        

      } else {
        CompilerError();        
      }

    } else if (id == "GoTo"){

      QString sId;
      _statements Identifier;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);

        if (bVM){
          s += " Q7BV << \"GOTO\";"; 
          s += " Q7BV << ";
          gotos_VM[sIdentifier] << s.length();          
          s += "; "; 
        } else {
          s += QString("goto _%1;\n").arg(sIdentifier); 
        }

      } else {
        CompilerError();        
      }

    } else if (id == "Label"){

      QString sId;
      _statements Identifier;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);

        if (bVM){
          labels_VM[sIdentifier] = s.length();
        } else {
          s += QString("_%1:;\n").arg(sIdentifier); 
        }
        
      } else {
        CompilerError();        
      }

    } else if (id == "NOP"){ 

      QString sId;
      if (pop(*AllStatements, &sId)){
      } else {
        CompilerError();        
      }

    } else if (id == "Expression"){      

      _statements Expression;
      if (popExpression(*AllStatements, &Expression)){
        s += decode(Expression, false, s2ndOutput);

      } else {
        CompilerError();        
      }

    } else if (id == "Debug" || id == "DebugAndAlso"){

      if (popDebug(*AllStatements)){
          QString code;


          code = "Q7BS";

        if (bVM){

       //   s += "                                                          ";

          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
       //     s += " Q7BV << \"String\";"; 
       //     s += " Q7BV << \"" + decode(Expression, false, s2ndOutput) + "\";";
          }
          
       //   s += " Q7BV << \"" + id + "\";";

        } else {

          s += QString(id == "Debug" ? "" : PREFIX + "ID(");
          s += QString(id == "Debug" ? "                                                                  " : "") + "" + code + "(";

          _statements Expression;
          bool bFirst = true;
          while (popExpression(*AllStatements, &Expression)){
            if (bFirst == false){
              s += ", ";
            }
            if (bFirst) bFirst = false;
            s += "\"" + decode(Expression, false, s2ndOutput) + "\"";
          }
          s += ")";
          s += QString(id == "Debug" ? "" : ")");
        }

      } else {
        CompilerError();        
      }

    } else if (id == "Operator"){

      QString sOperator;
      _statements l;      

      if (popOperator(*AllStatements, &sOperator) && popExpression(*AllStatements, &l)){

        QString ll = decode(l, false, s2ndOutput);

        if (sOperator == "ORELSE"){
            sOperator=sOperator;
            }

        QString sCast;



        if (sOperator == "NOT" || sOperator == "FLIP" || sOperator == "PLUS" || sOperator == "MINUS"){
          if (bVM){
            s += ll + ";";
            s += "; Q7BV << \"" + sOperator + "\";"; 
          } else {
            s += PREFIX + sOperator + "(" + ll + ")";
          }     
          
        } else if (sOperator == "BRACES"){
   
          if (bVM){
            s += ll;
          } else {
            s += "(" + ll + ")";
          }  
          
        } else {

          _statements r;

          if (popExpression(*AllStatements, &r)){
            QString rr = decode(r, false, s2ndOutput);

            if (bVM){
              s += ll + ";";
              s += rr + ";";
              s += "; Q7BV << \"" + sOperator + "\"; "; 
            } else {

              if (sOperator == "ORELSE"){
                  s += PREFIX + "ID(" + sCast + "(" + PREFIX + "CBOOL(" + ll + ") || " + PREFIX + "CBOOL(" + rr + ")))";
              } else if (sOperator == "ANDALSO"){
                  s += PREFIX + "ID(" + sCast + "(" + PREFIX + "CBOOL(" + ll + ") && " + PREFIX + "CBOOL(" + rr + ")))";
              } else if (sOperator == "DEBUG_ANDALSO"){
                  s += PREFIX + "ANDALSO" + "(" + ll + ", " + rr + ")";
              } else {
                s += PREFIX + sOperator + "(" + ll + ", " + rr + ")";
              }     
              
            }
          } else {
            CompilerError();                 
          }
        }

      } else {
        CompilerError();       
      }

    } else if (id == "Identifier"){

      QString Identifier;
      if (popIdentifier(*AllStatements, &Identifier)){

        s += Identifier;

      } else {
        CompilerError();        
      }

    } else if (id == "String"){

      QString String;
      if (popString(*AllStatements, &String)){



        if (bVM){
          s += " Q7BV << \"String\";"; 
          s += "; Q7BV << \"" + String + "\"" + ";"; 
        } else {
          s += PREFIX + "ID(\"" + String + "\")";
        }     


      } else {
        CompilerError();        
      }

    } else if (id == "BuiltinClassProperty"){

      QString sClass;
      bool bReturn;
      QString sProperty;
      _statements Object;
      _statements Expression;
      
      if (popBuiltinClassProperty(*AllStatements, &sClass, &bReturn, &sProperty) && popExpression(*AllStatements, &Object) && popExpression(*AllStatements, &Expression)){

        QString sObject = decode(Object, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);

        if (bVM){
          s += sObject;
          s += sExpression;
          int n = 0;

          if (!sExpression.isEmpty()){
            n++;
          }

          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
            s += decode(Expression, false, s2ndOutput);     
            n++;
          }          
          s += " Q7BV << \"BuiltinClassPropertyOrProcedure\"; Q7BV << \"" + PREFIX + sClass.toUpper() + "_" + sProperty.toUpper() + "\"; Q7BV << " + (bReturn ? "true" : "false") + "; Q7BV << " + QString("%1").arg(n) + "; "; 

        } else {

          s += PREFIX + sClass.toUpper() + "_" + sProperty.toUpper() + "(";

          s += sObject;

          if (!sExpression.isEmpty()){
            s += ", " + sExpression;
          }

          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
              s += ", ";
            if (bFirst) bFirst = false;
            s += decode(Expression, false, s2ndOutput);
          }

          s += ")";
        }

      } else {
        CompilerError();        
      }

    } else if (id == "BuiltinClassProcedure"){

      QString sClass;
      bool bReturn;
      QString sProcedure;
      _statements Object;
      _statements Expression;

      if (popBuiltinClassProcedure(*AllStatements, &sClass, &bReturn, &sProcedure) && popExpression(*AllStatements, &Object) && popExpression(*AllStatements, &Expression)){

        QString sObject = decode(Object, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);

        if (bVM){
          s += sObject;
          s += sExpression;  
          int n = 0;

          if (!sExpression.isEmpty()){
            n++;
          }
          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
            s += decode(Expression, false, s2ndOutput);     
            n++;
          }
          s += " Q7BV << \"BuiltinClassPropertyOrProcedure\"; Q7BV << \"" + PREFIX + sClass.toUpper() + "_" + sProcedure.toUpper() + "\"; Q7BV << " + (bReturn ? "true" : "false") + "; Q7BV << " + QString("%1").arg(n) + "; "; 

        } else {

          s += PREFIX + sClass.toUpper() + "_" + sProcedure.toUpper();
          s += "(";
          
          s += sObject;

          if (!sExpression.isEmpty()){
            s += ", " + sExpression;
          }

          _statements Expression;
          while (popExpression(*AllStatements, &Expression)){
            s += ", ";
            if (bFirst) bFirst = false;
            s += decode(Expression, false, s2ndOutput);     
          }
          
          s += ")";
        }

      } else {
        CompilerError();        
      }

    } else if (id == "For"){

      QString sId;
      _statements Variable;
      _statements Assignment;
      _statements Test;
      _statements Increment;
      _statements Statements;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Variable) && popExpression(*AllStatements, &Assignment) && popExpression(*AllStatements, &Test) && popExpression(*AllStatements, &Increment) && popExpression(*AllStatements, &Statements)){

        QString sVariable = decode(Variable, false, s2ndOutput);
        QString sAssignment = decode(Assignment, false, s2ndOutput);
        QString sTest = decode(Test, false, s2ndOutput);
        QString sIncrement = decode(Increment, false, s2ndOutput);
        QString sStatements = decode(Statements, false, s2ndOutput);

        if (bVM){  

          s += sAssignment;
          
          s += "; Q7BV << \"LOOPEND\"; "; 
          s += " Q7BV << " + QString("%1").arg(5 + sTest.count("<<") + sStatements.count("<<") + sIncrement.count("<<")) + "; "; 
          
          s += "; Q7BV << \"LOOPSTART\"; "; 
          
          s += sTest;
          
          s += "; Q7BV << \"DOLOOPWHILE\"; "; 
          s += " Q7BV << " + QString("%1").arg(2 + sStatements.count("<<") + sIncrement.count("<<")) + "; "; 
          
          s += sStatements;
          s += sIncrement;
          
          s += " Q7BV << \"JMP\"; "; 
          s += " Q7BV << " + QString("%1").arg(-(4 + sTest.count("<<") + sStatements.count("<<") + sIncrement.count("<<"))) + "; "; 
          
          s += "; Q7BV << \"LOOPEND2\"; "; 

        } else {
          s += QString("%1").arg(sAssignment);
          s += QString("for (;%1;%2){\n").arg(PREFIX + "CBOOL(" + sTest + ")").arg(sIncrement);
          s += QString("%1").arg(sStatements);
        }     

      } else {
        CompilerError();        
      }

    } else if (id == "Next"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){
        } else {
          s += "\n}\n";
        }

      } else {
        CompilerError();        
      }

    } else if (id == "Local Dim"){

      QString sId;
      _statements Identifier;
      _statements Type;
      _statements Expression;
      _statements Array;
      _statements Static;
      _statements IsType;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier)){
        
        QString sIdentifier = decode(Identifier, false, s2ndOutput);

        if (sIdentifier == "tt2"){
           sIdentifier = sIdentifier;
        }

QString sType;
        if (popExpression(*AllStatements, &Type)){ sType = decode(Type, false, s2ndOutput);
        if (popExpression(*AllStatements, &Expression)){QString sExpression = decode(Expression, false, s2ndOutput);
        if (popExpression(*AllStatements, &Array)){QString sArray = decode(Array, false, s2ndOutput);
        if (popExpression(*AllStatements, &Static)){QString sStatic = decode(Static, false, s2ndOutput); 
        if (popExpression(*AllStatements, &IsType)){QString sIsType = decode(IsType, false, s2ndOutput);

        



        if (sIsType.contains("true")){
          s += DEFAULTNAME + QString(" %1").arg(sIdentifier);
          s += "; " + PREFIX + "ASSIGNMENT(&" + sIdentifier + ", &" + PREFIX + "ID()); ";
          s += sExpression;
        } else {

          if (sStatic.contains("true")){
            if (bVM){

              QString sStatements;

              sStatements += " Q7BV << \"String\"; "; 
              sStatements += " Q7BV << \"" + sIdentifier + "\"; "; 
              sStatements += " Q7BV << \"Local Static\"; "; 

              if (!sExpression.isEmpty()){
                sStatements += sExpression;
                sStatements += " Q7BV << \"String\"; "; 
                sStatements += " Q7BV << \"" + sIdentifier + "\"; "; 
                sStatements += " Q7BV << \"Local Variable\"; "; 

                sStatements += " Q7BV << \"Assignment\"; "; 
              }

              s += "; Q7BV << \"STATIC\"; "; 
              s += " Q7BV << " + QString("%1").arg(sStatements.count("<<")) + "; "; 
              s += " Q7BV << \"" + sIdentifier + "\"; "; 
              s += sStatements;


            } else {
              s += QString("static ") + DEFAULTNAME + QString(" %1").arg(sIdentifier);
              if (!sExpression.isEmpty()){
                s += QString(" = " + PREFIX + "STATICASSIGNMENT(&") + sIdentifier + ", &" + sExpression + ")";              
            
             //   s += QString(" = " + PREFIX + "STATICASSIGNMENT(&") + sIdentifier + ", &" + PREFIX + "ID())";
              }
            }
          } else {

            if (bVM){
              
              s += " Q7BV << \"String\"; "; 
              s += " Q7BV << \"" + sIdentifier + "\"; "; 
              s += " Q7BV << \"Local Dim\"; "; 

              if (!sExpression.isEmpty()){
                s += sExpression;
                s += " Q7BV << \"String\"; "; 
                s += " Q7BV << \"" + sIdentifier + "\"; "; 
                s += " Q7BV << \"Local Variable\"; "; 
                s += " Q7BV << \"Assignment\"; "; 
              }

            } else {

              s += DEFAULTNAME + QString(" %1").arg(sIdentifier);

              if (!sExpression.isEmpty()){
                s += "; " + PREFIX + "ASSIGNMENT(&" + sIdentifier + ", &(" + PREFIX + "_" + sType.toUpper() + "(" + sExpression + ")))";
              }
            }

          }

        }

        s += ";\n";

        }}}

         }
      } else {
        CompilerError();        
      }

    } else {
      CompilerError();        
    }

    } else if (id == "Class Dim"){

      QString sId;
      _statements Identifier;
      _statements Type;
      _statements Expression;
      _statements Array;
      _statements IsType;
      _statements IsIBOutlet;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier) && popExpression(*AllStatements, &Type) && popExpression(*AllStatements, &Expression) && popExpression(*AllStatements, &Array) && popExpression(*AllStatements, &IsType) && popExpression(*AllStatements, &IsIBOutlet)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);
        QString sType = decode(Type, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);
        QString sIBOutlet = decode(IsIBOutlet, false, s2ndOutput);
        QString sIsType = decode(IsType, false, s2ndOutput);


        if (bVM){
          
        } else {
          if (s2ndOutput) *s2ndOutput += DEFAULTNAME + QString(" %1").arg(sIdentifier) +  ";\n";
        }        


        if (bVM){

          if (sIsType.contains("true")){
            s += sExpression;
          } else {
            if (!sExpression.isEmpty()){
              s += "{\n";
              s += "  _bytecodes Q7BV; ";
              //if (!sExpression.contains("Q7BV <<")){ // WORKAROUND
            //    sExpression = "Q7BV <<" + sExpression + "; ";
            
              s += sExpression;
              QString sss = "Q7B_VM_RUN(\"" + Me.sFileName + "\", \"" + Me.sFileName + "\", Q7BV, q7b_this, QMap<QString, Q7B>(), &QMap<QString, Q7B>(), QMap<QString, Q7B>())";             
              s += "  q7b_this->VM_Q7B_me_vars->insert(\"" + sIdentifier + "\", " + sss + ");\n";
              s += "}\n";
            }
          }
        } else {
          if (sIsType.contains("true")){
            s += sExpression;
          } else {
            if (!sExpression.isEmpty()){
              s += "  " + PREFIX + "ASSIGNMENT(&" + sIdentifier + ", &(" + "" + sExpression + "));\n";
            }
          }
        }



      } else {
        CompilerError();        
      }

    } else if (id == "Global Dim"){

      QString sId;
      _statements Identifier;
      _statements Type;
      _statements Expression;
      _statements Array;
      _statements Class;
      _statements IsType;

      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Identifier) && popExpression(*AllStatements, &Type) && popExpression(*AllStatements, &Expression) && popExpression(*AllStatements, &Array) && popExpression(*AllStatements, &Class) && popExpression(*AllStatements, &IsType)){

        QString sIdentifier = decode(Identifier, false, s2ndOutput);
        QString sType = decode(Type, false, s2ndOutput);
        QString sExpression = decode(Expression, false, s2ndOutput);
        QString sClass = decode(Class, false, s2ndOutput);
        QString sIsType = decode(IsType, false, s2ndOutput);


        if (s2ndOutput) *s2ndOutput += QString("static ") + DEFAULTNAME + QString(" %1").arg(sIdentifier) +  ";\n";

        if (sIsType.contains("true")){
          s += sExpression;
        } else {
          if (!sExpression.isEmpty()){
            if (s3ndOutput) *s3ndOutput += DEFAULTNAME + QString(" %1::%2 = ").arg(sClass).arg(sIdentifier) + PREFIX + "ASSIGNMENT2(&" + sIdentifier + ", &" + "" + sExpression + ");\n";
     //       if (s3ndOutput) *s3ndOutput += "Q7B_ASSIGNMENT(&" + QString("%1::%2").arg(sClass).arg(sIdentifier) + ", &" + "" + sExpression + ");\n";
          }
        }


      } else {
        CompilerError();        
      }

    } else if (id == "Code"){

      QString sCode;

      if (popCode(*AllStatements, &sCode)){

        if (!sCode.isEmpty()){
          s += sCode;
        }

      } else {
        CompilerError();        
      }

    } else if (id == "Do While ? ... Loop" || id == "Do Until ? ... Loop"){

      QString sId;
      _statements Condition;
      _statements Statements;
      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Condition)){

        
        QString sStatements;
        if (popExpression(*AllStatements, &Statements)){
          sStatements = decode(Statements, false, s2ndOutput);
        }
        if (bVM){
          QString sCondition = decode(Condition, false, s2ndOutput);
          
          s += "; Q7BV << \"LOOPEND\"; "; 
          s += " Q7BV << " + QString("%1").arg(5 + sCondition.count("<<") + sStatements.count("<<")) + "; "; 
          
          s += "; Q7BV << \"LOOPSTART\"; "; 
          s += sCondition;
          
          if (id == "Do Until ? ... Loop"){
            s += "; Q7BV << \"DOUNTILLOOP\"; "; 
          } else {
            s += "; Q7BV << \"DOWHILELOOP\"; "; 
          }
          s += " Q7BV << " + QString("%1").arg(2 + sStatements.count("<<")) + "; "; 
          
          s += sStatements;
          
          s += " Q7BV << \"JMP\"; "; 
          s += " Q7BV << " + QString("%1").arg(-(4 + sCondition.count("<<") + sStatements.count("<<"))) + "; "; 
          
          s += "; Q7BV << \"LOOPEND2\"; "; 
        } else {
          QString sCondition = PREFIX + "CBOOL(" + decode(Condition, false, s2ndOutput) + ")";
          s += QString("while (%1%2){\n%3").arg(id == "Do Until ? ... Loop" ? "!" : "").arg(sCondition).arg(sStatements);
        }        

      } else {
        CompilerError();        
      }

    } else if (id == "End Do While ? ... Loop" || id == "End Do Until ? ... Loop"){

      QString sId;
      if (pop(*AllStatements, &sId)){
 
        if (bVM){
        } else {
          s += QString("\n}\n");
        }        

      } else {
        CompilerError();        
      }

    } else if (id == "Do ... Loop While ?" || id == "Do ... Loop Until ?"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){
        } else {
          s += QString("do {\n");
        }     

      } else {
        CompilerError();        
      }

    } else if (id == "End ... Do Loop While ?" || id == "End ... Do Loop Until ?"){

      QString sId;
      _statements Condition;
      _statements Statements;
      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Condition)){

        QString sStatements;
        if (popExpression(*AllStatements, &Statements)){
          sStatements = decode(Statements, false, s2ndOutput);
        }

        if (bVM){  
          QString sCondition = decode(Condition, false, s2ndOutput);
          
          s += "; Q7BV << \"LOOPEND\"; "; 
          s += " Q7BV << " + QString("%1").arg(5 + sCondition.count("<<") + sStatements.count("<<")) + "; "; 
          
          s += "; Q7BV << \"LOOPSTART\"; "; 
          
          s += sStatements;
          s += sCondition;
          
          if (id == "End ... Do Loop Until ?"){
            s += "; Q7BV << \"DOLOOPUNTIL\"; "; 
          } else {
            s += "; Q7BV << \"DOLOOPWHILE\"; "; 
          }
          s += " Q7BV << " + QString("%1").arg(2 + sStatements.count("<<")) + "; "; 
          
          s += " Q7BV << \"JMP\"; "; 
          s += " Q7BV << " + QString("%1").arg(-(4 + sCondition.count("<<") + sStatements.count("<<"))) + "; "; 
          
          s += "; Q7BV << \"LOOPEND2\"; "; 
        } else {
          QString sCondition = PREFIX + "CBOOL(" + decode(Condition, false, s2ndOutput) + ")";
          s += QString("%1\n} while (%2%3);\n").arg(sStatements).arg(id == "End ... Do Loop Until ?" ? "!" : "").arg(sCondition);
        }     

      } else {
        CompilerError();        
      }

    } else if (id == "Break"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){  
          s += " Q7BV << \"BREAK\"; "; 
        } else {
          s += QString("break;\n");
        }           

      } else {
        CompilerError();        
      }

    } else if (id == "Continue"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){  
          s += " Q7BV << \"CONTINUE\"; "; 
        } else {
          s += QString("continue;\n");
        }         

      } else {
        CompilerError();        
      }

    } else if (id == "If"){

      QString sId;
      _statements Condition;
      _statements Statements;
      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Condition)){

        
        QString sStatements;
        if (popExpression(*AllStatements, &Statements)){
          sStatements = decode(Statements, false, s2ndOutput);
        }

        if (bVM){
          QString sCondition = decode(Condition, false, s2ndOutput);
          s += sCondition;
          s += "; Q7BV << \"IF\"; "; 
          s += " Q7BV << " + QString("%1").arg(sStatements.count("<<")) + "; "; 
          s += sStatements;
        } else {
          QString sCondition = PREFIX + "CBOOL(" + decode(Condition, false, s2ndOutput) + ")";
          s += QString("\nif (%1){\n%2").arg(sCondition).arg(sStatements);
        }        

      } else {
        CompilerError();        
      }

    } else if (id == "Else If"){

      QString sId;
      _statements Condition;
      _statements Statements;
      if (pop(*AllStatements, &sId) && popExpression(*AllStatements, &Condition)){
        
        QString sStatements;
        if (popExpression(*AllStatements, &Statements)){
          sStatements = decode(Statements, false, s2ndOutput);
        }

        if (bVM){
          QString sCondition = decode(Condition, false, s2ndOutput);
          s += sCondition;          

          s += "; Q7BV << \"ELSEIF\"; "; 
          s += " Q7BV << " + QString("%1").arg(sStatements.count("<<")) + "; "; 
          s += sStatements;

        } else {
          QString sCondition = PREFIX + "CBOOL(" + decode(Condition, false, s2ndOutput) + ")";
          s += QString("\n} else if (%1){\n%2").arg(sCondition).arg(sStatements);
        }
        
      } else {
        CompilerError();        
      }

    } else if (id == "Else"){

      QString sId;
      _statements Statements;
      if (pop(*AllStatements, &sId)){

        QString sStatements;
        if (popExpression(*AllStatements, &Statements)){
          sStatements = decode(Statements, false, s2ndOutput);
        }

        if (bVM){
          s += "; Q7BV << \"ELSE\"; "; 
          s += " Q7BV << " + QString("%1").arg(sStatements.count("<<")) + "; "; 
          s += sStatements;

        } else {
          s += QString("\n} else {\n%1").arg(sStatements);
        }        

      } else {
        CompilerError();        
      }

    } else if (id == "End If"){

      QString sId;
      if (pop(*AllStatements, &sId)){

        if (bVM){
          s += "; Q7BV << \"ENDIF\"; "; 

        } else {
          s += QString("\n}\n");
        }        

      } else {
        CompilerError();        
      }

    } else if (id == "Integer"){

      qint64 Integer;
      if (popInteger(*AllStatements, &Integer)){



        if (bVM){
          s += " Q7BV << \"Integer\";"; 
          s += "; Q7BV << "; 
          s += "(qint64)" + QString::number(Integer) + ";";
        } else {
          s += QString(PREFIX + "ID((qint64) %1)").arg(Integer);
        }             
        


      } else {
        CompilerError();        
      }

    } else if (id == "Long"){

      qint64 Integer;
      if (popInteger(*AllStatements, &Integer)){



        if (bVM){
          s += " Q7BV << \"Integer\";"; 
          s += "; Q7BV << "; 
          s += "(qint64)" + QString::number(Integer) + ";";
        } else {
          s += QString(PREFIX + "ID((qint64) %1)").arg(Integer);
        }            
        


      } else {
        CompilerError();        
      }

    } else if (id == "Decimal"){

      QString Decimal;
      if (popDecimal(*AllStatements, &Decimal)){
        
        QString bc;
        QString ad;

        if (Decimal.indexOf(".") > 0){
          bc = Decimal.left(Decimal.indexOf("."));
          ad = Decimal.mid(Decimal.indexOf(".") + 1);
          ad = ad.left(ad.length() - 1);
        } else {
          bc = "0";
          ad = Decimal.mid(Decimal.indexOf(".") + 1);
          ad = ad.left(ad.length() - 1);
        }
        if (ad.isEmpty()) ad = "0";

        if (bVM){
          s += " Q7BV << \"Decimal\";"; 
          s += " Q7BV << \"" + bc + "\"" + ";"; 
          s += " Q7BV << \"" + ad + "\"" + ";"; 
        } else {
          s += QString(PREFIX + "ID_DECIMAL(%1, %2)").arg(bc).arg(ad);
        }     
        

      } else {
        CompilerError();        
      }

    } else if (id == "Float"){

      qreal Float;
      if (popFloat(*AllStatements, &Float)){

        if (bVM){
          s += " Q7BV << \"Float\":"; 
          s += "; Q7BV << "; 
          s += "(double)" + QString::number(Float, 'g', 12) + ";";
        } else {
          s += PREFIX + "ID((double)" + QString::number(Float, 'g', 12) + ")";
        }     
        
      } else {
        CompilerError();        
      }

    } else if (id == "Boolean"){

      bool Boolean;
      if (popBoolean(*AllStatements, &Boolean)){



        if (bVM){
          s += " Q7BV << \"Boolean\";"; 
          s += "; Q7BV << "; 
          s += "(bool)" + QString::number(Boolean) + ";";
        } else {
          s += QString(PREFIX + "ID(%1)").arg(Boolean ? "true" : "false");
        }           
          


      } else {
        CompilerError();        
      }


    } else if (id == "Me"){
      
     
      if (popMe(*AllStatements)){



        if (bVM){
          s += " Q7BV << \"ME\";"; 
        } else {
          s += "q7b_this";
        }         
        

      } else {
        CompilerError();        
      }

    } else if (id == "Null"){           

      if (popNull(*AllStatements)){



        if (bVM){
          s += " Q7BV << \"NULL\";"; 
        } else {
          s += PREFIX + "IDNULL()";
        }     
        

      } else {
        CompilerError();        
      }

    } else if (id == "Nil"){

      if (popNil(*AllStatements)){

        if (bVM){
          s += " Q7BV << \"NIL\";"; 
        } else {
          s += PREFIX + "IDNIL()";
        }     
        
      } else {
        CompilerError();
      }

    } else {

      id = id;
    }
    
    int nu = AllStatements->size();
    nu = nu;
  }

  QMapIterator<QString, int> r(labels_VM);
  while (r.hasNext()) {
    r.next();

    QString sName = r.key();
    int nPos = r.value();

    if (gotos_VM.contains(sName)){
      for (int i = 0; i < gotos_VM[sName].count(); i++){
        
        int nGoto = 0;
        if (nPos < gotos_VM[sName].at(i)){
          nGoto = -(s.mid(nPos, gotos_VM[sName].at(i) - nPos).count("<<")); 
        } else {
          nGoto = s.mid(gotos_VM[sName].at(i), nPos - gotos_VM[sName].at(i)).count("<<"); 
        }
        s.insert(gotos_VM[sName].at(i), QString("(qint64) %1").arg(nGoto));

      }
    }
  }

  return s;
}

QString Compiler::decode_function(_statements & AllStatements, QString sSubFunctionIBActionActionSignalEventDelegateSlot)
{
  QString s;
  if (CONFIG["VM"] == "true" && AllStatements.size() > 0){
    //s += "QList<Q7B> global_vars;\n";

    s += "_bytecodes Q7BV;\n";

    s += decode(AllStatements);

    s += QString("if (Q7BV.size() > 0) %1Q7B_VM_RUN(\"" + Me.sFileName + "\", \"" + Me.sFileName + "\", Q7BV, q7b_this, Q7B_args, &Q7B_statics, *(q7b_this->VM_Q7B_me_vars));\n").arg(sSubFunctionIBActionActionSignalEventDelegateSlot == "Function" ? "return ": "");
  } else {
    return decode(AllStatements);
  }

  return s;
}

bool Compiler::compile(QString sFileName)
{


  QString s;

  Me.sFileName = sFileName;
  
  QString sClass = Parser::getClassName(sFileName);
  QString sSuperClass= Parser::getSuperClassName(sFileName);

  //if (sClass == "Application"){
   
//  }

  _statements ClassStatements = Parser::Me.ClassStatements[sClass];  

  QString sClassInit;
  QString sGlobal;
  QString sGlobal_h;

  QString c;
  QString h;

  QString sUDFClassCast_c;
  QString sUDFClassCast_h;

  QString h_variablesconstants;
  QString c_globalvariablesconstants;



  bool b_UI_File = false;
  bool bQtDesignerClass = Parser::isQtDesignerClassFileName(sFileName);
  if (bQtDesignerClass){ 
    b_UI_File = QFile::exists(CONFIG["PROJECTPATH"] + "/" + sClass + ".ui");
  }

  sClassInit += "  setObjectName(\"" + sClass + "\");\n"; 

  h += "#ifndef " + PREFIX + sClass.toLower() + "_h\n";
  h += "#define " + PREFIX + sClass.toLower() + "_h\n\n";

  h += "#include \"Q7BRuntime.h\"\n\n";

  if (sClass == "Global"){
    if (!Parser::Me.sCPPProHeaderFiles.isEmpty()){
      h += "\n" + Parser::Me.sCPPProHeaderFiles + "\n";
    }
  }

  c += "#include \"Global.h\"\n\n"; 

  if (sClass == "Global"){
      h += "class Q7B_workaround_eventloop : public QObject\n";
      h += "{\n";
      h += "Q_OBJECT\n";
      h += "public:\n";
      h += "public slots:\n";
      h += "void q7b_workaround_eventloop_();\n";
      h += "};\n";
  }

  if (!Parser::Me.classes.contains(sSuperClass) && !Parser::Me.controls.contains(sSuperClass)){ 
    h += "#include \"" + sSuperClass + ".h\"\n\n";
  }
   
  if (b_UI_File){   
    h += "namespace Ui {\n";
    h += "  class " + sClass + ";\n";
    h += "}\n\n";
  }

  h += "\nclass " + sClass + ";\nextern " + sClass + " *Q7B_" + sClass + "_Class(Q7B o);\nextern Q7B Q7B_" + sClass + "_Object();\nextern " + sClass + " *q7b_" + sClass + "_Object;\nextern Q7B q7b_" + sClass + "_Object_Q7B;\nextern bool q7b_" + sClass + "_Object_Finalized;\nextern bool q7b_" + sClass + "_Object_Init;\n\n";

  if (sSuperClass == "FormClass"){
    h += "#define FormClass Q7B_FormClass\n";
  }
  if (sSuperClass == "uiClass"){
    h += "#define uiClass Q7B_uiClass\n";
  }
  if (sSuperClass == "Class"){
    h += "#define Class Q7B_Class\n";
  }
  if (sSuperClass == "Module"){
    h += "#define Module Q7B_Module\n";
  }

  if (bQtDesignerClass || CONFIG["SINGLEFILEPROJECT"] == "true" || sClass == "Global"){
    h += "\nextern QMap<QString, Q7B>q7b_ui;\n\n";  
  }  

  h += "\nextern Q7B Q7B_MainWindow_Object();\n"; 

h += "\nextern Q7B Q7B_CMath_Object();\n"; 
  h += "\nextern Q7B Q7B_Preferences_Object();\n"; 
  h += "\nextern Q7B Q7B_Application_Object();\n"; 
  h += "\nextern Q7B Q7B_Debug_Object();\n"; 
  
  //h += "\nextern Q7B Q7B_SystemTrayIcon_Object();\n";   
  h += "\nextern Q7B Q7B_OS_Object();\n"; 
  h += "\nextern Q7B Q7B_File_Object();\n"; 
  h += "\nextern Q7B Q7B_Desktop_Object();\n"; 
  h += "\nextern Q7B Q7B_Dir_Object();\n"; 
  h += "\nextern Q7B Q7B_OpenFileDialog_Object();\n"; 
  h += "\nextern Q7B Q7B_SaveFileDialog_Object();\n"; 
  h += "\nextern Q7B Q7B_ColorDialog_Object();\n"; 
  h += "\nextern Q7B Q7B_FontDialog_Object();\n"; 

  h += "\nextern Q7B Q7B_ProgressDialog_Object();\n"; 
  h += "\nextern Q7B Q7B_InputDialog_Object();\n"; 
  h += "\nextern Q7B Q7B_Database_Object();\n"; 
  h += "\nextern Q7B Q7B_Table_Object();\n"; 
  h += "\nextern Q7B Q7B_Records_Object();\n"; 
  h += "\nextern Q7B Q7B_Query_Object();\n"; 
  h += "\nextern Q7B Q7B_MessageBox_Object();\n"; 
  h += "\nextern Q7B Q7B_ToolBar_Object();\n"; 
  h += "\nextern Q7B Q7B_Sounds_Object();\n"; 
  h += "\nextern Q7B Q7B_Pixmaps_Object();\n"; 
  h += "\nextern Q7B Q7B_Colors_Object();\n"; 
  h += "\nextern Q7B Q7B_Fonts_Object();\n"; 
  h += "\nextern Q7B Q7B_StatusBar_Object();\n"; 
  
  QString sSuperClass2 = sSuperClass;

  if (sSuperClass == "uiClass"){ 
     QString rr = CONFIG["PROJECTPATH"] + "/" + sClass + ".ui";

     
      if (QFile::exists(rr)){
        QString s = Parser::LoadFile(rr);  
        
        int m = 0;
        if((m = s.indexOf("<widget class=\"", m)) >= 0){
          m += 15;
          int m2 = s.indexOf("\"", m);
          sSuperClass2 = s.mid(m, m2 - m);          
        }
      }
    

  }

  h += "class " + sClass + " : public " + sSuperClass2 + "\n";
  
  h += "{\nQ_OBJECT\n";
  h += "public:\n";

  if (sClass == "Global"){

    QStringList ll = Parser::Me.Classes.keys();
    ll << Parser::Me.DeclareClasses.keys();
    for (int q = 0; q < ll.size(); q++){
      QString sClass2 = ll.at(q);

      if (sClass2.isEmpty()) continue;

      if ((!Parser::Me.classes.contains(sClass2) && !Parser::Me.controls.contains(sClass2))){
//      if (sClass2 == "Global" || (!Parser::Me.classes.contains(sClass2) && !Parser::Me.controls.contains(sClass2) && !Parser::Me.objects.contains(sClass2))){

        c += "\n#include \"" + sClass2 + ".h\"\n\n";

        sUDFClassCast_c += "\nQ7B Q7B_ID(" + sClass2 + " * o)\n";
        sUDFClassCast_c += "{\n";
        sUDFClassCast_c += "  Q7B q (new Q7B_id(typeid(" + sClass2 + ").name(), o));\n";
        sUDFClassCast_c += "  return q;\n";
        sUDFClassCast_c += "}\n";

        sUDFClassCast_c += "\nQ7B Q7B__" + sClass2.toUpper() + "(Q7B o)\n";
        sUDFClassCast_c += "{\n";

        sUDFClassCast_c += "  " + sClass2 + " *test = qobject_cast<" + sClass2 + " *>((QObject *) o->ref);\n";

        //sUDFClassCast_c += "  if (QString(o->type) == typeid(" + sClass2 + ").name()){\n"; // TODO2  sub classes ber?cksichtigen
        sUDFClassCast_c += "  if (test) return o;\n";
        //sUDFClassCast_c += "  }\n";
        sUDFClassCast_c += "  Q7B_CASTEXCEPTION(\"'" + sClass2 + "' for assignment expected, tried '\" + QString(o->type) + \"'\");\n";
        sUDFClassCast_c += "  return Q7B_idnil;\n";
        sUDFClassCast_c += "}\n";

        sUDFClassCast_h += "class " + sClass2 + ";\n";
        sUDFClassCast_h += "extern Q7B Q7B_ID(" + sClass2 + "* o);\n";
        sUDFClassCast_h += "extern Q7B Q7B__" + sClass2.toUpper() + "(Q7B o);\n";

        if (Parser::Me.DeclareClasses.contains(sClass2)){
          sUDFClassCast_h += "extern " + sClass2 + " *Q7B_" + sClass2 + "_Class(Q7B o);\n";
  //        sUDFClassCast_c += sClass2 + " *Q7B_" + sClass2 + "_Class(Q7B o){ QMessageBox::information(0, \"aa\", \"aa\"); ((" + sClass2 + " *) (o->ref))->setRange(0, 10);QMessageBox::information(0, \"bb\", \"bb\"); return (" + sClass2 + " *) (o->ref); }\n";
          sUDFClassCast_c += sClass2 + " *Q7B_" + sClass2 + "_Class(Q7B o){ return (" + sClass2 + " *) (o->ref); }\n";
           
        }
      }
    }   

  } else {
  
    c += "\n#include \"" + sClass + ".h\"\n\n";

    for (int q = 0; q < Me.sReferences[sClass].size(); q++){
      QString sClass2 = Me.sReferences[sClass].at(q);

      if (sClass2 != sClass){
        c += "#include \"" + sClass2 + ".h\"\n";
      }
      
    }
  }

  c += "\n";

  c += "#define CommandButton Q7B_CommandButton\n";
  c += "#define CommandLinkButton Q7B_CommandLinkButton\n";
  c += "#define ImageButton Q7B_ImageButton\n";
  c += "#define ToolButton Q7B_ToolButton\n";
  c += "#define CheckBox Q7B_CheckBox\n";
  c += "#define RadioButton Q7B_RadioButton\n";
  c += "#define Label Q7B_Label\n";
  c += "#define Frame Q7B_Frame\n";
  c += "#define ImageBox Q7B_ImageBox\n";
  c += "#define TextBox Q7B_TextBox\n";
    
  c += "#define FormClass Q7B_FormClass\n";
  c += "#define uiClass Q7B_uiClass\n";
  c += "#define Class Q7B_Class\n";
  c += "#define Module Q7B_Module\n";
 
  //c += "#define Box Q7B_Box\n"; // geht nicht kollidiert mit Qt namespace!
  c += "#define Control QWidget\n";
  c += "\n";
  
  
  if (!Parser::Me.Classes.keys().contains("Application")){
    if (sClass == "Global") c += "extern Q7B Q7B_idAPPLICATION;\nQ7B Q7B_Application_Object(){ if (Q7B_nil(Q7B_idAPPLICATION)){ Q7B_idAPPLICATION = Q7B(new Q7B_id(typeid(QApplication).name(), qApp)); } return Q7B_idAPPLICATION; }\n";
    //c += "extern Q7B Q7B_Application_Object();\n";
  }
  if (!Parser::Me.Classes.keys().contains("SystemTrayIcon")){
    if (sClass == "Global") c += "extern Q7B Q7B_idSYSTEMTRAYICON;\nQ7B Q7B_SystemTrayIcon_Object(){ if (Q7B_nil(Q7B_idSYSTEMTRAYICON)){ Q7B_idSYSTEMTRAYICON = Q7B(new Q7B_id(typeid(QSystemTrayIcon).name(), new QSystemTrayIcon())); } return Q7B_idSYSTEMTRAYICON; }\n";
    //c += "extern Q7B Q7B_Application_Object();\n";
  }
  //if (!Parser::Me.Classes.keys().contains("SystemTrayIcon")){
    //if (sClass == "gl") c += "Q7B Q7B_SystemTrayIcon_Object(){ return q7b_object[\"SystemTrayIcon\"]; }\n";
    //c += "extern Q7B Q7B_SystemTrayIcon_Object();\n";
  
  //c += "extern Q7B Q7B_Preferences_Object();\n";

  QStringList ll = Parser::Me.Classes.keys();
  for (int q = 0; q < ll.size(); q++){
    QString sClass2 = ll.at(q);
    if (Me.sReferences[sClass2].contains(s)){
      c += "\nextern " + sClass2 + " *Q7B_" + sClass2 + "_Class(Q7B o);\nextern Q7B Q7B_" + sClass2 + "_Object();\n";
    }

  }

  c += "\n";


  QString sApplicationClass;
  if (sClass == "Application"){
    sApplicationClass = Parser::getClassName(sFileName);
//    sSuperClass = "QObject";  
 /////    sMyInit += "connect(qApp, SIGNAL(focusChanged(QWidget *, QWidget *)), this, SLOT(on_focusChanged(QWidget *, QWidget *)));\n";
    if (Parser::Me.SubsFunctions[sClass].contains("on_lastWindowClosed")){
      sClassInit += "connect(qApp, SIGNAL(lastWindowClosed()), this, SLOT(on_lastWindowClosed()));\n";
    }
  } else if (sSuperClass == "QSystemTrayIcon"){
    if (CONFIG["SYSTEMTRAYICONFILE"] == "true"){
      if (Parser::Me.SubsFunctions[sClass].contains("on_activated")){
        sClassInit += "connect(this, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(on_activated(QSystemTrayIcon::ActivationReason)));\n";
      }
      if (Parser::Me.SubsFunctions[sClass].contains("on_messageClicked")){
        sClassInit += "connect(this, SIGNAL(messageClicked()), this, SLOT(on_messageClicked()));\n";
      }
    }
  }
  
  if (CONFIG["SINGLEFILEPROJECT"] == "false"){
    if (CONFIG["APPLICATIONFILE"] == "true") c += "#include \"Application.h\"\n\n"; 
    if (CONFIG["SYSTEMTRAYICONFILE"] == "true"){
      c += "#include \"SystemTrayIcon.h\"\n\n"; 
    }
  }

  QString sSharedSingleInit;
  sSharedSingleInit += "  if (q7b_" + sClass + "_Object_Init){ q7b_" + sClass + "_Object_Init = false; ";
  
  sSharedSingleInit += "q7b_" + sClass + "_Object_Q7B = q7b_this = Q7B(new Q7B_id(typeid(" + sClass + ").name(), this)); } else q7b_this = Q7B(new Q7B_id(typeid(" + sClass + ").name(), this)); \n";
 

  
  c += sClass + " *Q7B_" + sClass + "_Class(Q7B o){ return " + sClass + "::ClassPointer(o); }\n";

  if (sClass == "Application"){
    c += "Q7B Q7B_" + sClass + "_Object(){ return " + sClass + "::SingleTonObject(0, 0); }\n";
  } else {
    c += "Q7B Q7B_" + sClass + "_Object(){ return " + sClass + "::SingleTonObject(); }\n";
  }

  for (int q = 0; q < Me.sReferences[sClass].size(); q++){
    QString sClass2 = Me.sReferences[sClass].at(q);

    if (sClass2 != sClass){
      c += "extern " + sClass + " *Q7B_" + sClass + "_Class(Q7B o);\n";
      c += "extern Q7B Q7B_" + sClass + "_Object();\n";
    }   
  }

  c += sClass + " *q7b_" + sClass + "_Object = 0;\n";
  c += "Q7B q7b_" + sClass + "_Object_Q7B;\n";
  c += "bool q7b_" + sClass + "_Object_Finalized = false;\n";
  c += "bool q7b_" + sClass + "_Object_Init = false;\n\n";


  QString sClassInit2 = decode(ClassStatements, true, &h_variablesconstants, &c_globalvariablesconstants);
  QString sClassInit3;

  if (CONFIG["VM"] == "true"){
    sClassInit += "q7b_this->VM_Q7B_me_vars = new QMap<QString, Q7B>;\n";
  }

  if (Parser::Me.SubsFunctions[sClass].contains("Init")){
    if (CONFIG["VM"] == "true"){
      sClassInit3 += "QMap<QString, Q7B> Q7B_args;\n";
      sClassInit3 += "static QMap<QString, Q7B> Q7B_statics;\n";
    }
    sClassInit3 += decode_function(Parser::Me.SubsFunctions[sClass]["Init"].Statements);    
  }
 
  {    
    if (bQtDesignerClass){
      h += sClass + "(Q7B _q7b_this, QWidget *parent = 0);\n";
      h += sClass + "(QWidget *parent = 0);\n";
    } else if (sClass == "Application"){
      h += sClass + "(int argc, char ** argv);\n";
    } else {
      h += sClass + "(QObject *parent = 0);\n";
    }

    if (b_UI_File){

      h += "Ui::" + sClass + " *ui;\n\n";

      c += "#include \"ui_" + sClass + ".h\"\n\n";

      QList<_variableconstant> VariablesConstants = Parser::Me.VariablesConstants[sClass].values();

      bool bFirst = true;
      for (int yy = 0; yy < VariablesConstants.size(); yy++){
        _variableconstant vc = VariablesConstants.at(yy);

        if (vc.bOutlet){
          QString n = vc.sName;
          QString t = vc.sType;

          if (t == "PhononVideoPlayer") t = "Phonon::VideoPlayer";
          else if (t == "PhononSeekSlider") t = "Phonon::SeekSlider";
          else if (t == "PhononVolumeSlider") t = "Phonon::VolumeSlider";
            
          if (bFirst){
            bFirst = false;
            sClassInit += "  Q7B q;\n";
            sClassInit += "  QObject *o;\n";
          }

          sClassInit += "  o = findChild<QObject *>(\"" + n + "\");"; 

          if (CONFIG["VM"] == "true"){
            sClassInit += " if (o){ q = Q7B(new Q7B_id(typeid(" + t + ").name(), o, false)); " + "q7b_this->VM_Q7B_me_vars->insert(\"" + vc.sName + "\", q); } else { " + "q7b_this->VM_Q7B_me_vars->insert(\"" + vc.sName + "\", Q7B_IDNULL()); }\n";            
          } else {
            sClassInit += " if (o){ q = Q7B(new Q7B_id(typeid(" + t + ").name(), o, false)); " + n + " = q; } else { " + n + " = Q7B_IDNULL(); }\n";            
          }          

          
        }
      }


    }

    sClassInit += sClassInit2;

    if (bQtDesignerClass){
      c += sClass + "::" + sClass + "(Q7B _q7b_this, QWidget *parent)\n : " + sSuperClass2 + "(parent)" + (b_UI_File ? ", ui(new Ui::" + sClass + ")" : "") + "\n";
      c += "{\n";
      c += "  q7b_this = _q7b_this;\n";
      if (b_UI_File) c += "  ui->setupUi(this);\n";
     // c += "  Init();\n";
      
      
      c += "}\n\n";

      c += sClass + "::" + sClass + "(QWidget *parent)\n : " + sSuperClass2 + "(parent)" + (b_UI_File ? ", ui(new Ui::" + sClass + ")" : "") + "\n";

    } else if (sClass == "Application"){

      c += sClass + "::" + sClass + "(int argc, char ** argv)\n : " + sSuperClass2 + "(argc, argv)" + "\n";

    } else {

      c += sClass + "::" + sClass + "(QObject *parent)\n : " + sSuperClass2 + "(parent)" + "\n";

    }

    c += "{\n";
    //c += "  q7b_this = Q7B(new Q7B_id(typeid(" + sClass + ").name(), this, false));\n";
    if (bQtDesignerClass && b_UI_File) c += "  ui->setupUi(this);\n";
    
    c += "  Init();\n";
    c += "}\n\n";

    if (!Parser::Me.SubsFunctions[sClass].contains("Finalize")){

      c += sClass + "::~" + sClass+ "()\n";
      c += "{\n";

      if (sClass != "MainWindow"){
        c += "  if (this == q7b_" + sClass + "_Object){ q7b_" + sClass + "_Object = 0; q7b_" + sClass + "_Object_Q7B = Q7B_IDNIL(); }\n";
      }

      if (b_UI_File) c += "  delete ui;\n";
  //    if (sClass == "Application"){
    //    c += "QMessageBox::information(0, \"delete Application\", \"\");\n";  
   
      c += "  q7b_this->ref = 0;\n";
      c += "}\n\n";

      h += QString("~") + sClass + "();\n";
    }

    if (b_UI_File && !Parser::Me.SubsFunctions[sClass].contains("CloseEvent") && sClass != "MainWindow"){
      c += "void " + sClass + "::closeEvent(QCloseEvent *e)\n";
      c += "{\n";      
      c += "  if (e->isAccepted() && this == q7b_" + sClass + "_Object){ q7b_" + sClass + "_Object = 0; q7b_" + sClass + "_Object_Q7B = Q7B_IDNIL(); }\n";
      c += "}\n\n";

      h += "void closeEvent(QCloseEvent *e);\n";
    }

  }

  if (!Parser::Me.SubsFunctions[sClass].contains("Init")){
  
    if (sClass == "Application"){
      c += sClass + "::" + sClass + "(Q7B _q7b_this, int argc, char ** argv) : " + sSuperClass2 + "(argc, argv)\n"; 
      h += sClass + "(Q7B _q7b_this, int argc, char ** argv);\n";
    } else {
      c += sClass + "::" + sClass + "(Q7B _q7b_this)\n";
      h += sClass + "(Q7B _q7b_this);\n";
    }

    c += "{\n"; 
    c += "  q7b_this = _q7b_this;\n";

   // if (CONFIG["VM"] == "true"){
    //  c += "q7b_this->VM_Q7B_me_vars = new QMap<QString, Q7B>;\n";
   

    //c += "  Init();\n";
    
    c += "}\n\n";

    
    
  }

  if (Parser::Me.SubsFunctions[sClass].contains("Init")){ 
    QString m;
   // m += "  q7b_this = Q7B(new Q7B_id(typeid(" + sClass + ").name(), this, false));\n";
    if (bQtDesignerClass && b_UI_File) m += "  ui->setupUi(this);\n";
    //m += "  Init();\n";
    

    Parser::Me.SubsFunctions[sClass]["Init"].Statements = Compiler::pushCode(m);// + Parser::Me.SubsFunctions[sClass]["Init"].Statements;
  }

  h += "void Init();\n";
  c += "void " + sClass + "::Init()\n{\n";
  c += sSharedSingleInit;
  c += sClassInit;
  c += sClassInit3;
  c += "}\n\n";

  if (Parser::Me.SubsFunctions[sClass].contains("Finalize")){ 
    QString m;

    if (sClass != "MainWindow"){
      m += "  if (this == q7b_" + sClass + "_Object){ q7b_" + sClass + "_Object = 0; q7b_" + sClass + "_Object_Q7B = Q7B_IDNIL(); }\n";
    }

    if (b_UI_File) m += "  delete ui;\n";
    m += "  q7b_this->ref = 0;\n";

    Parser::Me.SubsFunctions[sClass]["Finalize"].Statements = Parser::Me.SubsFunctions[sClass]["Finalize"].Statements + Compiler::pushCode(m);
  }

  if (b_UI_File && Parser::Me.SubsFunctions[sClass].contains("CloseEvent") && sClass != "MainWindow"){ 
    QString m;
    m += "  if (((QCloseEvent *) (e->ref))->isAccepted() && this == q7b_" + sClass + "_Object){ q7b_" + sClass + "_Object = 0; q7b_" + sClass + "_Object_Q7B = Q7B_IDNIL(); }\n";

    Parser::Me.SubsFunctions[sClass]["CloseEvent"].Statements = Parser::Me.SubsFunctions[sClass]["CloseEvent"].Statements + Compiler::pushCode(m);
  }

  QString h_signals;
  QString h_events_delegates;

  QList<_subfunction> SubsFunctions = Parser::Me.SubsFunctions[sClass].values();

  for (int yy = 0; yy < SubsFunctions.size(); yy++){
    _subfunction sf = SubsFunctions.at(yy);

    if (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal" || sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Event" || sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"){

      QString sOutletName;
      QString sOutletType; 
      //if (sf.sName.contains("on_activated")){
      if (sf.sName==("on_activated")){
        sf.sName = sf.sName;
      }

      if (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
        sOutletName = Parser::getSignalOutletName(sf.sName);

        QList<_variableconstant> VariablesConstants = Parser::Me.VariablesConstants[sClass].values();

        for (int yy = 0; yy < VariablesConstants.size(); yy++){
          _variableconstant vc = VariablesConstants.at(yy);

          
          {
            if (vc.sName == sOutletName){
              sOutletType = vc.sType;
              break;
            }
          }
        }

        if (sOutletType.isEmpty()){ 
       
          QString rr;                          
         // if (QFile::exists(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i))){
            //rr = CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + ll.at(i);
          
          rr = CONFIG["PROJECTPATH"] + "/" + Parser::getClassName(sf.sFileName) + ".ui";
          

          if (QFile::exists(rr)){
            QString s = Parser::LoadFile(rr);  
            
            int m = 0;
            while((m = s.indexOf("<widget class=\"", m)) >= 0){
              m += 15;
              int k = s.indexOf("name=\"", m);
              if (k > m){
                k += 6;
                int k2 = s.indexOf("\"", k);
                QString nn = s.mid(k, k2 - k);
                if (nn == sOutletName){
                  int m2 = s.indexOf("\"", m);
                  sOutletType = s.mid(m, m2 - m);
                  
                  break;
                }
              }

              m++;

            }

            if (sOutletType.isEmpty()){ 

              if (s.contains("<action name=\"" + sOutletName + "\">")){
                sOutletType = "QAction";
              }

            }

          }
        }
      }

      

      if (sf.sName != "Init" && sf.sName != "Finalize" && (sf.sSubFunctionIBActionActionSignalEventDelegateSlot != "Signal" || (!sOutletType.isEmpty() || (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal" && Parser::getSignalSignalName(sf.sName).isEmpty())))){

        QString sSignalName;
        if (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
          sSignalName = Parser::getSignalSignalName(sf.sName);

          if (sSignalName.isEmpty()){ 
            if (sClass == "Application"){
              sSignalName = sf.sName.mid(3); 
              sOutletType = sClass;
              sOutletName = "";
            } else if (sClass == "SystemTrayIcon"){
              sSignalName = sf.sName.mid(3); 
              sOutletType = sClass;
              sOutletName = "";
            }
          }

          if (sSignalName.isEmpty()){ 
            QString z; 
            z += "void " + sf.sName;
            z += "()\n{\n";
            z += "  this->" + SLOTESCAPE + sf.sName + "(";
            z += ");\n";
            z += "}\n";
            h_signals += z;
            continue;
          }
        } else {
          sSignalName = sf.sName;
          sOutletType = sClass;
        }
          
        bool bFound = false;
        QString sOutletType2 = sOutletType;
        bool bCheckForNamingError = false;

        {

          do {            

            {
               {


                        QString sDeclare;
                        QString sCast;
                        QString sCode;
                        _subfunction declare_sf;
                        QString z;

                        if (sSignalName == "itemClicked"){
                          sSignalName = sSignalName;
                        }

                        getDeclare(sOutletType, sSignalName, sf, &sDeclare, &sCast, &sCode, &declare_sf);

                        bCheckForNamingError = false;

                        if (sSignalName == "itemClicked"){
                          sSignalName = sSignalName;
                        }
                        

                 if (!sDeclare.isEmpty()){
                   bCheckForNamingError = true;
                   sDeclare = sDeclare.simplified();
                   sDeclare = sDeclare.replace("const ", "");
                   sDeclare = sDeclare.replace("&", "");
                   sDeclare = sDeclare.replace("* ", "*");

                   int a = sDeclare.indexOf("(");
                   int b = sDeclare.indexOf(")");
                   QString sArguments = sDeclare.mid(a + 1, b - (a + 1));



                   QStringList l;
                  
                     l = sArguments.split(",", QString::SkipEmptyParts);
                  

                   
                   //int asd2 = l.size();
                   if (sf.Arguments.size() != l.size()){
                     continue;
                   }

                 
                   QStringList DeclareArgumentNames;

                   for (int zz = 0; zz < l.size(); zz++){
                     QString q = l.at(zz).simplified();
                     QString sDeclareArgumentType;
                     if (q.contains(" ")){
                       int n = q.indexOf(" ") + 1;
                       int n2 = q.indexOf(" ", n + 1);
                       if (n2 == -1) n2 = q.length();
                       QString sName = Parser::plainCType(q.mid(n, n2 - n));
                       DeclareArgumentNames << sName;
                       sDeclareArgumentType = q.left(n - 1);
                     } else {
                       continue;
                       
                      
                     }

                     
                    // QString sdf657 = Parser::convertDeclareType(sDeclareArgumentType);
                     if (Parser::convertDeclareType(sf.Arguments.at(zz).sType) != Parser::convertDeclareType(sDeclareArgumentType)){
                       continue;
                      
                      
                     }
                   }               
                   

                   if (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
                     z += "void on_";
                     if (!sOutletName.isEmpty()) z += sOutletName + "_";
                     z += sDeclare.mid(sDeclare.indexOf(" ") + 1) + "\n{\n";
                   } else {
                     z += sDeclare + "\n{\n";
                   }                 

                   if (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
                     z += "  this->" + SLOTESCAPE + "on_";
                     if (!sOutletName.isEmpty()) z += sOutletName + "_";
                     z += sSignalName + "(";
                   } else {
                     z += "  this->" + SLOTESCAPE + sSignalName + "(";
                   }

                   if (sCast.isEmpty()){
                     for (int zz = 0; zz < DeclareArgumentNames.size(); zz++){
                       if (zz > 0) z += ", ";
                       z += PREFIX + "ID(" + DeclareArgumentNames.at(zz) + ")";
                     }
                   } else {
                     z += sCast; 
                   }

                   z += ");\n";

                   z += "}\n";

                   if (sf.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
                     h_signals += z;
                   } else {
                     h_events_delegates += z;
                   }

                   bFound = true;

                 
                 }
              }

              if (bFound) break;

            }

            if (Parser::Me.classes.contains(sOutletType)){
              sOutletType = Parser::Me.classes[sOutletType]; 
            } else if (Parser::Me.controls.contains(sOutletType)){
              sOutletType = Parser::Me.controls[sOutletType]; 
            } else if (Parser::Me.objects.contains(sOutletType)){
              sOutletType = Parser::Me.objects[sOutletType]; 
            } else if (Parser::Me.Classes.contains(sOutletType)){
              sOutletType = Parser::Me.Classes[sOutletType]; 
            } else {
              break;
            }

          } while (!sOutletType.isEmpty());

          if (!bFound && bCheckForNamingError) Parser::error(QString("Signal '%1' of '%2' not correctly named (file %3)").arg(sSignalName).arg(sOutletType2).arg(sFileName), false);

        
        }
      }
    }
  }

  if (!h_signals.isEmpty()){
    h += "\npublic slots:\n";
    h += h_signals;
  }

  if (!h_events_delegates.isEmpty()){
    h += "\npublic:\n";
    h += h_events_delegates;
  }

  if (!h_variablesconstants.isEmpty()){
    h += "public:\n";
    h += h_variablesconstants;
  }

  h += "\n\n";

  h += "\npublic:\nstatic void SingleTonInit(" + sClass + "*me)\n";

  h += "{\n";
  h += "q7b_" + sClass + "_Object = me;\n";
  h += "q7b_" + sClass + "_Object_Q7B = me->q7b_this;\n";
  h += "q7b_" + sClass + "_Object_Init = true;\n";
  h += "me->Init();\n";  
  h += "}\n";  

  if (sClass == "Application"){
    h += "\nstatic Q7B SingleTonObject(int argc, char **argv)\n";
  } else {
    h += "\nstatic Q7B SingleTonObject()\n";
  }


  h += "{\n";
  if (sClass == "Application"){
    h += "SingleTonObjectPointer(argc, argv);\n";
  } else {
    h += "SingleTonObjectPointer();\n";
  }
  h += "return q7b_" + sClass + "_Object_Q7B;\n";
  h += "}\n";  

  if (sClass == "Application"){
    h += "\n\nstatic " + sClass + "* SingleTonObjectPointer(int argc, char **argv)\n";
  } else {
    h += "\n\nstatic " + sClass + "* SingleTonObjectPointer()\n";
  }  

  h += "{\n";

  h += "if (q7b_" + sClass + "_Object_Finalized) return 0;\n";
  h += "if (q7b_" + sClass + "_Object == 0){\n";

  h += "q7b_" + sClass + "_Object_Init = true;\n";

  if (bQtDesignerClass){
    h += "if (q7b_ui.contains(\"" + sClass + "\")){\n";
    h += "  q7b_" + sClass + "_Object = (" + sClass + " *) (QWidget *) q7b_ui[\"" + sClass + "\"]->ref; \n";

    h += "} else {\n  q7b_" + sClass + "_Object = new " + sClass + "(q7b_" + sClass + "_Object_Q7B, 0); q7b_" + sClass + "_Object->Init();\n}\n";    

  } else {
    //h += "QMessageBox::information(0, \"a\", \"a\");\n";  
    if (sClass == "Application"){
      h += "q7b_" + sClass + "_Object = new " + sClass + "(q7b_" + sClass + "_Object_Q7B, argc, argv);\n";    
      h += "q7b_" + sClass + "_Object->Init();\n";    
    } else {
      h += "q7b_" + sClass + "_Object = new " + sClass + "(q7b_" + sClass + "_Object_Q7B);\n";    
      h += "q7b_" + sClass + "_Object->Init();\n";    
    }
  }  

  h += "}\n";
  h += "return q7b_" + sClass + "_Object;\n";
  h += "}\n";

  h += "\n\nstatic " + sClass + "* ClassPointer(Q7B o)\n";
  h += "{\n";
  h += "return (" + sClass + "*) o->ref;\n";
  h += "}\n";

  h += "\n\npublic:\n";


  if (sClass == "Global"){    

    sGlobal += "\nQEventLoop *q7b_workaround_eventloop = 0; Q7B_workaround_eventloop Q7B_workaround_eventloop_; void Q7B_workaround_eventloop::q7b_workaround_eventloop_(){  q7b_workaround_eventloop->exit(); }\n";  
    sGlobal += "\nextern bool Q7B_bDebug;\n";  

    sGlobal += "\nint main (int argc, char *argv[])\n";  
    sGlobal += "{\n";

    if (Parser::Me.Classes.keys().contains("Application")){
      sGlobal += "Application::SingleTonObject(argc, argv);\n"; // q7b_object["MainWindow"] wird auch dort gesetzt     
      sGlobal += "Application *q7b_qApp = Application::SingleTonObjectPointer(argc, argv);\n";
    } else {
      sGlobal += "QApplication *q7b_qApp = new QApplication(argc, argv);\n";
    }    

    //sGlobal += "qApp->addLibraryPath(\"C:\\\\Users\\\\Bernd\\\\Desktop\\\\q7basic_release\\\\Q7Basic\\\\mingw\");\n";    

    sGlobal += "qApp->addLibraryPath(qApp->applicationDirPath() + \"/plugins\");\n";    
   // sGlobal += "qApp->addLibraryPath(qApp->applicationDirPath() + \"/MySQL\");\n";    // ging nicht in unterverzeichnis
   // sGlobal += "qApp->addLibraryPath(qApp->applicationDirPath() + \"/PostgreSQL\");\n";    // ging nicht in unterverzeichnis 

    sGlobal += "qApp->setApplicationName(\"" + CONFIG["PROJECTNAME"] + "\");\n";

    QString ziu798sdf = CONFIG["SPLASH"];

    if (CONFIG["SPLASH"] == "true"){
      sGlobal += "QPixmap q7b_splash_pixmap(\":/Resources/splash.png\");\n";
      sGlobal += "QSplashScreen q7b_splash(q7b_splash_pixmap);\n";
      sGlobal += "q7b_splash.show();\n";
    }

    if (CONFIG["Deploy"] == "true"){
      sGlobal += "Q7B_bDebug = false;\n";
    }          

   // if (CONFIG["SINGLEFILEPROJECT"] == "true" || sApplicationClass.isEmpty()){
      //sGlobal += "q7b_object[\"Application\"] = Q7B(new Q7B_id(typeid(QApplication).name(), qApp, false)); \n";
   

    if (CONFIG["SYSTEMTRAYICONFILE"] == "false"){
      // sGlobal += "q7b_object[\"SystemTrayIcon\"] = Q7B(new Q7B_id(typeid(QSystemTrayIcon).name(), new QSystemTrayIcon())); \n";
    }

    sGlobal += "Global::SingleTonObject();\n"; // q7b_object["Global"] wird auch dort gesetzt

    if (CONFIG["SINGLEFILEPROJECT"] == "true" || sApplicationClass.isEmpty()){ // CONFIG["APPLICATIONFILE"] == "false" as well
    } else {
      sGlobal += "Application::SingleTonObject();\n"; // q7b_object["Application"] wird auch dort gesetzt
    }    
    
    if (CONFIG["SINGLEFILEPROJECT"] == "false"){
     // sGlobal += "Q7B__MSGBOX(Q7B_ID(\"sGlobal11\"));";
      sGlobal += "MainWindow::SingleTonObject();\n"; // q7b_object["MainWindow"] wird auch dort gesetzt     
      if (CONFIG["SPLASH"] == "true"){
        sGlobal += "q7b_splash.close();\n";
      }
      sGlobal += "MainWindow::SingleTonObjectPointer()->show();\n"; // q7b_object["MainWindow"] wird auch dort gesetzt     
     // sGlobal += "Q7B__MSGBOX(Q7B_ID(\"sGlobal33\"));";
      sGlobal += "int q7b_n = qApp->exec();\n";      
    } else if (CONFIG["SPLASH"] == "true"){
      sGlobal += "q7b_splash.close();\n";
    }
    

    sGlobal += "\n";     

    //sGlobal += "QMessageBox::information(0, \"1\", \"bn\");\n";  

    
    sGlobal += "QMapIterator<QString, Q7B> iii(q7b_ui);\nwhile (iii.hasNext()){\n  iii.next();\n"; 
    sGlobal += "  if (!((QWidget *) iii.value()->ref)->testAttribute(Qt::WA_DeleteOnClose)){\n"; 
    sGlobal += "    delete ((QWidget *) iii.value()->ref);\n"; 
    sGlobal += "  }\n"; 
    sGlobal += "q7b_ui[iii.key()]->ref = 0;\n"; 
    sGlobal += "q7b_ui[iii.key()] = Q7B_IDNIL();\n"; 

    sGlobal += "}\n"; 

    sGlobal += "\n";   

    

    if (CONFIG["SINGLEFILEPROJECT"] == "false"){
      QStringList lll;
      lll << Parser::Me.files;
      
      for (int yyy = 0; yyy < lll.count(); yyy++){
        QString qwert = Parser::getClassName(lll.at(yyy));
         if (qwert == "MainWindow") ;
         else if (qwert == "Global") ;
         else if (qwert == "Application") ;
         else if (qwert == "SystemTrayIcon") ;
         else sGlobal += "if (q7b_" + qwert + "_Object){ " + qwert + " *q7b_o" + qwert + " = " + qwert + "::SingleTonObjectPointer(); if (q7b_o" + qwert + "){ q7b_" + qwert + "_Object_Finalized = true; delete q7b_o" + qwert + "; q7b_" + qwert + "_Object = 0; q7b_" + qwert + "_Object_Q7B->ref = 0; }}\n";
      }

      sGlobal += "\n"; 
    }
    
    if (CONFIG["SYSTEMTRAYICONFILE"] == "false"){
      sGlobal += "if (Q7B_idSYSTEMTRAYICON != Q7B_IDNIL() && !Q7B_idSYSTEMTRAYICON.isNull() && Q7B_idSYSTEMTRAYICON->ref){ Q7B_idSYSTEMTRAYICON->ref = 0; Q7B_idSYSTEMTRAYICON = Q7B_idnil; }\n";      
    }

    if (CONFIG["SINGLEFILEPROJECT"] == "true" || sApplicationClass.isEmpty()){ // CONFIG["APPLICATIONFILE"] == "false" as well      
    } else {
      sGlobal += sApplicationClass + " *q7b_o" + sApplicationClass + " = " + sApplicationClass + "::q7b_Object(); if (q7b_o" + sApplicationClass + "){ q7b_" + sApplicationClass + "_Object_Finalized = true; delete q7b_o" + sApplicationClass + "; q7b_" + sApplicationClass + "_Object = 0;  q7b_" + sApplicationClass + "_Object_Q7B->ref = 0; }\n";
    }

    if (CONFIG["SINGLEFILEPROJECT"] != "true"){
      //sGlobal += "Q7B__MSGBOX(Q7B_ID(\"oMainWindow = MainWindow::SingleTonObjectPointer\"));";
      sGlobal += "MainWindow *q7b_oMainWindow = MainWindow::SingleTonObjectPointer(); if (q7b_oMainWindow){ q7b_MainWindow_Object_Finalized = true; delete q7b_oMainWindow; q7b_MainWindow_Object = 0;  q7b_MainWindow_Object_Q7B->ref = 0; }\n";   
    
      sGlobal += "q7b_workaround_eventloop = new QEventLoop();\n";
      sGlobal += "QTimer::singleShot(10, &Q7B_workaround_eventloop_, SLOT(q7b_workaround_eventloop_())); q7b_workaround_eventloop->exec();\n";
      sGlobal += "delete q7b_workaround_eventloop;\n";
    }

    sGlobal += "Global *q7b_oGlobal = Global::SingleTonObjectPointer(); if (q7b_oGlobal){ q7b_Global_Object_Finalized = true; delete q7b_oGlobal; q7b_Global_Object = 0;  q7b_Global_Object_Q7B->ref = 0; }\n";
    
    sGlobal += "q7b_workaround_eventloop = new QEventLoop();\n";
    sGlobal += "QTimer::singleShot(10, &Q7B_workaround_eventloop_, SLOT(q7b_workaround_eventloop_())); q7b_workaround_eventloop->exec();\n";
    sGlobal += "delete q7b_workaround_eventloop;\n";

    sGlobal += "Q7B_CLOSEALLDATABASES();\n";
    sGlobal += "Q7B_CLOSESCREEN();\n";    

    sGlobal += "if (Q7B_Preferences_Object() != Q7B_IDNIL()) ((QSettings *) Q7B_Preferences_Object()->ref)->sync();\n";    

//    sGlobal += "if (q7b_object[\"Preferences\"] != Q7B_IDNIL() && !q7b_object[\"Preferences\"].isNull() && q7b_object[\"Preferences\"]->ref) ((QSettings *) q7b_object[\"Preferences\"]->ref)->sync();\n";      
   
    sGlobal += "delete q7b_qApp;\n";      

    if (CONFIG["SINGLEFILEPROJECT"] == "false"){
      sGlobal += "return q7b_n;\n";
    } else {
      sGlobal += "return 0;\n";
    }
    
    sGlobal += "}\n";

    QString sLoadUI;
    QString sOpenWindow;
    QString sOpenDialog;
    QString sOpenToolWindow;
   
    
    for (int i = 0; i < Parser::Me.uiCompileFiles.size(); i++){     
      
      //if (QFileInfo(Parser::Me.uiCompileFiles.at(i)).isFile())
      {
        QString s = Parser::getBaseName(Parser::Me.uiCompileFiles.at(i));
        if (s != "MainWindow"){
          sOpenWindow +=  "  if (uiName == \"" + s + "\"){\n";
          sOpenWindow +=  "    if (q7b_ui.contains(\"" + s + "\")){\n";
          sOpenWindow +=  "      ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->showNormal(); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->activateWindow(); return q7b_ui[\"" + s + "\"];\n";
          sOpenWindow +=  "    } else {\n";

          sOpenWindow +=  "      q7b_ui[\"" + s + "\"] = Q7B(new Q7B_id(typeid(QWidget).name(), new " + s + "(q7b_ui[\"" + s + "\"], 0))); " + s + "::SingleTonInit(((" + s + " *) q7b_ui[\"" + s + "\"]->ref)); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->showNormal(); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->activateWindow(); return q7b_ui[\"" + s + "\"];\n";
          sOpenWindow +=  "    }\n";
          sOpenWindow +=  "  }\n";
          
          sOpenDialog +=  "  if (uiName == \"" + s + "\"){\n";
          sOpenDialog +=  "    if (q7b_ui.contains(\"" + s + "\")){\n";
          sOpenDialog +=  "      return q7b_ui[\"" + s + "\"];\n";
          sOpenDialog +=  "    } else {\n";
          sOpenDialog +=  "      q7b_ui[\"" + s + "\"] = Q7B(new Q7B_id(typeid(QWidget).name(), new " + s + "(q7b_ui[\"" + s + "\"], 0))); " + s + "::SingleTonInit(((" + s + " *) q7b_ui[\"" + s + "\"]->ref)); return q7b_ui[\"" + s + "\"];\n";
          sOpenDialog +=  "    }\n";
          sOpenDialog +=  "  }\n";

          sOpenToolWindow +=  "  if (uiName == \"" + s + "\"){\n";
          sOpenToolWindow +=  "    if (q7b_ui.contains(\"" + s + "\")){\n";
          sOpenToolWindow +=  "      ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->showNormal(); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->activateWindow(); return q7b_ui[\"" + s + "\"];\n";
          sOpenToolWindow +=  "    } else {\n";
          sOpenToolWindow +=  "      q7b_ui[\"" + s + "\"] = Q7B(new Q7B_id(typeid(QWidget).name(), new " + s + "(q7b_ui[\"" + s + "\"], 0))); " + s + "::SingleTonInit(((" + s + " *) q7b_ui[\"" + s + "\"]->ref)); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->setWindowFlags(((Qt::WindowFlags) ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->windowFlags()) | Qt::Tool); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->showNormal(); ((QWidget *) q7b_ui[\"" + s + "\"]->ref)->activateWindow(); return q7b_ui[\"" + s + "\"];\n";
          sOpenToolWindow +=  "    }\n";
          sOpenToolWindow +=  "  }\n";

          sLoadUI +=  "  if (uiName == \"" + s + "\"){\n";
          sLoadUI +=  "    QObject *oo = new " + s + "(q7b_this, 0); q7b_this = Q7B(new Q7B_id(typeid(QWidget).name(), oo));  ((" + s + " *) oo)->Init(); return q7b_this;\n";
          sLoadUI +=  "  }\n";
        }
      }
    }
   
    for (int i = 0; i < Parser::Me.uiRuntimeFiles.size(); i++){
      QString s = Parser::getBaseName(Parser::Me.uiRuntimeFiles.at(i));
      if (s != "MainWindow" && s != "Global" && s != "SystemTrayIcon"){
        sOpenWindow += "  if (uiName == \"" + s + "\"){\n";
        //sOpenWindow +=  "    if (q7b_ui.contains(\"" + s + "\")){\n";
        //sOpenWindow +=  "      q7b_ui[\"" + s + "\"]->showNormal(); return q7b_ui[\"" + s + "\"];\n";
        //sOpenWindow +=  "    } else {\n";

        sOpenWindow +=  "      QWidget *w = Q7B_CREATE_FROM_UI_FILE(\":/uifiles/" + (s.endsWith(".ui") ? s : s + ".ui") + "\", 0);\n";

        sOpenWindow +=  "      if (w){ w->setAttribute(Qt::WA_DeleteOnClose); w->showNormal(); w->activateWindow(); q7b_this = Q7B(new Q7B_id(typeid(QWidget).name(), w)); return q7b_this; }\n";
//        sOpenWindow +=  "      if (w){ w->setAttribute(Qt::WA_DeleteOnClose); q7b_ui[\"" + s + "\"] = w; w->show(); return w; }\n";
        sOpenWindow +=  "      return Q7B_IDNIL();\n";
        //sOpenWindow +=  "    }\n";
        sOpenWindow +=  "  }\n";

        sOpenDialog +=  "  if (uiName == \"" + s + "\"){\n";
        sOpenDialog +=  "    QWidget *w = Q7B_CREATE_FROM_UI_FILE(\":/uifiles/" + (s.endsWith(".ui") ? s : s + ".ui") + "\", 0);\n";
        sOpenDialog +=  "    if (w){ w->setAttribute(Qt::WA_DeleteOnClose); q7b_this = Q7B(new Q7B_id(typeid(QWidget).name(), w)); return q7b_this; }\n";
        sOpenDialog +=  "    return Q7B_IDNIL();\n";
        sOpenDialog +=  "  }\n";

        sOpenToolWindow += "  if (uiName == \"" + s + "\"){\n";
        sOpenToolWindow +=  "      QWidget *w = Q7B_CREATE_FROM_UI_FILE(\":/uifiles/" + (s.endsWith(".ui") ? s : s + ".ui") + "\", 0);\n";
        sOpenToolWindow +=  "      if (w){ w->setAttribute(Qt::WA_DeleteOnClose); w->setWindowFlags(((Qt::WindowFlags) w->windowFlags()) | Qt::Tool); w->showNormal(); w->activateWindow(); q7b_this = Q7B(new Q7B_id(typeid(QWidget).name(), w)); return q7b_this; }\n";
        sOpenToolWindow +=  "      return Q7B_IDNIL();\n";
        sOpenToolWindow +=  "  }\n";

        sLoadUI +=  "  if (uiName == \"" + s + "\"){\n";
        sLoadUI +=  "    QWidget *w = Q7B_CREATE_FROM_UI_FILE(\":/uifiles/" + (s.endsWith(".ui") ? s : s + ".ui") + "\", 0);\n";
        sLoadUI +=  "    if (w){ w->setAttribute(Qt::WA_DeleteOnClose); q7b_this = Q7B(new Q7B_id(typeid(QWidget).name(), w)); return q7b_this; }\n";
        sLoadUI +=  "  }\n";
      }
    }    

    sGlobal += "\nQ7B Q7B_GLOBAL_LOADUI(QString uiName)\n";  
    sGlobal += "{\n";
    sGlobal += "  Q7B q7b_this;\n";
    sGlobal += sLoadUI;
    sGlobal += "  return Q7B_IDNIL();\n";
    sGlobal += "}\n";

    sGlobal += "\nQ7B Q7B_GLOBAL_OPENWINDOW(QString uiName)\n";  
    sGlobal += "{\n";
    sGlobal += "  Q7B q7b_this;\n";
    sGlobal += sOpenWindow;
    sGlobal += "  return Q7B_IDNIL();\n";
    sGlobal += "}\n";

    sGlobal += "\nQ7B Q7B_GLOBAL_OPENDIALOG(QString uiName)\n";  
    sGlobal += "{\n";
    sGlobal += "  Q7B q7b_this;\n";
    sGlobal += sOpenDialog;
    sGlobal += "  return Q7B_IDNIL();\n";
    sGlobal += "}\n";

    sGlobal += "\nQ7B Q7B_GLOBAL_OPENTOOLWINDOW(QString uiName)\n";  
    sGlobal += "{\n";
    sGlobal += "  Q7B q7b_this;\n";
    sGlobal += sOpenToolWindow;
    sGlobal += "  return Q7B_IDNIL();\n";
    sGlobal += "}\n";

    sGlobal += "\nbool Q7B_GLOBAL_CLOSEWINDOW(QString uiName)\n";  
    sGlobal += "{\n";
    sGlobal +=  "    if (q7b_ui.contains(uiName)){\n";
    sGlobal +=  "      if (((QWidget *) q7b_ui[uiName]->ref)->close()){\n";
    sGlobal +=  "         ((QWidget *) q7b_ui[uiName]->ref)->deleteLater();\n";
    sGlobal +=  "         q7b_ui[uiName] = Q7B_IDNIL();\n";
    sGlobal +=  "         q7b_ui.remove(uiName);\n";
    sGlobal +=  "      }\n";
    sGlobal +=  "    }\n";
    
    sGlobal += "  return false;\n";
    sGlobal += "}\n";

    sGlobal += sUDFClassCast_c;

  }   

  {
    QMap<QString, _subfunction> SubsFunctions = Parser::Me.SubsFunctions[Parser::getClassName(sFileName)];

    QMapIterator<QString, _subfunction> x(SubsFunctions);

    while (x.hasNext()) {
       x.next();

       QString sProcedure = x.key();

       Me.SubFunction = Parser::Me.SubsFunctions[sClass][sProcedure];

       QString sKind = Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot;
       QString sClass = Parser::getClassName(sFileName);

       if (sKind == "Event"){
         if (Me.SubFunction.sName == "Init"){
           c += sClass + "::" + sClass + "(Q7B _q7b_this";
           h += sClass + "(Q7B _q7b_this";
         } else if (Me.SubFunction.sName == "Finalize"){
           c += sClass + "::" + QString("~") + sClass + "(";
           h += QString("~") + sClass + "(";
         } else {
          c += "void " + sClass + "::" + SLOTESCAPE + Me.SubFunction.sName + "(";
          h += "void " + SLOTESCAPE + Me.SubFunction.sName + "(";
         }
       } else if (sKind == "Signal"){
          c += "void " + sClass + "::" + SLOTESCAPE + Me.SubFunction.sName + "(";
          h += "void " + SLOTESCAPE + Me.SubFunction.sName + "(";
       } else if (sKind == "Function"){
          c += "Q7B " + sClass + "::" + Me.SubFunction.sName + "(";
          h += "Q7B " + Me.SubFunction.sName + "(";          
       } else {
         c += "void " + sClass + "::" + Me.SubFunction.sName + "(";
         h += "void " + Me.SubFunction.sName + "(";
       }         

       for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){
         if (i > 0 || (sKind == "Event" && Me.SubFunction.sName == "Init")){
           c += ", ";
           h += ", ";
         }
		     c += "Q7B " + Me.SubFunction.Arguments.at(i).sName;
		     h += "Q7B " + Me.SubFunction.Arguments.at(i).sName;
       }

       c += ")\n{\n";
       h += ");\n";

       _statements Statements = x.value().Statements;

       if (CONFIG["VM"] == "true"){
         c += "QMap<QString, Q7B> Q7B_args;\n";
         c += "static QMap<QString, Q7B> Q7B_statics;\n";

         for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){
           c += "Q7B_args[\"" + Me.SubFunction.Arguments.at(i).sName + "\"] = " + Me.SubFunction.Arguments.at(i).sName + "; ";
         }
         if (Me.SubFunction.Arguments.size() > 0) c += "\n";
       }

       c += decode_function(Statements, sKind);
       c += "}\n\n";

    }
  }

  QString sVM_CallBridge;
  QString sVM_ClassSingleTone;
  if (sClass == "Global" && CONFIG["VM"] == "true"){ 
    
    QStringList ll = Parser::Me.Classes.keys();
    for (int q = 0; q < ll.size(); q++){
      QString sClass = ll.at(q);

      sVM_ClassSingleTone += "if (sClass == \"" + sClass + "\") return Q7B_" + sClass + "_Object();\n";

      {
        QMap<QString, _subfunction> SubsFunctions = Parser::Me.SubsFunctions[sClass];

        QMapIterator<QString, _subfunction> x(SubsFunctions);

        while (x.hasNext()) {
           x.next();

           QString sProcedure = x.key();

           Me.SubFunction = Parser::Me.SubsFunctions[sClass][sProcedure];

           QString sKind = Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot;
           

           bool bVM_CallBridge = false;

           if (sKind == "Event"){
           } else if (sKind == "Signal"){
           } else if (sKind == "Function"){
              bVM_CallBridge = true;
           } else {
             bVM_CallBridge = true;
           }         

           if (bVM_CallBridge){
             sVM_CallBridge += QString("if (sClass == \"class " + sClass + "\" && sProcedure == \"" + Me.SubFunction.sName + "\"){ %1((" + sClass + " *) theObject)->" + Me.SubFunction.sName + "(").arg(sKind == "Function" ? "return " : "");
           
             for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){
               if (i > 0) sVM_CallBridge += ", ";
               sVM_CallBridge += QString("args.at(%1)").arg(i);
             }

             sVM_CallBridge += "); }\n";
           }
        }
      }


    }
  
  //  sGlobal += "\nQMap<QString, Q7B> *Q7B_VM_me_vars_get(Q7B theObject)\n{\n";
    //sGlobal += "QString s = theObject->type;\n";
    //sGlobal += "QString ss = typeid(MainWindow).name();\n";
   
  //  sGlobal += "if (theObject->type == typeid(MainWindow).name()){ return &((MainWindow *)theObject->ref)->VM_Q7B_me_vars; }\n";
 //   sGlobal += "static QMap<QString, Q7B> d; return &d;\n}\n";
  
  }

  if (sClass == "Global"){
    sGlobal += "\nQ7B VM_Q7B_Call(QString sClass, QString sProcedure, void *theObject, QList<Q7B> args)\n{\n";
    sGlobal += sVM_CallBridge;
    sGlobal += "return Q7B_IDNULL();\n}\n";

    sGlobal += "\nQ7B VM_Q7B_ClassSingleTone(QString sClass)\n{\n";
    sGlobal += sVM_ClassSingleTone;
    sGlobal += "return Q7B_IDNULL();\n}\n";
  }

  {
    QMap<QString, _subfunction> SubsFunctions = Parser::Me.GlobalSubsFunctions;

    QMapIterator<QString, _subfunction> i(SubsFunctions);

    while (i.hasNext()) {
      i.next();

      QString sProcedure = i.key();

      QString sClass = Parser::getClassName(sFileName);
      Me.SubFunction = i.value();

      if (Parser::getClassName(Me.SubFunction.sFileName) == sClass){

         QString sKind = Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot;

         if (sKind == "Function"){
            c += "Q7B " + sClass + "::" + Me.SubFunction.sName + "(";
            h += "static Q7B " + Me.SubFunction.sName + "(";
         } else {
           c += "void " + sClass + "::" + Me.SubFunction.sName + "(";
           h += "static void " + Me.SubFunction.sName + "(";
         }             

         for (int q = 0; q < Me.SubFunction.Arguments.size(); q++){
           if (q > 0 || (sKind == "Event" && Me.SubFunction.sName == "Init")){
             c += ", ";
             h += ", ";
           }
           c += "Q7B " + Me.SubFunction.Arguments.at(q).sName;
           h += "Q7B " + Me.SubFunction.Arguments.at(q).sName;
         }
         c += ")\n{\n";
         h += ");\n";

         _statements Statements = i.value().Statements;

         if (CONFIG["VM"] == "true"){
           c += "QMap<QString, Q7B> Q7B_args;\n";
           c += "static QMap<QString, Q7B> Q7B_statics;\n";

           for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){
             c += "Q7B_args[\"" + Me.SubFunction.Arguments.at(i).sName + "\"] = " + Me.SubFunction.Arguments.at(i).sName + "; ";
           }
          
           if (Me.SubFunction.Arguments.size() > 0) c += "\n";
         }

         c += decode_function(Statements, sKind);
         c += "}\n\n";
      }

    }
  }

  if (sClass == "Global"){ 
     
    QList<_type> Types; 

    Types << Parser::Me.GlobalTypes.values();

    
    
    QStringList ll = Parser::Me.Classes.keys();
    for (int q = 0; q < ll.size(); q++){
      if (Parser::Me.Types.contains(ll.at(q))){
        QString sClassss =  ll.at(q);
        Types << Parser::Me.Types[ll.at(q)].values();

      }
    }
   
    for (int i = 0; i < Types.size(); i++){      

      _type Type = Types.at(i);  

      QString sName = Type.sName;
      if (Type.sPublicPrivateGlobal != "Global") sName = Parser::getClassName(Type.sFileName) + "_" + sName;
      sName = "q7b_type_" + sName + "_init";

      sGlobal += "\nvoid Global::" + sName + "(const Q7B *v)\n{\n";      
      h += "static void " + sName + "(const Q7B *v);\n";

      sGlobal += QString("(*v)->q7b_type = new QVector<Q7B>; (*v)->q7b_type->resize(%1);\n").arg(Type.Names.size());
      //sGlobal += QString("Q7B q7b_type = (*v)->q7b_type; q7b_type->resize(%1);\n").arg(Type.Names.size());

      for (int q = 0; q < Type.Types.size(); q++){
        QString sType = Type.Types.at(q);

        QString sTypeL;
        QString sTypeR;

        if (sType.contains(".")){
          sTypeL = sType.left(sType.indexOf("."));
          sTypeR = sType.mid(sType.indexOf(".") + 1);
        } else {
          sTypeL = sType;
          sTypeR = "";
        }

        _type Type2;

        if (sTypeL == "type3"){
          sTypeL = sTypeL;
        }

        QString sdf = ((QStringList) Parser::Me.Types.keys()).join(" "); 

        bool b = false;
        if (Parser::Me.GlobalTypes.contains(sTypeL)){ 
          Type2 = Parser::Me.GlobalTypes[sTypeL];
        } else if (Parser::Me.Types.contains(sTypeL) && Parser::Me.Types[sTypeL].contains(sTypeR)){ 
          Type2 = Parser::Me.Types[sTypeL][sTypeR];
        
          //Type2 = Parser::Me.Types[sClass][sTypeL];
        } else if (Parser::Me.Types.contains(Parser::getClassName(Type.sFileName)) && Parser::Me.Types[Parser::getClassName(Type.sFileName)].contains(sTypeL)){ 
          Type2 = Parser::Me.Types[Parser::getClassName(Type.sFileName)][sTypeL];
        } else {
          
          {
            b = true;
            Type2 = Type;
          }
          
        }
        
        QString sName = sType;
        if (Type2.sPublicPrivateGlobal != "Global") sName = Parser::getClassName(Type2.sFileName) + "_" + sName;
        sName = "q7b_type_" + sName + "_init";

        _array aa = Type.Arrays.at(q);
        if (b == false || aa.isValid()){
          sGlobal += QString("(*v)->q7b_type->replace(%1, Q7B_ID()); ").arg(q);        

          QString sType3 = Type.Types.at(q);
          _statements Statements;             
          if (Parser::typeArrayInit(Statements, QString("((*v)->q7b_type->at(%1))").arg(q), Type2, sType3, Type.Arrays.at(q))){

          
          //  sadf = sadf;
            sGlobal += decode_function(Statements) + ";\n";
          }
        }
        
      }


      //sGlobal += QString("(*v)->q7b_type = q7b_type;\n").arg(Type.Names.size());
      sGlobal += "}\n";
    }


  }


  h += "private:\nQ7B q7b_this;";

  //if (CONFIG["VM"] == "true"){
    //h += "\npublic:\nQMap<QString, Q7B> VM_Q7B_me_vars;";
  
  



  h += "\n\n";

  h += "};\n";   

  h += sUDFClassCast_h; 

  c += c_globalvariablesconstants;

  if (sClass == "Global"){ 
    c += sGlobal;
  }
h += "\n#endif\n";



    Me.GCC_sInterface[sFileName] = h;
    Me.GCC_sImplementation[sFileName] = c;

    Parser::SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + Parser::getClassName(sFileName) + ".h", Me.GCC_sInterface[sFileName], true);
    Parser::SaveFile(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/" + Parser::getClassName(sFileName) + ".cpp", Me.GCC_sImplementation[sFileName], true);

    return true;
}

void Compiler::addReference(QString sFileName)
{
  if (sFileName.isEmpty()) return;

  QString s = Parser::getClassName(sFileName);

  if (s == "code.NSObject.objb"){
      s=s;
      }
  if (s != Parser::Me.sFileName){
    if (!Me.sReferences[Parser::getClassName(Parser::Me.sFileName)].contains(s)){
      Me.sReferences[Parser::getClassName(Parser::Me.sFileName)] << s;

    }
  }
}

void Compiler::addReferenceToClass(QString sClass)
{
  if (sClass.isEmpty()) return;

  if (sClass == "code.NSObject.objb.h"){
      sClass=sClass;
      }
  if (sClass != Parser::getClassName(Parser::Me.sFileName)){
    if (!Me.sReferences[Parser::getClassName(Parser::Me.sFileName)].contains(sClass)){
      Me.sReferences[Parser::getClassName(Parser::Me.sFileName)] << sClass;
    }
  }
}

QString Compiler::getDeclare(QString sOutletType, QString sSignalName, _subfunction ForSubFunction, QString *sDeclare, QString *sCast, QString *sCode, _subfunction *SubFunction)
{
 *sDeclare = "";
 *sCast = "";
 *sCode = "";

  do {
     if (Parser::Me.classes_declare_events_signals_delegates.contains(sOutletType) && Parser::Me.classes_declare_events_signals_delegates[sOutletType].contains(sSignalName)){
       *sDeclare = Parser::Me.classes_declare_events_signals_delegates[sOutletType][sSignalName];
       *sCast = Parser::Me.classes_declarecast_events_signals_delegates[sOutletType][sSignalName];
       *sCode = Parser::Me.classes_declarecode_events_signals_delegates[sOutletType][sSignalName];
     } else if (Parser::Me.controls_declare_events_signals_delegates.contains(sOutletType) && Parser::Me.controls_declare_events_signals_delegates[sOutletType].contains(sSignalName)){
       *sDeclare = Parser::Me.controls_declare_events_signals_delegates[sOutletType][sSignalName];
       *sCast = Parser::Me.controls_declarecast_events_signals_delegates[sOutletType][sSignalName];
       *sCode = Parser::Me.controls_declarecode_events_signals_delegates[sOutletType][sSignalName];
     } else if (Parser::Me.objects_declare_events_signals_delegates.contains(sOutletType) && Parser::Me.objects_declare_events_signals_delegates[sOutletType].contains(sSignalName)){
       *sDeclare = Parser::Me.objects_declare_events_signals_delegates[sOutletType][sSignalName];
       *sCast = Parser::Me.objects_declarecast_events_signals_delegates[sOutletType][sSignalName];
       *sCode = Parser::Me.objects_declarecode_events_signals_delegates[sOutletType][sSignalName];
     } else {
       if (Parser::Me.DeclareSignals.contains(sOutletType) && Parser::Me.DeclareSignals[sOutletType].contains(sSignalName)){
         *sDeclare = Parser::Me.DeclareSignals[sOutletType][sSignalName].sDeclareNative;
       } else if (Parser::Me.DeclareEvents.contains(sOutletType) && Parser::Me.DeclareEvents[sOutletType].contains(sSignalName)){
         *sDeclare = Parser::Me.DeclareEvents[sOutletType][sSignalName].sDeclareNative;
       } else if (Parser::Me.DeclareDelegates.contains(sOutletType) && Parser::Me.DeclareDelegates[sOutletType].contains(sSignalName)){
         *sDeclare = Parser::Me.DeclareDelegates[sOutletType][sSignalName].sDeclareNative;
       }
     }


     if (!sDeclare->isEmpty()){
         *SubFunction = Parser::Me.DeclareSubsFunctionsSignalsEventsDelegates[sOutletType][sSignalName];
         return sOutletType;
     }
     if (Parser::Me.classes.contains(sOutletType)){
       sOutletType = Parser::Me.classes[sOutletType]; 
     } else if (Parser::Me.controls.contains(sOutletType)){
       sOutletType = Parser::Me.controls[sOutletType]; 
     } else if (Parser::Me.objects.contains(sOutletType)){
       sOutletType = Parser::Me.objects[sOutletType]; 
     } else if (Parser::Me.Classes.contains(sOutletType)){
       sOutletType = Parser::Me.Classes[sOutletType]; 
     } else {
       break;
     }

 } while (!sOutletType.isEmpty());


    
    QString sKey = sSignalName + QString().fill(':', ForSubFunction.Arguments.count());
    if (Parser::Me.DeclareDelegatesList.contains(sKey)){
        *sDeclare = Parser::Me.DeclareDelegatesList[sKey].sDeclareNative;
        *SubFunction = Parser::Me.DeclareDelegatesList[sKey];
        return "";
    }


    return "";

}







#include "_Q7BCompiler.h"


bool Parser::projectContainsClass(QString s)
{
    for (int i = 0; Me.bError == false && i < Me.files.size(); i++){
      if (Me.files.at(i) == s) return true;
    }
    return false;
}

void Parser::error(QString ss, bool bDetailedInfo)
{
  QString s = ss;
  if (Me.bError) return;

  QString token_2 = getToken(-3);
  QString token_1 = getToken(-2);
  QString token0 = getToken(-1);
  QString token1 = getToken();
  QString token2 = getToken(+1);

  
  if (!Me.sFileName.isEmpty()) QFile::remove(CONFIG["PROJECTPATH"] + "/" + CONFIG["BUILDDIR"] + "/Scanner/" + Me.sFileName);

  
  s = "syntax error or parser error " + (s.isEmpty() ? "" : (" - " + s));

  s = "Q7Basic: " + s;

  if (token_1.mid(1) == "."){
    s += " " + QString("near '" + format(token_2) + " " + format(token_1) + " " + format(token0) + " " + format(token1) + " " + format(token2) + "'").simplified();
  } else {
    QString fsd = format(token0) + format(token1) + format(token2);
    if (!fsd.simplified().isEmpty()) s += " near '" + fsd + "'";
  }
  if (bDetailedInfo && !Me.sFileName.isEmpty()){
    s += QString(" in line %1 in file %2\n").arg(Me.nLine).arg(Me.sFileName);
  }


//  Parser::SaveFile("C:\\Users\\Bernd\\Desktop\\debug.txt", s, true);


  Write_To_stderr(s);

  Me.bError = true;
}

void Parser::CopyOverwrite(QString s, QString s2)
{
    if (QFile::exists(s2)) QFile::remove(s2);
    QFile::copy(s, s2);
}

QString Parser::format(QString s)
{
  if (s.left(1) == "S"){
     return "\"" + s.mid(1).replace("\n", " ") + "\"";
  }
  if (s.left(1) == "C"){
     return " '" + s.mid(1).replace("\n", " ");
  }
  return s.mid(1).replace("\n", " ");
}

void Parser::Write_To_stdout(const QString & s)
{
  QFile file;
  if (file.open(stdout, QIODevice::WriteOnly)){
    file.write(s.toLocal8Bit());
    file.flush();
  }
}

void Parser::Write_To_stderr(const QString & s)
{
  QFile file;
  if (file.open(stderr, QIODevice::WriteOnly)){    
    file.write(s.toLocal8Bit());
    file.flush();
  }
}

QString Parser::getPath(const QString & s)
{
  int n = s.lastIndexOf("/");
  QString sName = s;
  if (n == -1) n = s.lastIndexOf("\\");
  if (n != -1) sName = s.left(n + 1);
  return sName;
}

QString Parser::getFileName(const QString & s)
{
  int n = s.lastIndexOf("/");
  QString sName = s;
  if (n == -1) n = s.lastIndexOf("\\");
  if (n != -1) sName = s.mid(n + 1);
  return sName;
}

QString Parser::getBaseName(const QString & ss)
{
  QString s = ss;
  int n = s.lastIndexOf("/");
  if (n == -1) n = s.lastIndexOf("\\");
  if (n != -1) s = s.mid(n + 1);
  n = s.lastIndexOf(".");
  if (n != -1) s = s.left(n);
  return s;
}

QString Parser::getExtension(const QString & ss)
{
  QString s = ss;
  int n = s.lastIndexOf(".");  
  if (n != -1) s = s.mid(n + 1);
  return s;
}

QString Parser::getSignalOutletName(const QString & ss)
{
  QString s;


  if (ss.startsWith("on_")){
    int n = ss.lastIndexOf("_");
    if (n >= 0){
      s = ss.mid(3, n - 3);
    }
  }


  return s;
}

QString Parser::getSignalSignalName(const QString & ss)
{
  QString s;



  if (ss.count("_") < 2) return "";

  int n = ss.lastIndexOf("_");
  if (n >= 0){
    s = ss.mid(n + 1);
  }

  
  return s;
}

QString Parser::getFileNameForClass(const QString & s)
{
  return Me.sFileNameForClass[s];
}

QString Parser::getClassName(const QString & ss)
{
  if (CONFIG["SINGLEFILEPROJECT"] == "true"){
    return "Global";
  }

  QString s = ss;
  int n = s.lastIndexOf(".");  
  if (n != -1){
    s = s.left(n);
  }  
  n = s.lastIndexOf(".");  
  if (n != -1){
    s = s.left(n);
  }

  return s;
}

QString Parser::getSuperClassName(const QString & ss)
{

  if (CONFIG["SINGLEFILEPROJECT"] == "true"){
    return "QObject";
  }


  QString s = ss;
  int n = s.lastIndexOf(".");  
  if (n != -1){
    s = s.left(n);
  }  
  n = s.lastIndexOf(".");  
  if (n != -1){
    s = s.mid(n + 1);
  }


  return s;


}

QString Parser::getSuperClassNameOfType(const QString & sClass)
{
  if (Me.classes.contains(sClass)) return Me.classes[sClass];
  if (Me.controls.contains(sClass)) return Me.controls[sClass];
  if (Me.objects.contains(sClass)) return Me.objects[sClass];

  if (Me.Classes.contains(sClass)) return Me.Classes[sClass];

  return "";
}

QString Parser::LoadFile(const QString & sFile)
{
  QString s;
  QString sFile2=sFile;
#ifndef Q_OS_WIN32
  sFile2 = sFile2.replace("\\", "/");
#endif
 QFile f(sFile2);
  if (!f.open(QIODevice::ReadOnly)){
    error(QString("Could not read from %1").arg(sFile));
  } else {
    QTextStream t(&f);
    
    t.setCodec("UTF-8");
    t.setAutoDetectUnicode(true);
    t.setGenerateByteOrderMark(true);

    s = t.readAll();
    s = s.replace("\r", "");
    f.close();
  }
  return s;
}

QStringList Parser::LoadFileAsStringList(const QString & sFile)
{
  QStringList sl;
  QString sFile2=sFile;
#ifndef Q_OS_WIN32
  sFile2 = sFile2.replace("\\", "/");
#endif
 QFile f(sFile2);
  if (!f.open(QIODevice::ReadOnly)){
    error(QString("Could not read from %1").arg(sFile));
  } else {
    QDataStream t(&f);

    t >> sl;
    f.close();
  }
  return sl;
}

void Parser::SaveFile(const QString & sFile, const QString & s, bool bUTF8)
{

   QString sFile2=sFile;
#ifndef Q_OS_WIN32
   sFile2 = sFile2.replace("\\", "/");
#endif
  QFile f(sFile2);
  if (!f.open(QIODevice::WriteOnly)){
    error(QString("Could not write to %1").arg(sFile));
  } else {
    QTextStream t(&f);
    
    if (bUTF8){
      t.setCodec("UTF-8");
      t.setAutoDetectUnicode(true);
      t.setGenerateByteOrderMark(true);
    }

    t << s;
    f.close();    
  }
}

void Parser::SaveFileAsStringList(const QString & sFile, const QStringList & sl)
{
    QString sFile2=sFile;
 #ifndef Q_OS_WIN32
    sFile2 = sFile2.replace("\\", "/");
 #endif
   QFile f(sFile2);
  if (!f.open(QIODevice::WriteOnly)){
    error(QString("Could not write to %1").arg(sFile));
  } else {
    QDataStream t(&f);

    t << sl;
    f.close();
    
  }
}



bool Parser::shellCopy(QString a, QString b)
  {
    return false;
//return QProcess::execute("cp", QString("-r " + a + " " + b).split(" "));
 }


QMap<QString, QString> links;
bool Parser::copyDir(const QString& from, const QString& to, bool bCopyFilesEvenExists, QStringList ignoreFilter, bool bFirst, QString ignoreFilterEndsWith, QString ignoreFilterEndsWith2)
{
  if (bFirst){
      links.clear();
  }

  QDir d;
  d.mkpath(to);

 // Write_To_stdout(to + "\n");

  QDir thisDir( from );	
  QFileInfoList files = thisDir.entryInfoList();

  if ( files.size() ) {

    QFileInfo fi;
    for (int i = 0; i < files.size(); ++i) {
      fi = files.at(i);

      QString ss = fi.absoluteFilePath();

///       Write_To_stdout(ss + "\n");

		  if (fi.fileName() == "." || fi.fileName() == ".."){
		      ; 
                  } else if ( fi.isSymLink()){

                      if (ignoreFilter.contains(fi.fileName())) continue;
                      if (ignoreFilter.contains("." + fi.suffix())) continue;
                      
                      if (!ignoreFilterEndsWith.isEmpty() && fi.fileName().endsWith(ignoreFilterEndsWith)) continue;
                      if (!ignoreFilterEndsWith2.isEmpty() && fi.fileName().endsWith(ignoreFilterEndsWith2)) continue;

                      QString sLink = to + fi.absoluteFilePath().mid(from.length());
                      QString sTarget = fi.symLinkTarget();

                      sTarget = to + sTarget.mid(from.length());

                      links[sTarget] = sLink;


                      
		  } else if ( fi.isDir() ){

                      QString asf = fi.fileName();
          if (ignoreFilter.contains(fi.fileName())) continue;
          if (ignoreFilter.contains("." + fi.suffix())) continue;

          if (!ignoreFilterEndsWith.isEmpty() && fi.fileName().endsWith(ignoreFilterEndsWith)) continue;
          if (!ignoreFilterEndsWith2.isEmpty() && fi.fileName().endsWith(ignoreFilterEndsWith2)) continue;

        if (!copyDir(fi.absoluteFilePath(), to + "/" + fi.fileName(), bCopyFilesEvenExists, ignoreFilter, false, ignoreFilterEndsWith, ignoreFilterEndsWith2)) return false;

      } else {

        if (ignoreFilter.contains(fi.fileName())) continue;
        if (ignoreFilter.contains("." + fi.suffix())) continue;

        if (!ignoreFilterEndsWith.isEmpty() && fi.fileName().endsWith(ignoreFilterEndsWith)) continue;
        if (!ignoreFilterEndsWith2.isEmpty() && fi.fileName().endsWith(ignoreFilterEndsWith2)) continue;

        if (bCopyFilesEvenExists == true || (!QFile::exists(to + "/" + fi.fileName()))){
          copyIfNeeded(fi.absoluteFilePath(), to + "/" + fi.fileName());
        }

      }		    
	}
  
  }    

  if (bFirst){ 
      QMapIterator<QString, QString> i(links);
      while (i.hasNext()) {
          i.next();

          QFile::link(i.key(), i.value());
      }
  }
  return true;
}


void Parser::copyResourceFolder(QString & sResourceFiles, QString sPath, QString sPathTo, QString sPrefix)
{
  if (QFile::exists(sPath)){
    QDir("/").mkpath(sPathTo);

    QDir dir(sPath);
    QStringList ll = dir.entryList();

    for (int i = 0; i < ll.size(); i++){       
      if (QFileInfo(sPath + "/" + ll.at(i)).isDir()){
        if (ll.at(i) != "." && ll.at(i) != ".."){
          copyResourceFolder(sResourceFiles, sPath + "/" + ll.at(i), sPathTo + "/" + ll.at(i), ll.at(i) + "/");
        }
      } else {
        copyIfNeeded(sPath + "/" + ll.at(i), sPathTo + "/" +  ll.at(i));
        sResourceFiles += QString("<file alias=\"" + sPrefix + ll.at(i) + "\">../Resources/") + sPrefix + ll.at(i) + "</file>\n";
      }
    }
  }
}

bool Parser::copyIfNeeded(QString s, QString s2, bool bContentOnly)
{
   bool bCopy = false;

   
   if (s2.endsWith("windows_application_icon.rc")){

     QFile f(s);
     if (!f.open(QIODevice::ReadOnly)){
       return false;
     } else {
       QByteArray ba = f.readAll();
       QFile f2(s2);
     
       if (!f2.open(QIODevice::Truncate | QIODevice::WriteOnly)){
         return false;
       } else {
         return f2.write(ba) == ba.size();
       }

     }
     return false;
   }

  if (QFile::exists(s2)){

    QFileInfo fi(s);
    QFileInfo fiCached(s2);

    bool b1 = false;
    bool b2 = false;
    bool b3 = false;

    if (bContentOnly){
      if (s.endsWith(".pro")){
        QString a = LoadFile(s);
        QString b = LoadFile(s2);

        QString sSearch = "#################";
        int n = a.lastIndexOf(sSearch);
        if (n >= 0) a = a.mid(n + sSearch.length());
        n = b.lastIndexOf(sSearch);
        if (n >= 0) b = b.mid(n + sSearch.length());
        
        bCopy = a != b;
      
      } else {
        bCopy = LoadFile(s) != LoadFile(s2);
      }

    } else {
      QString ss = fi.lastModified().toString();
      QString sss = fiCached.lastModified().toString();
      if ((b1 = (fi.lastModified() == fiCached.lastModified())) && (b2 = (fi.size() == fiCached.size())) && (bContentOnly && (b3 = (LoadFile(s) == LoadFile(s2))))){
      } else {
        bCopy = true;
    }
    }
  } else {
      bCopy = true;
  }

  if (bCopy){
   if (s.toLower() != s2.toLower()){
     
//     Write_To_stdout("copyIfNeeded\n");
     QFile f(s2);
     f.remove();
     QFile::copy(s, s2);     
  //  Write_To_stdout("            copyIfNeeded\n");

   }
  }

  return bCopy;
} 

bool Parser::removeDirectory(QDir aDir, bool bFollowLinks)
{
    bool has_err = false;
    if (aDir.exists())
    {
      QFileInfoList entries = aDir.entryInfoList(QDir::NoDotAndDotDot | QDir::Dirs | QDir::Files);
      int count = entries.size();
      for (int idx = 0; ((idx < count) && (true != has_err)); idx++)
      {
        QFileInfo entryInfo = entries[idx];
        QString path = entryInfo.absoluteFilePath();
      //  QMessageBox::information(0, "RemoveDirectory", path+ "\n" + aDir.absolutePath());
        if (entryInfo.isDir())
        {
          has_err = removeDirectory(QDir(path), bFollowLinks);
         // QMessageBox::information(0, "1 err", path);
        }
        else if (entryInfo.isSymLink())
        {
          if (QFileInfo(entryInfo.symLinkTarget()).isDir() && entryInfo.symLinkTarget().startsWith(aDir.absolutePath())){
            has_err = removeDirectory(QDir(path), bFollowLinks);
         //   QMessageBox::information(0, "1 err", path);
          }
          else {
            QFile file(path);
            if (!file.remove()){
              has_err = true;
//              QMessageBox::information(0, "2 err", path);
            }
          }
        }
          else
        {

          //if (path.endsWith("/plugins")) QMessageBox::information(0, "RemoveDirectory", "1"+path);

          QFile file(path);
          if (!file.remove()){
          //  QMessageBox::information(0, "QFile err", path);
            has_err = true;
          }
          //if (QFile::exists(path))QMessageBox::information(0, "RemoveDirectory", "1"+path);


        }
      }

      if (!aDir.rmdir(aDir.absolutePath())){
         // QMessageBox::information(0, "aDir err", aDir.absolutePath());

        has_err = true;
      }

      //QMessageBox::information(0, "RemoveDirectory", "2"+aDir.absolutePath());

    }
   
     // QMessageBox::information(0, "___err", aDir.absolutePath ());
   

    return(has_err);
}





#include "_Q7BCompiler.h"



  


   






int main(int argc, char *argv[])
{
    

 

//  QCoreApplication app(argc, argv); 


//  (new myTest99())->raiseSignal();
 
 // q7b_type_myClass_type2_init(&v);

 

  return StartMeUp(argc, argv);
}

bool Q7B_Compiler_ConvertDeclareType(QString *sCast)
{
  
  if (*sCast == "FormClass"){ *sCast = "CFORMCLASS"; return true; }
  if (*sCast == "PhononSeekSlider"){ *sCast = "CPHONONSEEKSLIDER"; return true; }
  if (*sCast == "PhononVideoPlayer"){ *sCast = "CPHONONVIDEOPLAYER"; return true; }
  if (*sCast == "PhononVolumeSlider"){ *sCast = "CPHONONVOLUMESLIDER"; return true; }
  if (*sCast == "QAbstractButton"){ *sCast = "CQABSTRACTBUTTON"; return true; }
  if (*sCast == "QAbstractItemModel"){ *sCast = "CQABSTRACTITEMMODEL"; return true; }
  if (*sCast == "QAbstractItemView"){ *sCast = "CQABSTRACTITEMVIEW"; return true; }
  if (*sCast == "QAbstractPrintDialog"){ *sCast = "CQABSTRACTPRINTDIALOG"; return true; }
  if (*sCast == "QAbstractScrollArea"){ *sCast = "CQABSTRACTSCROLLAREA"; return true; }
  if (*sCast == "QAbstractSlider"){ *sCast = "CQABSTRACTSLIDER"; return true; }
  if (*sCast == "QAbstractSpinBox"){ *sCast = "CQABSTRACTSPINBOX"; return true; }
  if (*sCast == "QAbstractTextDocumentLayout"){ *sCast = "CQABSTRACTTEXTDOCUMENTLAYOUT"; return true; }
  if (*sCast == "QAccessibleEvent"){ *sCast = "CQACCESSIBLEEVENT"; return true; }
  if (*sCast == "QAction"){ *sCast = "CQACTION"; return true; }
  if (*sCast == "QActionEvent"){ *sCast = "CQACTIONEVENT"; return true; }
  if (*sCast == "QActionGroup"){ *sCast = "CQACTIONGROUP"; return true; }
  if (*sCast == "QApplication"){ *sCast = "CQAPPLICATION"; return true; }
  if (*sCast == "QBitmap"){ *sCast = "CQBITMAP"; return true; }
  if (*sCast == "QBoxLayout"){ *sCast = "CQBOXLAYOUT"; return true; }
  if (*sCast == "QBrush"){ *sCast = "CQBRUSH"; return true; }
  if (*sCast == "QButtonGroup"){ *sCast = "CQBUTTONGROUP"; return true; }
  if (*sCast == "QByteArray"){ *sCast = "CQBYTEARRAY"; return true; }
  if (*sCast == "QCalendarWidget"){ *sCast = "CQCALENDARWIDGET"; return true; }
  if (*sCast == "QChar"){ *sCast = "CQCHAR"; return true; }
  if (*sCast == "QCheckBox"){ *sCast = "CQCHECKBOX"; return true; }
  if (*sCast == "QChildEvent"){ *sCast = "CQCHILDEVENT"; return true; }
  if (*sCast == "QClipboard"){ *sCast = "CQCLIPBOARD"; return true; }
  if (*sCast == "QCloseEvent"){ *sCast = "CQCLOSEEVENT"; return true; }
  if (*sCast == "QColor"){ *sCast = "CQCOLOR"; return true; }
  if (*sCast == "QColumnView"){ *sCast = "CQCOLUMNVIEW"; return true; }
  if (*sCast == "QComboBox"){ *sCast = "CQCOMBOBOX"; return true; }
  if (*sCast == "QCommandLinkButton"){ *sCast = "CQCOMMANDLINKBUTTON"; return true; }
  if (*sCast == "QCompleter"){ *sCast = "CQCOMPLETER"; return true; }
  if (*sCast == "QContextMenuEvent"){ *sCast = "CQCONTEXTMENUEVENT"; return true; }
  if (*sCast == "QCoreApplication"){ *sCast = "CQCOREAPPLICATION"; return true; }
  if (*sCast == "QCursor"){ *sCast = "CQCURSOR"; return true; }
  if (*sCast == "QDate"){ *sCast = "CQDATE"; return true; }
  if (*sCast == "QDateEdit"){ *sCast = "CQDATEEDIT"; return true; }
  if (*sCast == "QDateTime"){ *sCast = "CQDATETIME"; return true; }
  if (*sCast == "QDateTimeEdit"){ *sCast = "CQDATETIMEEDIT"; return true; }
  if (*sCast == "QDeclarativeContext"){ *sCast = "CQDECLARATIVECONTEXT"; return true; }
  if (*sCast == "QDeclarativeView"){ *sCast = "CQDECLARATIVEVIEW"; return true; }
  if (*sCast == "QDial"){ *sCast = "CQDIAL"; return true; }
  if (*sCast == "QDialog"){ *sCast = "CQDIALOG"; return true; }
  if (*sCast == "QDialogButtonBox"){ *sCast = "CQDIALOGBUTTONBOX"; return true; }
  if (*sCast == "QDir"){ *sCast = "CQDIR"; return true; }
  if (*sCast == "QDockWidget"){ *sCast = "CQDOCKWIDGET"; return true; }
  if (*sCast == "QDoubleSpinBox"){ *sCast = "CQDOUBLESPINBOX"; return true; }
  if (*sCast == "QDrag"){ *sCast = "CQDRAG"; return true; }
  if (*sCast == "QDragLeaveEvent"){ *sCast = "CQDRAGLEAVEEVENT"; return true; }
  if (*sCast == "QDropEvent"){ *sCast = "CQDROPEVENT"; return true; }
  if (*sCast == "QDynamicPropertyChangeEvent"){ *sCast = "CQDYNAMICPROPERTYCHANGEEVENT"; return true; }
  if (*sCast == "QElapsedTimer"){ *sCast = "CQELAPSEDTIMER"; return true; }
  if (*sCast == "QEvent"){ *sCast = "CQEVENT"; return true; }
  if (*sCast == "QFileInfo"){ *sCast = "CQFILEINFO"; return true; }
  if (*sCast == "QFileInfoList"){ *sCast = "CQFILEINFOLIST"; return true; }
  if (*sCast == "QFileOpenEvent"){ *sCast = "CQFILEOPENEVENT"; return true; }
  if (*sCast == "QFileSystemWatcher"){ *sCast = "CQFILESYSTEMWATCHER"; return true; }
  if (*sCast == "QFocusEvent"){ *sCast = "CQFOCUSEVENT"; return true; }
  if (*sCast == "QFont"){ *sCast = "CQFONT"; return true; }
  if (*sCast == "QFontComboBox"){ *sCast = "CQFONTCOMBOBOX"; return true; }
  if (*sCast == "QFontDatabase"){ *sCast = "CQFONTDATABASE"; return true; }
  if (*sCast == "QFontInfo"){ *sCast = "CQFONTINFO"; return true; }
  if (*sCast == "QFontMetrics"){ *sCast = "CQFONTMETRICS"; return true; }
  if (*sCast == "QFormLayout"){ *sCast = "CQFORMLAYOUT"; return true; }
  if (*sCast == "QFrame"){ *sCast = "CQFRAME"; return true; }
  if (*sCast == "QFtp"){ *sCast = "CQFTP"; return true; }
  if (*sCast == "QGraphicsSceneEvent"){ *sCast = "CQGRAPHICSSCENEEVENT"; return true; }
  if (*sCast == "QGraphicsView"){ *sCast = "CQGRAPHICSVIEW"; return true; }
  if (*sCast == "QGridLayout"){ *sCast = "CQGRIDLAYOUT"; return true; }
  if (*sCast == "QGroupBox"){ *sCast = "CQGROUPBOX"; return true; }
  if (*sCast == "QHBoxLayout"){ *sCast = "CQHBOXLAYOUT"; return true; }
  if (*sCast == "QHeaderView"){ *sCast = "CQHEADERVIEW"; return true; }
  if (*sCast == "QHelpEvent"){ *sCast = "CQHELPEVENT"; return true; }
  if (*sCast == "QHideEvent"){ *sCast = "CQHIDEEVENT"; return true; }
  if (*sCast == "QHostAddress"){ *sCast = "CQHOSTADDRESS"; return true; }
  if (*sCast == "QHostInfo"){ *sCast = "CQHOSTINFO"; return true; }
  if (*sCast == "QHoverEvent"){ *sCast = "CQHOVEREVENT"; return true; }
  if (*sCast == "QIcon"){ *sCast = "CQICON"; return true; }
  if (*sCast == "QIconDragEvent"){ *sCast = "CQICONDRAGEVENT"; return true; }
  if (*sCast == "QImage"){ *sCast = "CQIMAGE"; return true; }
  if (*sCast == "QInputDialog"){ *sCast = "CQINPUTDIALOG"; return true; }
  if (*sCast == "QInputEvent"){ *sCast = "CQINPUTEVENT"; return true; }
  if (*sCast == "QInputMethodEvent"){ *sCast = "CQINPUTMETHODEVENT"; return true; }
  if (*sCast == "QIntValidator"){ *sCast = "CQINTVALIDATOR"; return true; }
  if (*sCast == "QItemSelectionModel"){ *sCast = "CQITEMSELECTIONMODEL"; return true; }
  if (*sCast == "QKeySequence"){ *sCast = "CQKEYSEQUENCE"; return true; }
  if (*sCast == "QLCDNumber"){ *sCast = "CQLCDNUMBER"; return true; }
  if (*sCast == "QLabel"){ *sCast = "CQLABEL"; return true; }
  if (*sCast == "QLayout"){ *sCast = "CQLAYOUT"; return true; }
  if (*sCast == "QLayoutItem"){ *sCast = "CQLAYOUTITEM"; return true; }
  if (*sCast == "QLine"){ *sCast = "CQLINE"; return true; }
  if (*sCast == "QLineEdit"){ *sCast = "CQLINEEDIT"; return true; }
  if (*sCast == "QListQStringList"){ *sCast = "CQLISTQSTRINGLIST"; return true; }
  if (*sCast == "QListView"){ *sCast = "CQLISTVIEW"; return true; }
  if (*sCast == "QListWidget"){ *sCast = "CQLISTWIDGET"; return true; }
  if (*sCast == "QListWidgetItem"){ *sCast = "CQLISTWIDGETITEM"; return true; }
  if (*sCast == "QLocalServer"){ *sCast = "CQLOCALSERVER"; return true; }
  if (*sCast == "QLocalSocket"){ *sCast = "CQLOCALSOCKET"; return true; }
  if (*sCast == "QLocale"){ *sCast = "CQLOCALE"; return true; }
  if (*sCast == "QMainWindow"){ *sCast = "CQMAINWINDOW"; return true; }
  if (*sCast == "QMargins"){ *sCast = "CQMARGINS"; return true; }
  if (*sCast == "QMatrix"){ *sCast = "CQMATRIX"; return true; }
  if (*sCast == "QMdiArea"){ *sCast = "CQMDIAREA"; return true; }
  if (*sCast == "QMdiSubWindow"){ *sCast = "CQMDISUBWINDOW"; return true; }
  if (*sCast == "QMenu"){ *sCast = "CQMENU"; return true; }
  if (*sCast == "QMenuBar"){ *sCast = "CQMENUBAR"; return true; }
  if (*sCast == "QMimeData"){ *sCast = "CQMIMEDATA"; return true; }
  if (*sCast == "QModelIndex"){ *sCast = "CQMODELINDEX"; return true; }
  if (*sCast == "QMoveEvent"){ *sCast = "CQMOVEEVENT"; return true; }
  if (*sCast == "QMovie"){ *sCast = "CQMOVIE"; return true; }
  if (*sCast == "QNetworkRequest"){ *sCast = "CQNETWORKREQUEST"; return true; }
  if (*sCast == "QNetworkSession"){ *sCast = "CQNETWORKSESSION"; return true; }
  if (*sCast == "QObject"){ *sCast = "CQOBJECT"; return true; }
  if (*sCast == "QPaintEvent"){ *sCast = "CQPAINTEVENT"; return true; }
  if (*sCast == "QPainter"){ *sCast = "CQPAINTER"; return true; }
  if (*sCast == "QPalette"){ *sCast = "CQPALETTE"; return true; }
  if (*sCast == "QPen"){ *sCast = "CQPEN"; return true; }
  if (*sCast == "QPicture"){ *sCast = "CQPICTURE"; return true; }
  if (*sCast == "QPixmap"){ *sCast = "CQPIXMAP"; return true; }
  if (*sCast == "QPlainTextEdit"){ *sCast = "CQPLAINTEXTEDIT"; return true; }
  if (*sCast == "QPoint"){ *sCast = "CQPOINT"; return true; }
  if (*sCast == "QPolygon"){ *sCast = "CQPOLYGON"; return true; }
  if (*sCast == "QPrintDialog"){ *sCast = "CQPRINTDIALOG"; return true; }
  if (*sCast == "QPrintPreviewDialog"){ *sCast = "CQPRINTPREVIEWDIALOG"; return true; }
  if (*sCast == "QPrintPreviewWidget"){ *sCast = "CQPRINTPREVIEWWIDGET"; return true; }
  if (*sCast == "QPrinter"){ *sCast = "CQPRINTER"; return true; }
  if (*sCast == "QPrinterInfo"){ *sCast = "CQPRINTERINFO"; return true; }
  if (*sCast == "QProcess"){ *sCast = "CQPROCESS"; return true; }
  if (*sCast == "QProcessEnvironment"){ *sCast = "CQPROCESSENVIRONMENT"; return true; }
  if (*sCast == "QProgressBar"){ *sCast = "CQPROGRESSBAR"; return true; }
  if (*sCast == "QProgressDialog"){ *sCast = "CQPROGRESSDIALOG"; return true; }
  if (*sCast == "QPushButton"){ *sCast = "CQPUSHBUTTON"; return true; }
  if (*sCast == "QRadioButton"){ *sCast = "CQRADIOBUTTON"; return true; }
  if (*sCast == "QRect"){ *sCast = "CQRECT"; return true; }
  if (*sCast == "QRegExp"){ *sCast = "CQREGEXP"; return true; }
  if (*sCast == "QRegExpValidator"){ *sCast = "CQREGEXPVALIDATOR"; return true; }
  if (*sCast == "QRegion"){ *sCast = "CQREGION"; return true; }
  if (*sCast == "QResizeEvent"){ *sCast = "CQRESIZEEVENT"; return true; }
  if (*sCast == "QResource"){ *sCast = "CQRESOURCE"; return true; }
  if (*sCast == "QRgb"){ *sCast = "CQRGB"; return true; }
  if (*sCast == "QRubberBand"){ *sCast = "CQRUBBERBAND"; return true; }
  if (*sCast == "QScrollArea"){ *sCast = "CQSCROLLAREA"; return true; }
  if (*sCast == "QScrollBar"){ *sCast = "CQSCROLLBAR"; return true; }
  if (*sCast == "QSessionManager"){ *sCast = "CQSESSIONMANAGER"; return true; }
  if (*sCast == "QShortcutEvent"){ *sCast = "CQSHORTCUTEVENT"; return true; }
  if (*sCast == "QShowEvent"){ *sCast = "CQSHOWEVENT"; return true; }
  if (*sCast == "QSignalMapper"){ *sCast = "CQSIGNALMAPPER"; return true; }
  if (*sCast == "QSize"){ *sCast = "CQSIZE"; return true; }
  if (*sCast == "QSizeF"){ *sCast = "CQSIZEF"; return true; }
  if (*sCast == "QSizeGrip"){ *sCast = "CQSIZEGRIP"; return true; }
  if (*sCast == "QSizePolicy"){ *sCast = "CQSIZEPOLICY"; return true; }
  if (*sCast == "QSlider"){ *sCast = "CQSLIDER"; return true; }
  if (*sCast == "QSound"){ *sCast = "CQSOUND"; return true; }
  if (*sCast == "QSpinBox"){ *sCast = "CQSPINBOX"; return true; }
  if (*sCast == "QSplashScreen"){ *sCast = "CQSPLASHSCREEN"; return true; }
  if (*sCast == "QSplitter"){ *sCast = "CQSPLITTER"; return true; }
  if (*sCast == "QSplitterHandle"){ *sCast = "CQSPLITTERHANDLE"; return true; }
  if (*sCast == "QStackedLayout"){ *sCast = "CQSTACKEDLAYOUT"; return true; }
  if (*sCast == "QStackedWidget"){ *sCast = "CQSTACKEDWIDGET"; return true; }
  if (*sCast == "QStatusBar"){ *sCast = "CQSTATUSBAR"; return true; }
  if (*sCast == "QStatusTipEvent"){ *sCast = "CQSTATUSTIPEVENT"; return true; }
  if (*sCast == "QString"){ *sCast = "CQSTRING"; return true; }
  if (*sCast == "QStringList"){ *sCast = "CQSTRINGLIST"; return true; }
  if (*sCast == "QSvgWidget"){ *sCast = "CQSVGWIDGET"; return true; }
  if (*sCast == "QSyntaxHighlighter"){ *sCast = "CQSYNTAXHIGHLIGHTER"; return true; }
  if (*sCast == "QSystemLocale"){ *sCast = "CQSYSTEMLOCALE"; return true; }
  if (*sCast == "QSystemTrayIcon"){ *sCast = "CQSYSTEMTRAYICON"; return true; }
  if (*sCast == "QTabBar"){ *sCast = "CQTABBAR"; return true; }
  if (*sCast == "QTabWidget"){ *sCast = "CQTABWIDGET"; return true; }
  if (*sCast == "QTableView"){ *sCast = "CQTABLEVIEW"; return true; }
  if (*sCast == "QTableWidget"){ *sCast = "CQTABLEWIDGET"; return true; }
  if (*sCast == "QTableWidgetItem"){ *sCast = "CQTABLEWIDGETITEM"; return true; }
  if (*sCast == "QTextBlock"){ *sCast = "CQTEXTBLOCK"; return true; }
  if (*sCast == "QTextBlockFormat"){ *sCast = "CQTEXTBLOCKFORMAT"; return true; }
  if (*sCast == "QTextBrowser"){ *sCast = "CQTEXTBROWSER"; return true; }
  if (*sCast == "QTextCharFormat"){ *sCast = "CQTEXTCHARFORMAT"; return true; }
  if (*sCast == "QTextCursor"){ *sCast = "CQTEXTCURSOR"; return true; }
  if (*sCast == "QTextDocument"){ *sCast = "CQTEXTDOCUMENT"; return true; }
  if (*sCast == "QTextDocumentFragment"){ *sCast = "CQTEXTDOCUMENTFRAGMENT"; return true; }
  if (*sCast == "QTextEdit"){ *sCast = "CQTEXTEDIT"; return true; }
  if (*sCast == "QTextFormat"){ *sCast = "CQTEXTFORMAT"; return true; }
  if (*sCast == "QTextFrameFormat"){ *sCast = "CQTEXTFRAMEFORMAT"; return true; }
  if (*sCast == "QTextOption"){ *sCast = "CQTEXTOPTION"; return true; }
  if (*sCast == "QThread"){ *sCast = "CQTHREAD"; return true; }
  if (*sCast == "QTime"){ *sCast = "CQTIME"; return true; }
  if (*sCast == "QTimeEdit"){ *sCast = "CQTIMEEDIT"; return true; }
  if (*sCast == "QTimeLine"){ *sCast = "CQTIMELINE"; return true; }
  if (*sCast == "QTimer"){ *sCast = "CQTIMER"; return true; }
  if (*sCast == "QTimerEvent"){ *sCast = "CQTIMEREVENT"; return true; }
  if (*sCast == "QToolBar"){ *sCast = "CQTOOLBAR"; return true; }
  if (*sCast == "QToolBox"){ *sCast = "CQTOOLBOX"; return true; }
  if (*sCast == "QToolButton"){ *sCast = "CQTOOLBUTTON"; return true; }
  if (*sCast == "QTransform"){ *sCast = "CQTRANSFORM"; return true; }
  if (*sCast == "QTreeView"){ *sCast = "CQTREEVIEW"; return true; }
  if (*sCast == "QTreeWidget"){ *sCast = "CQTREEWIDGET"; return true; }
  if (*sCast == "QTreeWidgetItem"){ *sCast = "CQTREEWIDGETITEM"; return true; }
  if (*sCast == "QUrl"){ *sCast = "CQURL"; return true; }
  if (*sCast == "QUrlInfo"){ *sCast = "CQURLINFO"; return true; }
  if (*sCast == "QVBoxLayout"){ *sCast = "CQVBOXLAYOUT"; return true; }
  if (*sCast == "QValidator"){ *sCast = "CQVALIDATOR"; return true; }
  if (*sCast == "QVariant"){ *sCast = "CQVARIANT"; return true; }
  if (*sCast == "QWebPage"){ *sCast = "CQWEBPAGE"; return true; }
  if (*sCast == "QWebSettings"){ *sCast = "CQWEBSETTINGS"; return true; }
  if (*sCast == "QWebView"){ *sCast = "CQWEBVIEW"; return true; }
  if (*sCast == "QWhatsThisClickedEvent"){ *sCast = "CQWHATSTHISCLICKEDEVENT"; return true; }
  if (*sCast == "QWidget"){ *sCast = "CQWIDGET"; return true; }
  if (*sCast == "QWindowStateChangeEvent"){ *sCast = "CQWINDOWSTATECHANGEEVENT"; return true; }
  if (*sCast == "uiClass"){ *sCast = "CUICLASS"; return true; }



  return false;
}



#include "_Q7BCompiler.h"



QString pageSeparator()
{
  QString s;

  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  s += "<hr size=\"1\">"; 
  return s;
}

QString h1(QString s)
{
  return "<h1>" + s + "</h1>\n";
}

QString h2(QString s)
{
  return "<h2>" + s + "</h2>\n";
}

QString h3(QString s)
{
  return "<h3>" + s + "</h3>\n";
}

QString h4(QString s)
{
  return "<h4>" + s + "</h4>\n";
}

QStringList lContents;

QString ch2(QString s)
{
  //if (!s.contains("Appendix")) lContents << s;  
  return "<a name=\"" + s + "\"></a><h2>" + s + "</h2>\n";
}

QString link(QString s, QString ss = "", QString onClick = "")
{
  if (!onClick.isEmpty()) onClick = " " + onClick;
  if (ss.isEmpty()) return "<a href=\"#" + s + "\"" + onClick + ">" + s + "</a>";

  return "<a href=\"#" + s + "\"" + onClick + ">" + ss + "</a>";
}

QString linkQt(QString s, QString ss)
{
  return "<a href=\"" + s + "\" class=\"qt\" target=\"_parent\">" + ss + "</a>";
}

QString linkTypeClass(QString s)
{
  QString sCategory;
  if (Parser::Me.types.contains(s)) sCategory = "Type";
  else if (Parser::Me.classes.contains(s)) sCategory = "Class";

  return "<a href=\"#" + sCategory + s + "\">" + s + "</a>";
}

QString rightLink(QString l, QString r)
{
  return link(l + r, r, QString("onClick=\"navigate('") + l + r + "')\"");
}

QString bold(QString s)
{
  return "<b>" + s + "</b>";
}

QString name(QString s)
{
  return "<a name=\"" + s + "\"></a>";
}

QString comment(QString s)
{
  if (s.isEmpty()) return "";

  return s.replace("\n", "<br>") + "<br>";
}

QString code(QString s)
{
  return "";

  if (s.isEmpty()) return "";

  bool bError = false;
  QString sError;
  int nErrorLine = 1;

//  QStringList loo = Scanner::scan("i=i+1\nMsgBox(i)", &bError, &sError, &nErrorLine);
  QStringList l = Scanner::scan(s, &bError, &sError, &nErrorLine);

  QString k;
  for (int i = 0; i < l.size(); i++){
    QString q = l.at(i);

    if (q == "K\n") k += "<br>";
    else if (q.startsWith("I")) k += q.mid(1) + " ";
    else if (q.startsWith("N")) k += "<i>" + q.mid(1) + "</i>";
    else if (q.startsWith("S")) k += "<font color=\"#800000\">\"" + q.mid(1) + "\"</font>";
    else if (q == "K." || q == "K!" || q == "K(" || q == "K)" || q == "K[" || q == "K]"){
      if (k.endsWith(" ")) k.chop(1);
      k += "<font color=\"#0000FF\">" + q.mid(1) + "</font>";
    } else if (q == "K,"){
      if (k.endsWith(" ")) k.chop(1);
      k += "<font color=\"#0000FF\">" + q.mid(1) + "</font> ";
    }
    else if (q.startsWith("K")) k += " <font color=\"#0000FF\">" + q.mid(1) + "</font> ";
    else if (q.startsWith("C")) k += "<font color=\"#00AA00\"> ' " + q.mid(1) + "</font>";
        
    
  }

  return "<br><code>" + k + "</code><br>";
}

QString oldbasic(QString sOldBasic)
{
  if (sOldBasic.isEmpty()) return "";

  return "<br><i>Old Basic compatibility (VB6, QBasic). This feature is experimental supported. Please note that VB6 and QBasic support is provided, BUT IT IS STRONGLY RECOMMENDED NOT TO USE subs or functions, which are marked as (VB6, QBasic)! In general, there is a better replacement as a new command.</i>";
}

QString seealso(QString sPrefix, QString s, QString sSuperPrefix = "")
{
  if (s.isEmpty()) return "";

  s = s.replace(" , ", ",");
  s = s.replace(", ", ",");
  s = s.replace(" ,", ",");

  QStringList l = s.split(" ");
  if (l.count() < 2) l = s.split(",");

  QString k;
  for (int i = 0; i < l.size(); i++){
    if (i > 0) k += ", ";
    if (sSuperPrefix.isEmpty()){
      k += link(sSuperPrefix + sPrefix + l.at(i), l.at(i));
    } else {
      k += link(sSuperPrefix + l.at(i), l.at(i));
    }
  }

  return "<br>See also " + k;
}

QString alias(QString sPrefix, QString s, QString sCurrent)
{
  if (s.isEmpty()) return "";

  s = s.replace(" , ", ",");
  s = s.replace(", ", ",");
  s = s.replace(" ,", ",");

  QStringList l = s.split(",", QString::SkipEmptyParts);

  if (l.count() == 1) return "";

  QString k;
  for (int i = 0; i < l.size(); i++){
    if (l.at(i) != sCurrent){
      if (!k.isEmpty()) k += ", ";
      k += link(sPrefix + l.at(i), l.at(i));
    }
  }

  return "<br>Alias " + k;
}

QString ARG(QString s)
{
  if (s.contains("[")) return s;
  if (s.contains("{")) return s;

  QStringList l = s.split(",");
  if (l.count() == 0) l << s;

  QString k;
  for (int i = 0; i < l.size(); i++){
    if (i > 0) k += ", ";
    QString q = l.at(i);
    int n = q.indexOf(" As ");
    if (n >= 0){
      QString r = q.mid(n + 4);
      int n2 = r.indexOf(" = ");
      if (n2 >= 0){
        k += q.left(n) + " " + link("As") + " " + linkTypeClass(r.left(n2)) + r.mid(n2);
      } else {
        k += q.left(n) + " " + link("As") + " " + linkTypeClass(r);
      }
    } else {
      k += link(q);
    }
  }

  return k;
}

QMap<QString, QStringList> sSuperClasses;
QMap<QString, QStringList> sChildClasses2;

QStringList lNonQObjectClasses;


QString getInheritanceClasses(QString sSuperClass, int nCounter, QStringList & lSuperClasses)
{

  sChildClasses2[sSuperClass] = lSuperClasses;
  Parser::Me.super_classes[sSuperClass] = lSuperClasses;

  lSuperClasses.append(sSuperClass);

  lNonQObjectClasses << sSuperClass;

  QString s;
  QStringList l = sSuperClasses[sSuperClass];

  for (int i = 0; i < l.count(); i++){
  
    if (Parser::Me.controls.contains(l.at(i))){ 
      getInheritanceClasses(l.at(i), nCounter + 1, lSuperClasses);
    } else {
      s += "<li>" + link("Class" + l.at(i), l.at(i)) + "</li><ul>" + getInheritanceClasses(l.at(i), nCounter + 1, lSuperClasses) + "</ul>";
    }
  }

  lSuperClasses.removeLast();

  return s;
}

QString sLIST;
QString sDICTIONARY;
QString sClassesGenerator_h;
QString sClassesGenerator_cpp;

QString typeHelper(QString s, bool *bEnum = 0)
{
  if (bEnum) *bEnum = true;
  if (s.contains("::")) return "Integer";
  if (bEnum) *bEnum = false;
  return s;
}

QString sRest;

QString getClassBody(QString sCategory, QMap<QString, QString> & theClass, QMap<QString, QMap<QString, _comment> > & theComment)
{
  static QString Q7BRuntime_cpp;
  static QString Q7BRuntime_h;
  


  if (Q7BRuntime_h.isEmpty()) Q7BRuntime_h = Parser::LoadFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "/objb_q7basic/q7b/Runtime/Q7BRuntime.h");
  if (Q7BRuntime_cpp.isEmpty()) Q7BRuntime_cpp = Parser::LoadFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "/objb_q7basic/q7b/Runtime/Q7BRuntime.cpp");

  QString ss;
  QString s;


  QMapIterator<QString, QString> it(theClass);
  while (it.hasNext()){
    it.next();

    QString sClass = it.key();

    s = "";
    if (sClass == "List"){
    } else if (sClass == "Dictionary"){
    } else {

      s += name(sCategory + sClass); 
      s += name(sClass);           // double name  one for F1 and one for links

      QString sQtDocu = "http://qt-project.org/doc/qt-4.8/" + sClass + ".html";    
      if (sCategory == "Class"){
        s += h3(QString("<font color=\"#123456\">" + sCategory + "</font>") + " " + bold(linkQt(sQtDocu, sClass)));
      } else {
        s += h3(QString("<font color=\"#123456\">" + sCategory + "</font>") + " " + bold(sClass));
      }
    }

    if (sClass == "test2"){
      sClass = sClass;
    }

    QString sClassComment = theComment[sClass][""]._COMMENT;

    
    QString _sSuperClasses;

    if (Parser::Me.controls.contains(sClass) && sClass != "Control"){
      _sSuperClasses += link(sCategory + "Control", "Control") + " ";
    }      

    QStringList l = sChildClasses2[sClass];
    for (int i = l.size() - 1; i >= 0; i--){
      _sSuperClasses += link("Class" + l.at(i), l.at(i)) + " ";
    }

    QString _sChildClasses;

    if (sClass == "Control"){
      {
        QMapIterator<QString, QString> it(Parser::Me.controls);
        while (it.hasNext()){
          it.next();

          QString sKey = it.key();

          if (sKey == "Control") continue;

          _sChildClasses += link(sCategory + sKey, sKey) + " ";
        }
      }

    } else {
      l = sSuperClasses[sClass];
      for (int i = l.size() - 1; i >= 0; i--){
        _sChildClasses += link(sCategory + l.at(i), l.at(i)) + " ";
      }
    }

    QString _sOverview;
    QString _sSubFunction;
    QString _sProperty;
    QString _sEvent;
    QString _sSignal;
    QString _sDelegate;

    
    
    if (sClass == "QPaintEvent"){
      sClass = sClass;
    }

    QMapIterator<QString, _comment>it2 = theComment[sClass];
    while (it2.hasNext()){
      it2.next();    

      QString sKey = it2.key();

      if (sKey == "") continue; 

      _comment c = it2.value();

      _sOverview += "<a href=\"#" + sClass + sKey + "\""">" + sKey + "</a> ";

      if (sClass == "test2"){
        sClass = sClass;
      }
      
      if (CONFIG["CompileItself"] == "true" 
        && sKey.at(0).isLower() 
        && (c._CATEGORY == "SubFunction" || c._CATEGORY == "Property"))
      {

        if (sClass == "Dictionary") continue;
        if (sClass == "List") continue;
        if (sClass == "PhononSeekSlider") continue;
        if (sClass == "PhononVideoPlayer") continue;
        if (sClass == "PhononVolumeSlider") continue;

        if (sClass == "QListQStringList") continue;         

        if (sClass == "QTextDocument"){
          sClass = sClass;
        }
        if (sKey.toUpper() == "SETHTML"){
          sKey = sKey;
        }

        QString sClass2 = Parser::convertDeclareType(sClass, 0);
        QString sMethod;
        QString sProperty1;
        QString sProperty2;
        QString sProperty3;

        for (int i = 0; i < (c._CATEGORY == "Property" ? 2 : 1); i++){
          sMethod = sKey;
          
          bool bEnum = false;
          QString c_RETURN = "void";
          if (!c._RETURN.isEmpty()){ 
            c_RETURN = Parser::convertDeclareType(typeHelper(c._RETURN, &bEnum), 2);
          }
          QString sReturn;
          if (i == 0){
            sReturn = c_RETURN;
            if (c._CATEGORY == "Property" && sReturn == "bool"){
              sMethod = "is" + sMethod.left(1).toUpper() + sMethod.mid(1);
            }
          } else {
            

            sReturn = c_RETURN;
            
            if (c._CATEGORY == "Property"){
              sMethod = "set" + sMethod.left(1).toUpper() + sMethod.mid(1);

              QString sType = sReturn;
              if (sType == "id*") sType = "";
              if (sType.endsWith("*")) sType = sType.replace("*", "");

              sProperty1 = ", Q7B theProperty";
              sProperty2 = "\n  if (Q7B_nil(Q7B_" + sType.toUpper() + "(theProperty))){ Q7B_EXCEPTION(\"" + sType + " expected\"); return; }\n";
              sProperty3 = (bEnum ? "(" + c._RETURN + ") " : "") + "Q7B_ID" + sType + "(theProperty)";
            }            
          }
          QString sHeader = (sReturn == "void" || i > 0 ? "void " : "Q7B ") + QString("Q7B_") + sClass.toUpper() + "_" + sKey.toUpper() + "(";

          sHeader += "Q7B self" + sProperty1;

          QStringList l = c._ARGUMENTS.split(",", QString::SkipEmptyParts);

          QString sCallArgs = "(";
          QString sCheckArgs;
          for (int y = 0; y < l.size(); y++){

            QString m = l.at(y);
            QString sName;
            QString sType;
            QString sType2;
            QString sType3;

            bool bEnum = false;
            if (m.contains(" As ")){
              sName = m.left(m.indexOf(" As "));
              sType = Parser::convertDeclareType(typeHelper(m.mid(m.indexOf(" As ") + 4), &bEnum), 2);
              sType2 = Parser::convertDeclareType(typeHelper(m.mid(m.indexOf(" As ") + 4), &bEnum), 0);
              sType3 = m.mid(m.indexOf(" As ") + 4);
            } else {
              sName = QString("a%1").arg(y);
              sType = Parser::convertDeclareType(typeHelper(m.simplified(), &bEnum), 2);
              sType2 = Parser::convertDeclareType(typeHelper(m.simplified(), &bEnum), 0);
              sType3 = m.simplified();
            }
            if (sType == "id*") sType = "";
            if (sType.endsWith("*")) sType = sType.replace("*", "");

            if (sType.indexOf("=") > 0) sType = sType.left(sType.indexOf("="));
            if (sType2.indexOf("=") > 0) sType2 = sType2.left(sType2.indexOf("="));

            sName = sName.simplified();
            sType = sType.simplified();
            sType2 = sType2.simplified();

            if (y > 0) sCallArgs += ", ";
            sCallArgs += (bEnum ? "(" + sType3 + ") " : "") + "Q7B_ID" + sType + "(" + sName + ")";

            sHeader += ", ";
            sHeader += "Q7B " + sName;

            if (!sType.isEmpty()) sCheckArgs += "\n  if (Q7B_nil(Q7B_" + sType.toUpper() + "(" + sName + "))){ Q7B_EXCEPTION(\"" + sType2 + " expected\"); return " + (sReturn == "void" || i > 0 ? "; }\n" : "Q7B_idnil; }\n");
             
            
          }
          sCallArgs += sProperty3;
          sCallArgs += ")";
          sHeader += ")";

          QString sHeader2 = sHeader.left(sHeader.indexOf("("));
          if (!Q7BRuntime_h.contains("\n" + sHeader2)){
            sClassesGenerator_h += sHeader + "; // generated\n";
          }

          if (Q7BRuntime_cpp.contains("\n" + sHeader2)){
            sRest += sHeader;     
            continue;
          } else {
            sClassesGenerator_cpp += sHeader + " // generated\n{\n";

            sClassesGenerator_cpp += QString("  if (Q7B_nil(self)){ Q7B_NULLPOINTEREXCEPTION(); return ") + (sReturn == "void" || i > 0 ? "; }\n" : "Q7B_idnil; }\n");
            sClassesGenerator_cpp += "  if (Q7B_nil(Q7B_" + sClass.toUpper() + "(self))){ Q7B_EXCEPTION(\"" + sClass2 + " expected\"); return " + (sReturn == "void" || i > 0 ? "; }\n" : "Q7B_idnil; }\n");

            sClassesGenerator_cpp += sCheckArgs;
          
            sClassesGenerator_cpp += sProperty2;
            sClassesGenerator_cpp += "\n";
            
            QString sCall = "Q7B_ID" + sClass + "(self)" + (!lNonQObjectClasses.contains(sClass) ? "." : "->") + sMethod.left(1).toLower() + sMethod.mid(1);
            if (sReturn == "void" || i > 0){
              sClassesGenerator_cpp += "  " + sCall + sCallArgs + ";\n";
            } else {
              sClassesGenerator_cpp += "  return Q7B_ID( " + sCall + sCallArgs + " );\n";
            }
            sClassesGenerator_cpp += "}\n\n";
          }


          if (c._CATEGORY == "SubFunction") break;
          
        }
      }

      QString sQtDocu = "http://qt-project.org/doc/qt-4.8/" + sClass + ".html#" + sKey;      
      QString sKey2 = sKey.at(0).isUpper() ? sKey : linkQt(sQtDocu, sKey);

      if (c._CATEGORY == "SubFunction"){
        _sSubFunction += "<a name=\"" + sClass + sKey + "\"></a>";
        
        if (c._RETURN.isEmpty()){
          _sSubFunction += h3(link("Sub") + " " + bold(sKey2) + "(" + ARG(c._ARGUMENTS) + ")");
        } else {
          _sSubFunction += h3(link("Function") + " " + bold(sKey2) + "(" + ARG(c._ARGUMENTS) + ")" + " " + link("As") + " " + linkTypeClass(c._RETURN));
        }      
        _sSubFunction += comment(c._COMMENT.replace("$", bold(sKey)));
        _sSubFunction += code(c._EXAMPLE);
        _sSubFunction += seealso(c._CATEGORY, c._SEEALSO, sClass);
        _sSubFunction += alias(c._CATEGORY, c._ALIAS, sKey);

      } else if (c._CATEGORY == "Property"){
        _sProperty += "<a name=\"" + sClass + sKey + "\"></a>";
        
        _sProperty += h3(link("Property") + " " + bold(sKey2) + " " + link("As") + " " + linkTypeClass(c._RETURN));
        _sProperty += comment(c._COMMENT.replace("$", bold(sKey)));
        _sProperty += code(c._EXAMPLE);
        _sProperty += seealso(c._CATEGORY, c._SEEALSO, sClass);
        _sProperty += alias(c._CATEGORY, c._ALIAS, sKey);

      } else if (c._CATEGORY == "Event"){
        _sEvent += "<a name=\"" + sClass + sKey + "\"></a>";        
        
        if (c._RETURN.isEmpty()){
          _sEvent += h3(link("Event") + " " + bold(sKey2) + "(" + ARG(c._ARGUMENTS) + ")");
        } else {
          _sEvent += h3(link("Event") + " " + bold(sKey2) + "(" + ARG(c._ARGUMENTS) + ")" + " " + link("As") + " " + linkTypeClass(c._RETURN));
        }    
        _sEvent += comment(c._COMMENT.replace("$", bold(sKey)));
        _sEvent += code(c._EXAMPLE);
        _sEvent += seealso(c._CATEGORY, c._SEEALSO, sClass);
        _sEvent += alias(c._CATEGORY, c._ALIAS, sKey);

      } else if (c._CATEGORY == "Signal"){
        _sSignal += "<a name=\"" + sClass + sKey + "\"></a>";
                
        _sSignal += h3(link("Signal") + " " + bold(linkQt(sQtDocu, sKey2)) + "(" + ARG(c._ARGUMENTS) + ")");

        _sSignal += comment(c._COMMENT.replace("$", bold(sKey)));
        _sSignal += code(c._EXAMPLE);
        _sSignal += seealso(c._CATEGORY, c._SEEALSO, sClass);
        _sSignal += alias(c._CATEGORY, c._ALIAS, sKey);

      } else if (c._CATEGORY == "Delegate"){
        _sDelegate += "<a name=\"" + sClass + sKey + "\"></a>";
        
        if (c._RETURN.isEmpty()){
          _sDelegate += h3(link("Delegate") + " " + bold(sKey2) + "(" + ARG(c._ARGUMENTS) + ")");
        } else {
          _sDelegate += h3(link("Delegate") + " " + bold(sKey2) + "(" + ARG(c._ARGUMENTS) + ")" + " " + link("As") + " " + linkTypeClass(c._RETURN));
        }    
        _sDelegate += comment(c._COMMENT.replace("$", bold(sKey)));
        _sDelegate += code(c._EXAMPLE);
        _sDelegate += seealso(c._CATEGORY, c._SEEALSO, sClass);
        _sDelegate += alias(c._CATEGORY, c._ALIAS, sKey);

      }

    }

    s += "<div style=\"background-color:#EFEFEF;\">";

    if (!sClassComment.isEmpty()){
      s += sClassComment;
      s += "<br>";
    }

    if (!_sSuperClasses.isEmpty()){
      s += h4("Super Classes");
      s += _sSuperClasses;
      s += "<br>";
      s += "<br>";
    }

    if (!_sChildClasses.isEmpty()){
      s += h4("Child Classes");
      s += _sChildClasses;
      s += "<br>";
      s += "<br>";
    }

    if (!_sOverview.isEmpty()){
      s += h4("Overview");
      s += _sOverview;
      s += "<br>";
      s += "<br>";
    }
    s += "</div>";
    
    if (!_sProperty.isEmpty()){
      s += "<br>";
      s += h4("Properties");
      s += _sProperty;
      s += "<br>";
    }

    if (!_sSubFunction.isEmpty()){
      s += "<br>";
      s += h4("Subs & Functions");
      s += _sSubFunction;
      s += "<br>";
    }

    if (!_sEvent.isEmpty()){
      s += "<br>";
      s += h4("Events");
      s += _sEvent;
      s += "<br>";
    }

    if (!_sSignal.isEmpty()){
      s += "<br>";
      s += h4("Signals");
      s += _sSignal;
      s += "<br>";
    }

    if (!_sDelegate.isEmpty()){
      s += "<br>";
      s += h4("Delegates");
      s += _sDelegate;
      s += "<br>";
    }

    s += "<hr size=\"1\">";

    if (sClass == "List"){
      sLIST = s;
    } else if (sClass == "Dictionary"){
      sDICTIONARY = s;
    } else {

      ss += s;
    }

  }


  if (sCategory == "Class"){
    Parser::SaveFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "\\objb_q7basic\\Generator\\Classes.cpp", sClassesGenerator_cpp, true);
    Parser::SaveFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "\\objb_q7basic\\Generator\\Classes.h", sClassesGenerator_h, true);
  }

  return ss;
}


void Parser::createDocumentation()
{
  QString body;
  QString contents;

  QString sSEARCH;

  QString BASIC;

  BASIC = "Basic For Qt&reg;";

  {
    QMapIterator<QString, QString> it(Me.classes);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();



      if (sKey == "List") continue;
      if (sKey == "Dictionary") continue;

      // e.g. sSuperClasses["NSObject] << "MovieView";
      sSuperClasses[it.value()] << sKey;
    }
  }

  {
    QMapIterator<QString, QString> it(Me.controls);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();

      sSuperClasses[it.value()] << sKey;
    }
  }
  
  QString sINHERITANCE_CLASSES;  
  {


      sINHERITANCE_CLASSES += link("ClassQObject", "QObject") + "<br>";
      sINHERITANCE_CLASSES += "<ul>";
      QStringList lSuperClasses;
      sINHERITANCE_CLASSES += getInheritanceClasses("QObject", 0, lSuperClasses);
      sINHERITANCE_CLASSES += "</ul>";


    if (CONFIG["CompileItself"] != "true"){
      return;
    }

    //QString sdaf = sChildClasses2["QPushButton"].join(";");

    QString sNonQObjectClasses;
    {
      QMapIterator<QString, QString> it(Me.classes);
      while (it.hasNext()){
        it.next();

        QString sKey = it.key();


        if (sKey == "List") continue;
        if (sKey == "Dictionary") continue;

        if (!lNonQObjectClasses.contains(sKey)){    
          sNonQObjectClasses += "<li>" + link("Class" + sKey, sKey) + "</li>";
        }
      }
    }



    sINHERITANCE_CLASSES += "<br>Non QObject-based classes (flat view)<br><br><ul>";

    sINHERITANCE_CLASSES += sNonQObjectClasses;
    sINHERITANCE_CLASSES += "</ul>";
  }

  QString sCLASS;
  QString sCLASS2; 
  QString sCLASS3; 
  {
    QMapIterator<QString, QString> it(Me.classes);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();


        if (sKey == "List") continue;
        if (sKey == "Dictionary") continue;

      sCLASS += link("Class" + sKey, sKey) + " ";
      
      sCLASS3 += "<OPTION value=\"Class" + sKey + "\">" + sKey;
      sSEARCH += "'" + sKey + "', ";
    }
  }
  sCLASS2 += getClassBody("Class", Me.classes, Me.comments_classes);

  sRest = sRest;

  if (!sClassesGenerator_cpp.isEmpty()){

    SaveFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "\\objb_q7basic\\Generator\\sClassesGenerator_h.txt", sClassesGenerator_h, false);
    SaveFile(QStandardPaths::writableLocation(QStandardPaths::DesktopLocation) + "\\objb_q7basic\\Generator\\sClassesGenerator_cpp.txt", sClassesGenerator_cpp, false);
  }

  QString sOBJECT;
  QString sOBJECT2; 
  QString sOBJECT3; 
  {
    QMapIterator<QString, QMap<QString, _comment> > it(Me.comments_objects);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();

      sOBJECT += link("Object" + sKey, sKey) + " ";

      sOBJECT3 += "<OPTION value=\"Object" + sKey + "\">" + sKey;
      sSEARCH += "'" + sKey + "', ";

    }
  }
  sOBJECT2 += getClassBody("Object", Me.objects, Me.comments_objects);


  QString sCONTROL;
  QString sCONTROL2; 
  QString sCONTROL3; 
  QString sSuperControls;
  {
    QMapIterator<QString, QString> it(Me.controls);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();

      if (sKey != "Control"){     
        sSuperControls += "<li>" + link("Control" + sKey, sKey) + "</li>";

        sCONTROL += link("Control" + sKey, sKey) + " ";
      }
 
      sCONTROL3 += "<OPTION value=\"Control" + sKey + "\">" + sKey;
      sSEARCH += "'" + sKey + "', ";

    }
  }
  sCONTROL2 += getClassBody("Control", Me.controls, Me.comments_controls);

  QString sINHERITANCE_CONTROLS;  
  {
    sINHERITANCE_CONTROLS += link("ControlControl", "Control") + "<br>";
    sINHERITANCE_CONTROLS += "<ul>";
    sINHERITANCE_CONTROLS += sSuperControls;
    sINHERITANCE_CONTROLS += "</ul>";
  }
  
  QString sSUBFUNCTION;
  QString sSUBFUNCTION2;
  QString sSUBFUNCTION3;
  QMap<QString, QStringList> sGROUP;
  {
    QMapIterator<QString, QStringList> it(Me.subsfunctions);
    QString sInitGroup;
    QString sInitGroup2 = "<OPTION value=\"\">";

    while (it.hasNext()){
      it.next();
      QString sKey = it.key();

      _comment c = Me.comments_subsfunctions[sKey];

      sGROUP[c._GROUP] << sKey;

      if (c._GROUP == "Init"){
        sGROUP["Conversion"] << sKey; 

        sInitGroup += link("Sub" + sKey, sKey) + " ";
      } else {
        sSUBFUNCTION += link("Sub" + sKey, sKey) + " ";
      }      

      sSUBFUNCTION2 += name("Sub" + sKey); 
      if (c._GROUP != "Init"){      
        sSUBFUNCTION2 += name(sKey);         
        sSUBFUNCTION3 += "<OPTION value=\"Sub" + sKey + "\">" + sKey;
        sSEARCH += "'" + sKey + "', ";
      } else {
        sInitGroup2 += "<OPTION value=\"Sub" + sKey + "\">" + sKey;
      }      

      
      if (c._RETURN.isEmpty()){
        sSUBFUNCTION2 += h3(link("Sub") + " " + bold(sKey) + "(" + ARG(c._ARGUMENTS) + ")");
      } else {
        sSUBFUNCTION2 += h3(link("Function") + " " + bold(sKey) + "(" + ARG(c._ARGUMENTS) + ")" + " " + link("As") + " " + linkTypeClass(c._RETURN));
      }      
      sSUBFUNCTION2 += comment(c._COMMENT.replace("$", bold(sKey)));
      sSUBFUNCTION2 += code(c._EXAMPLE);
      sSUBFUNCTION2 += seealso("Sub", c._SEEALSO);
      sSUBFUNCTION2 += alias("Sub", c._ALIAS, sKey);
      sSUBFUNCTION2 += oldbasic(c._OLDBASIC);
      

      sSUBFUNCTION2 += "<hr size=\"1\">";

    }
    sSUBFUNCTION += "<br><br>The following list contains the init functions.<br><br>" + sInitGroup;

    sSUBFUNCTION3 += sInitGroup2;
  }

  QString sKEYWORD;
  QString sKEYWORD2; 
  {
    for (int i = 0; i < Me.keywords.size(); i++){

      QString sKey = Me.keywords.at(i);

      sKey = sKey.replace("<", "&lt;").replace(">", "&gt;");

      

      sKEYWORD += link("Keyword" + sKey, sKey) + " ";
      
      sKEYWORD2 += name("Keyword" + sKey); 
      sKEYWORD2 += name(sKey);             // double name  one for F1 and one for links


      sKEYWORD2 += h3(QString("<font color=\"#123456\">Keyword</font>") + " " + bold(sKey));


      _comment c = Me.comments_keywords[sKey];

      sKEYWORD2 += comment(c._COMMENT.replace("$", bold(sKey)));
      sKEYWORD2 += code(c._EXAMPLE);
      sKEYWORD2 += seealso("Keyword", c._SEEALSO);

      sKEYWORD2 += "<hr size=\"1\">";
    }
  }

  QString sCPPOBJCKEYWORD;
  {
    for (int i = 0; i < Me.cppobjcjava_keywords.size(); i++){

      QString sKey = Me.cppobjcjava_keywords.at(i);

      sCPPOBJCKEYWORD += sKey + " ";      
    }
  }

  QString sTYPE;
  QString sTYPE2; 
  {
    for (int i = 0; i < Me.types.size(); i++){

      QString sKey = Me.types.at(i);
      

      sTYPE += link("Type" + sKey, sKey) + " ";
      
      sTYPE2 += name("Type" + sKey); 
      sTYPE2 += name(sKey);          // double name  one for F1 and one for links


      sTYPE2 += h3(QString("<font color=\"#123456\">Type</font>") + " " + bold(sKey));


      _comment c = Me.comments_types[sKey];

      sTYPE2 += comment(c._COMMENT);


      if (sKey == "List"){
        sTYPE2 += sLIST;
      } else if (sKey == "Dictionary"){
        sTYPE2 += sDICTIONARY;
      }

      sTYPE2 += "<hr size=\"1\">";
    }
  }

  QString sCONSTANT;
  QString sCONSTANT2; 
  QString sCONSTANT3; 
  {
    QMapIterator<QString, QList<QVariant> > it(Me.constants);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();     


      sCONSTANT += link("Constant" + sKey, sKey) + " ";
      
      sCONSTANT2 += name("Constant" + sKey); 
      sCONSTANT2 += name(sKey);              // double name  one for F1 and one for links

      sCONSTANT3 += "<OPTION value=\"Constant" + sKey + "\">" + sKey;
      sSEARCH += "'" + sKey + "', ";

      sCONSTANT2 += h3(QString("<font color=\"#123456\">Constant</font>") + " " + bold(sKey));

      _comment c = Me.comments_constants[sKey];

      sCONSTANT2 += comment(c._COMMENT);

      sCONSTANT2 += "<hr size=\"1\">";
    }
  }

  QString sOPERATOR;
  QString sOPERATOR2; 
  {
    for (int i = 0; i < Me.operators.size(); i++){

      QString sKey = Me.operators.at(i);
      
      sOPERATOR += link("Operator" + sKey, sKey) + " ";
      
      sOPERATOR2 += name("Operator" + sKey); 
      sOPERATOR2 += name(sKey);              // double name  one for F1 and one for links


      sOPERATOR2 += h3(QString("<font color=\"#123456\">Operator</font>") + " " + bold(sKey));

      _comment c = Me.comments_operators[sKey];

      sOPERATOR2 += comment(c._COMMENT);

      sOPERATOR2 += "<hr size=\"1\">";
    }
  }



  

  body += h1(BASIC + "'s Language Reference");

  body += BASIC + " comes with extensive documentation, with hypertext cross-references throughout, so you can easily click your way to whatever interests you. The part of the documentation that you will probably use the most is the this Language Reference. Each link provides a different way of navigating the this Language Reference; try them all to see which work best for you. ";
  body += BASIC + " ships with lots of small and some medium-sized example programs that teach you how to implement various tasks. Most of them will show how to use a certain class or module, others aim at programming techniques and basics, and some of them simply want to show you what is possible.<br><br>"

"Names starting with 'Q' normally directly points to native Qt names in general. If you would like to send a comment or an example, please write to sales@kbasic.com.";
  body += "<br>This new framework provides many improvements and enhancements over previous releases. This overview covers the most important features. ";
  body += BASIC + " will be continuously improved as a result of feedback and suggestions from customers and the open source community. ";

  body += "<br><br>Last edit on " + QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss") + "<br><br>";
  
  body += ch2("Subs & Functions");    
  body += "Sub-procedures contain commands and statements, but do not return a value or cannot be used in expressions. The following built-in subs are predefined subs, which has a special meaning and which meaning cannot be changed. Some of them are provided for VB6 backward compatibility.";
  body += "A function-procedure is like a sub-procedure, but it can return a value. That is the only difference between them. The following built-in functions are predefined functions, which has a special meaning and which meaning cannot be changed. Some of them are provided for VB6 backward compatibility.";
  body += "<br><br>" + sSUBFUNCTION + QString("<br><br>");    
  
  body += ch2("Objects");   
  body += "The following list contains the built-in objects.";
  body += "<br><br>" + sOBJECT + QString("<br><br>");    
  
  body += ch2("Classes");   
  body += "Classes are needed, when you would like create objects. The following list contains the built-in classes.";
  body += "<br><br>" + sCLASS + QString("<br><br>");    
  
  body += ch2("Inheritance Tree");   

  body += "Built-in Qt classes are listed. QObject is the root class of most classes. Through id, objects inherit a basic interface to the runtime system.";
  body += "<br><br>" + sINHERITANCE_CLASSES + QString("<br><br>");    
  

  body += ch2("Controls");   
  body += "This is the parent class of all controls providing common functionality for all controls (used by the form designer). It receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. ";
  body += "<br><br>" + sINHERITANCE_CONTROLS + QString("<br><br>");    

  body += ch2("Keywords"); 
  body += "A keyword is a predefined identifier, which has a special meaning for " + BASIC + " and which meaning cannot be changed. The following list contains all " + BASIC + " keywords. Be aware that keywords are case sensitive, which means you must it write with the same lowercase or uppercase letters everywhere.  Some of them are provided for backward compatibility.";
  body += "<br><br>" + sKEYWORD + QString("<br><br>");    
  
  body += ch2("Types"); 
  body += "Like a file, a variable has a name (used to access the variable and to identify it). Additional, it has also a data type to specify the type of information a variable holds. So data types describe the type of data stored inside a variable. If you declare a variable you must also give it a data type. Unlike built-in classes, the following types cannot be used as super class for custom classes.";
  body += "<br><br>" + sTYPE + QString("<br><br>");    
  
  body += ch2("Constants"); 
  body += "Constants are similar to variables but they cannot change values. When you declare a constant you assign a value to it that cannot be altered during the lifetime of your program.";
  body += "<br><br>" + sCONSTANT + QString("<br><br>");    
  
  body += ch2("Operators"); 
  body += "Operators for calculating, comparision, logical operators and other Operators.";
  body += "<br><br>" + sOPERATOR + QString("<br><br>");    
    
  QString sOperatorOrder = "<ol><li>" + link(".") + " " + link("!") + " " + link("(") + " " + link(")") + " " + "</li><li>" + link("Not") + " " + link("Flip") + " " + "(unary +) (unary -)" + "</li><li>" + link("*") + " " + link("/") + " " + link("\\") + " " + link("Mod") + "</li><li>" + link("&") + " " + link("+") + " " + link("-") + " " + "</li><li>" + link("^") + "</li><li>" + " " + link("Shl") + " " + link("Shr") + "</li><li>" + link("<") + " " + link(">") + " " + link("<") + " " + link("=") + " " + link(">=") + " " + link("=") + " " + link("==") + " " + link("===") + " " + "</li><li>" + link("And") + " " + "</li><li>" + link("Or") + " " + link("Xor") + " " + "</li><li>" + link("AndAlso") + " " + "</li><li>" + link("OrElse") + " " + "</ol><br>Use paranthesis () to change the order.";
  body += ch2("Operator Order"); 
  body += "Normally, an expression is executed from left to right following standard mathematical rules. Here is the overview about operator order (priority) from top to bottom, which means " + link("*") + " is executed before " + link("And") + ":";
  body += "<br><br>" + sOperatorOrder + QString("<br><br>");    

  body += ch2("Sub-Classing"); 

  body += "Most built-in Qt classes may be used to create new classes (a sub-class) based on an existing Qt class. Change the file extension of a code file in order to do so.";
  body += "<br><br>Example: file name is 'Car.QObject.q7b'.<br><br>Class name is 'Car' and super class is 'QObject'." + QString("<br><br>");    


  body += ch2("Control Flow & Structure"); 
  body += "Decisions: The term 'decisions' refers to the use of conditional statements to decide what to execute in your program. Conditional statements test if a given expression is 'True' or 'False.'Then, statements are executed. Normally a condition uses an expression in which a comparison operator is used to compare two values or variables. ";
  body += "<br><br>Loops: The statements that control decisions and loops are called control structures. Normally every command is executed only one time but in many cases it may be useful to run a command several times until a defined state has been reached. Loops repeat commands depending upon a condition. Some loops repeat commands while a condition is 'True,' other loops repeat commands while a condition is 'False.' There are other loops repeating a fixed number of times and some repeat for all elements of a collection." + QString("<br><br>");    
  
body += ""
"Class : Classes are needed, when you would like use custom objects.<br>"
"<br>"
"Module : Modules are needed, when you would like to organize large code parts<br>"
"<br>"
"Do...Loop Until : repeats until a condition is set<br>"
"<br>"
"Do...Loop While : repeats statements while condition is set<br>"
"<br>"
"Do Until...Loop : A group of statements enabling you to define a loop which will be repeated until a certain condition remains true.<br>"
"<br>"
"Do While...Loop : A group of statements enabling you to define a loop which will be repeated until a certain condition remains true.<br>"
"<br>"
"Break : breaks out of a loop wether it is a for loop or not<br>"
"<br>"
"Exit Do : breaks out of a loop<br>"
"<br>"
"Exit For : breaks out of a for loop<br>"
"<br>"
"Exit Function : exits a function <br>"
"<br>"
"Exit Sub : exits a sub <br>"
"<br>"
"For Next : Defines a loop that runs for a specified number of times.<br>"
"<br>"
"GoTo : jumps to the desired label or line<br>"
"<br>"
"If : single decision possibility<br>"
"<br>"
"IIf : returns a value depending on an expression<br>"
"<br>"
"Continue : continues to iterate a loop wether it is a for loop or not<br>"
"<br>"
"Iterate Do : continues to iterate a loop if condition is set<br>"
"<br>"
"Iterate For : continues to iterate a for loop if condition is set<br>"
"<br>"
"Return : returns either from a gosub call or leaves the function or sub<br>"
"<br>"
"Select : Multi-line conditional selection statement.<br>"
"<br>"
"While...End While : A group of statements enabling you to define a loop which will be repeated until a certain condition remains true.<br>"
"<br>";


  body += ch2("Comments"); 
  QString sComment = "* " + link("'") + " " + "Code is recognized as comment till the end of the current line.<br><br>";
  body += QString("The ") + link("'", "comment") + " symbol " + link("'") + " is used to mark comments in code. Comments can explain a procedure or a statement. " + BASIC + " ignores all comments while compiling and running your program. To write a comment, use the symbol " + link("'") + " followed by the text of the comment. Comments are printed in green on screen. Comments are extremely helpful when it comes to explaining your code to other programmers. So comments, normally, describe how your program works. ";
  body += "<br><br>" + sComment + QString("<br><br>");    
  


  QString sLiteral = "<table>"
  "<tr><td>Integer</td><td>-1, 2, -44, 4453</td></tr>"
  "<tr><td>Float</td><td>21.32, 0.344, -435.235421.21</td></tr>"
  "<tr><td>Decimal</td><td>21.99D, 0.3456D</td></tr>"
  "<tr><td>String</td><td>Is simply text, but it must start with a " + link("\"") + " and end with a " + link("\"") + " so that " + BASIC + " can recognize it as string. Strings uses the same escape codes as C++ strings. Important escape codes are: \\\" = Double quotation mark, \\\\ = Backslash" + "</td></tr>"
  "<tr><td>Boolean</td><td>" + link("True") + ", " + link("False") + "</td></tr>"
  "</table><br>";

  body += ch2("Literals"); 
  body += "Besides keywords, symbols, and names, a " + BASIC + " program contains literals. A literal is a number or string representing a value. There are different numerical literals.";
  body += sLiteral + QString("<br><br>");      


  QString sWayOfNaming = "When coding in " + BASIC + ", you declare and name elements, like procedures (functions and subs), variables, and constants and so on. All names must start with a letter; may contain letters, numbers, or the sign _ (periods and commas are forbidden); and must not contain reserved words. A reserved word is a part of " + BASIC + " and has a predefined meaning. These include keywords (e.g. " + link("If") + " or " + link("Then") + "), builtin-functions and operators (e.g. " + link("Mod") + "). Be aware that names are case sensitive, which means you must it write with the same lowercase or uppercase letters everywhere. <br><br>";
  body += ch2("Appendix: Way of naming"); 
  body += sWayOfNaming;    
  
  QString sNativeLanguage;


  sNativeLanguage = "C++";

  body += ch2("Appendix: List of " + sNativeLanguage + " Keywords"); 
  body += "The following list contains all " + sNativeLanguage + " keywords, which must not be used in " + BASIC + " code.";

  body += "<br><br><div style=\"background-color:#EEEEEE;\">" + sCPPOBJCKEYWORD + QString("</div><br><br>");
  
  body += ch2("Appendix: Syntax of Arguments"); 
  body += "The following list gives you some hints regarding how to read the syntax provided here.";
  body += "<br><br>Arguments listed inside brackets [ ] are optional.<br>(Do not write these [ ] in your code).";
  body += "<br><br>{ } together with | means that one of the elements must be written.<br>(Do not write these { } or | in your code).";
  body += "<br><br>";  

  body += pageSeparator();

  body += h2("Subs & Functions");    
  body += sSUBFUNCTION2;    
  body += pageSeparator();
  
  body += h2("Objects");    
  body += sOBJECT2;    
  body += pageSeparator();
  
  body += h2("Classes");    
  body += sCLASS2;   
  body += pageSeparator();

  body += h2("Controls");    
  body += sCONTROL2;  
  body += pageSeparator();

  body += h2("Keywords");    
  body += sKEYWORD2;  
  body += pageSeparator();

  body += h2("Types");    
  body += sTYPE2;  
  body += pageSeparator();

  body += h2("Constants");    
  body += sCONSTANT2;  
  body += pageSeparator();

  body += h2("Operators");    
  body += sOPERATOR2;  
  body += pageSeparator();



  contents += h2("Grouped");    
  QString sInitGroup;
  {
    QMapIterator<QString, QStringList> it(sGROUP);
    while (it.hasNext()){
      it.next();
      QStringList l = it.value();

      QString sKey = it.key();
      if (sKey.isEmpty()) sKey = "Misc.";

      if (sKey == "Init"){
        sInitGroup += h3(sKey);
      } else {
        contents += h3(sKey);
      }

      for (int i = 0; i < l.size(); i++){         
        QString sdf = l.at(i);

        if (sKey == "Init"){
          sInitGroup += link("Sub" + l.at(i), l.at(i), QString("onClick=\"navigate('") + "Sub" + l.at(i) + "')\"") + "<br>";
        } else {
          contents += link("Sub" + l.at(i), l.at(i), QString("onClick=\"navigate('") + "Sub" + l.at(i) + "')\"") + "<br>";
        }        
      }
    }
    contents += sInitGroup;
  }  

  QString s = ""
"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
"<html xmlns=\"http://www.w3.org/1999/xhtml\" dir=\"ltr\">\n"
"<head>\n"
"<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"/>\n"
"<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" media=\"screen\" />\n"
"<title>" + BASIC + "</title>\n"
"</head>\n"
"";
  
  s += body;


  s += "<br><br><p>(C)opyright KBasic Software 2009-2012. All right reserved.</body>";

  
  
  QString QDesktopServices_DesktopLocation;


  QDesktopServices_DesktopLocation = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);
  SaveFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\body.html", s, true);



  
  {
    QString u = LoadFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\Language Reference.html");

    int n = u.indexOf("<title>") + 7;
    int n2 = u.indexOf("</title>");

    u = u.replace(n, n2 - n, BASIC + "'s Language Reference");
    
    SaveFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\Language Reference.html", u, true);
  }
  

  // *** top.html ***
  {
    QString u = LoadFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\top.html");

    int n;
    int n2;

    n = u.indexOf("// SEARCH") + QString("// SEARCH").length();
    n2 = u.indexOf("// END SEARCH");
    u = u.replace(n, n2 - n, "\nvar allsearch = new Array(" + sSEARCH + "'');\n");
    
    n = u.indexOf("<!--SUBSFUNCTIONS-->") + QString("<!--SUBSFUNCTIONS-->").length();
    n2 = u.indexOf("<!--END SUBSFUNCTIONS-->");
    u = u.replace(n, n2 - n, "\n" + sSUBFUNCTION3 + "\n");
    
    n = u.indexOf("<!--OBJECTS-->") + QString("<!--OBJECTS-->").length();
    n2 = u.indexOf("<!--END OBJECTS-->");
    u = u.replace(n, n2 - n, "\n" + sOBJECT3 + "\n");

    n = u.indexOf("<!--CLASSES-->") + QString("<!--CLASSES-->").length();
    n2 = u.indexOf("<!--END CLASSES-->");
    u = u.replace(n, n2 - n, "\n" + sCLASS3 + "\n");

    n = u.indexOf("<!--CONTROLS-->") + QString("<!--CONTROLS-->").length();
    n2 = u.indexOf("<!--END CONTROLS-->");
    u = u.replace(n, n2 - n, "\n" + sCONTROL3 + "\n");

    n = u.indexOf("<!--CONSTANTS-->") + QString("<!--CONSTANTS-->").length();
    n2 = u.indexOf("<!--END CONSTANTS-->");
    u = u.replace(n, n2 - n, "\n" + sCONSTANT3 + "\n");

    SaveFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\top.html", u, true);
  }
  

  // *** left.html ***
  {
    QString u = LoadFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\left.html");

    int n = u.indexOf("<p>") + 3;
    int n2 = u.indexOf("</p>");

    u = u.replace(n, n2 - n, contents);
    
    SaveFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\left.html", u, true);
  }
  

  // *** right.html ***
  {
    QString u = LoadFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\right.html");

    QString common = h2("Common");  

    common += h3("Contents");
    common += rightLink("", "Subs & Functions") + "<br>";
    common += rightLink("", "Objects") + "<br>";
    common += rightLink("", "Classes") + "<br>";
    common += rightLink("", "Inheritance Tree") + "<br>";
    common += rightLink("", "Controls") + "<br>";
    common += rightLink("", "Keywords") + "<br>";
    common += rightLink("", "Types") + "<br>";
    common += rightLink("", "Constants") + "<br>";
    common += rightLink("", "Operators") + "<br>";
    common += rightLink("", "Operator Order") + "<br>";
    common += rightLink("", "Sub-Classing") + "<br>";
    common += rightLink("", "Control Flow & Structure") + "<br>";
    common += rightLink("", "Comments") + "<br>";
    common += rightLink("", "Literals") + "<br>";
    common += rightLink("", "Appendix: Way of naming") + "<br>";
    common += rightLink("", "Appendix: List of " + sNativeLanguage + " Keywords") + "<br>";
    common += rightLink("", "Appendix: Syntax of Arguments") + "<br>";



    common += h3("Class");
    common += rightLink("Class", "QObject") + "<br>";
    common += rightLink("Class", "QWidget") + "<br>";
    common += rightLink("Class", "Module") + "<br>";
    common += rightLink("Class", "Class") + "<br>";
    common += rightLink("Class", "uiClass") + "<br>";
    common += rightLink("Class", "FormClass") + "<br>";

    common += h3("Object");
    common += rightLink("Object", "Application") + "<br>";
    common += "<br>";
    common += rightLink("Object", "Database") + "<br>";
    common += rightLink("Object", "Table") + "<br>";
    common += rightLink("Object", "Records") + "<br>";
    common += rightLink("Object", "Query") + "<br>";
    common += "<br>";
    common += rightLink("Object", "Dir") + "<br>";
    common += rightLink("Object", "File") + "<br>";
    common += rightLink("Object", "Preferences") + "<br>";

    common += h3("Control");
    common += rightLink("Control", "Control") + "<br>";


    int n = u.indexOf("<p>") + 3;
    int n2 = u.indexOf("</p>");

    u = u.replace(n, n2 - n, common);
    
    SaveFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\right.html", u, true);
  }
  

  // *** bottom.html ***
  {
    QString u = LoadFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\bottom.html");

    QString w = "\n";

    for (int i = 0; i < lContents.size(); i++){
       w += QString("<input type=\"button\" value=\"") + lContents.at(i) + "\" onclick=\"navigate('" + lContents.at(i) + "')\">\n"; 
    }

    int n = u.indexOf("<form>") + 6;
    int n2 = u.indexOf("</form>");

    u = u.replace(n, n2 - n, w);
    
    SaveFile(QDesktopServices_DesktopLocation + "\\objb_q7basic\\Documentation\\bottom.html", u, true);
  }
  

  

}







#include "_Q7BCompiler.h"

extern QStringList lNonQObjectClasses;



QStringList Parser::FindFile(QString Path, QStringList NameFilter, bool bRecursiveCall, bool bbb)
{  
  bool bRecursive = true;
  QDir::Filters Filter = QDir::NoFilter;
  

  bool b = bbb;
  if (bRecursive && !(Filter & QDir::AllDirs)){
    b = true;
    Filter |= QDir::AllDirs | QDir::Files;
  }
  
  QFileInfoList l;
  QDir dir;

 

  dir.setPath(Path);
  l = dir.entryInfoList(NameFilter, (QDir::Filters) Filter);

 
  //  dir.setPath(Path);    
  

  //}

  QStringList ll;  

  foreach(QFileInfo f, l){

    bool bb = bRecursive && f.isDir();

    if (!bb || (bb && b == false)){
      ll << f.absoluteFilePath();
    }

    if (bb){

      QString sd = f.fileName();

		  if (f.fileName() == "." || f.fileName() == ".."){
		      ; 
		  } else {

        QStringList ll2 = FindFile(f.absoluteFilePath(), NameFilter, true, b);        
        ll << ll2;        
      }
    }

  }
  return ll;
}


void Parser::createCompilerFiles()
{

}



void Parser::createRuntimeFiles()
{



  QString Q7BRuntime_cpp_Original;
  QString Q7BRuntime_h_Original;

  QString QDesktopServices_DesktopLocation = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation);

  QString Q7BRuntime_cpp = Q7BRuntime_cpp_Original = LoadFile(QDesktopServices_DesktopLocation + "/objb_q7basic/q7b/Runtime/Q7BRuntime.cpp");
  QString Q7BRuntime_h = Q7BRuntime_h_Original = LoadFile(QDesktopServices_DesktopLocation + "/objb_q7basic/q7b/Runtime/Q7BRuntime.h");

  QString c;
  QString h;

  QString sPrefix;

  QStringList l;
  for (int y = 0; y < 2; y++){
    switch(y){
      case 0:
        l = Me.classes.keys();
        sPrefix = "";
        break;
      case 1:
        l = Me.controls.keys();
        sPrefix = "Q7B_";
        break;
    }   

    for (int i = 0; i < l.size(); i++){

       QString sClass = l.at(i);

       if (sClass == "QList<QStringList>"){
         sClass = sClass;
       }
       QString sClass2 = sClass;

       //sClass = sClass.replace("<", ""); // template types
       //sClass = sClass.replace(">", ""); // template types

       if (
         sClass == "Dictionary"
         || sClass == "List"
         || sClass == "QString"
         || sClass == "QStringList"
         //|| sClass == "QWebSettings"
         ) continue;

       if (
         sClass == "Class"
         || sClass == "Module"
         || sClass == "uiClass"         
         || sClass == "FormClass"         
         ) sClass2 = "QObject";


       if (sClass == "PhononSeekSlider") sClass2 = "Phonon::SeekSlider";
       if (sClass == "PhononVideoPlayer") sClass2 = "Phonon::VideoPlayer";
       if (sClass == "PhononVolumeSlider") sClass2 = "Phonon::VolumeSlider";

       if (sClass == "QListQStringList") sClass2 = "QList<QStringList>";

       //sClass = sClass.replace("<", ""); // template types
       //sClass = sClass.replace(">", ""); // template types

      

       sClass2 = sPrefix + sClass2;
       if (y == 1) h += "\nclass " + sClass2 + ";";

       QString k = "Q7B_Object->type == typeid(" + sClass2 + ").name()";


       {
         QString s = "Q7B Q7B_" + sClass.toUpper() + "(Q7B Q7B_Object)";
         h += "\n" + s;
         c += "\n" + s + "\n{\n";
         
         if (!lNonQObjectClasses.contains(sClass)){
           c += "  if (Q7B_Object->type == typeid(" + sClass2 + ").name()) return Q7B_Object;\n";
         } else {
           if (sClass == "Control"){
             c += "  if (qobject_cast<QWidget *>((QWidget* )(Q7B_Object->ref))) return Q7B_Object;\n";
           } else {
             c += "  if (qobject_cast<" + sClass2 + " *>((" + sClass2 + "* )(Q7B_Object->ref))) return Q7B_Object;\n";
           }
         }
         c += "  if (Q7B_nil(Q7B_Object)){\n";
         c += "    return Q7B_Object;\n";
         c += "  }\n";
         c += "  Q7B_CASTEXCEPTION(\"'" + sClass + "' for assignment expected. Tried '\" + QString(Q7B_Object->type) + \"'\");\n";
         c += "  return Q7B_idnil;\n";

         
         c += "}\n";

         h += ";";     
       }
       {
         QString s = "Q7B Q7B__" + sClass.toUpper() + "(Q7B Q7B_Object)";
         h += "\n" + s;
         c += "\n" + s + "\n{\n";

         if (!lNonQObjectClasses.contains(sClass)){
           c += "  if (Q7B_Object->type == typeid(" + sClass2 + ").name()) return Q7B_Object;\n";
         } else {
           if (sClass == "Control"){
             c += "  if (qobject_cast<QWidget *>((QWidget* )(Q7B_Object->ref))) return Q7B_Object;\n";
           } else {
             c += "  if (qobject_cast<" + sClass2 + " *>((" + sClass2 + "* )(Q7B_Object->ref))) return Q7B_Object;\n";
           }
         }

       //  c += "  if (" + k + "){\n"; // TODO2 // folgendes m?sste f?r alle sub classes gemacht werden und nicht nur eigentliche klasse
       //  c += "  }\n";
         c += "  if (Q7B_nil(Q7B_Object)){\n";
         c += "    return Q7B_Object;\n";
         c += "  }\n";
         c += "  Q7B_CASTEXCEPTION(\"'" + sClass + "' for assignment expected. Tried '\" + QString(Q7B_Object->type) + \"'\");\n";
         c += "  return Q7B_idnil;\n";
         c += "}\n";

         h += ";";     
       }

       if (
         sClass != "Class"
         && sClass != "Module"
         && sClass != "uiClass"
         && sClass != "FormClass"
         && sClass != "QWebSettings"
         )
       {         
         QString s = "Q7B Q7B_ID(" + sClass2 + "* o)";
         h += (sClass2 != "QCloseEvent" ? "\n" : "\n") + s; 
         c += "\n" + s + "\n{\n";
         c += "  Q7B q (new Q7B_id(typeid(" + sClass2 + ").name(), o));\n";
         c += "  return q;\n";
         c += "}\n";

         h += ";";   
         
         if (
           !lNonQObjectClasses.contains(sClass)
           && sClass != "QPainter"
           && sClass != "QProcess"
           && sClass != "QRgb"        
           && sClass != "QPlainTextEdit"    

           && sClass != "QColumnView"     
           && sClass != "QHeaderView"     
           && sClass != "QListView"     
           && sClass != "QListWidget"     
           && sClass != "QTableView"     
           && sClass != "QTableWidget"     
           && sClass != "QTreeView"     
           && sClass != "QTreeWidget"     
           && sClass != "QAbstractItemView"   
           && sClass != "QAbstractItemModel"   
           && sClass != "QIntValidator"   
           && sClass != "QLayoutItem"   
           && sClass != "QItemSelectionModel"   
           && sClass != "QDeclarativeView"   
           && sClass != "QGraphicsView"   
           && sClass != "QMdiArea"   
           && sClass != "QScrollArea"   
           && sClass != "QTextEdit"   
           && sClass != "QTextBrowser"   
           && sClass != "QLayout"   
           && sClass != "QBoxLayout"   
           && sClass != "QHBoxLayout"   
           && sClass != "QVBoxLayout"   
           && sClass != "QFormLayout"   
           && sClass != "QGridLayout"   
           && sClass != "QLocalSocket"   
           && sClass != "QStackedLayout"   
           && sClass != "QResource"   
           && sClass != "QPrinter"   
           && sClass != "QSystemTrayIcon"   
           && sClass != "QGraphicsSceneEvent"   
           && sClass != "QDeclarativeContext"   
           
           

         
           
           


           //&& sClass != "QTextDocument"        

           
           
           )
         {        
           s = "Q7B Q7B_ID(" + sClass2 + " o)";
           h += "\n" + s;
           c += "\n" + s + "\n{\n";
           
           c += "  Q7B q (new Q7B_id(typeid(" + sClass2 + ").name(), new " + sClass2 + "(o)));\n";
           c += "  return q;\n";
           c += "}\n";

           h += ";";     
         }

       }       
    }  
  }

  QString sBegin = "// Begin Generator h#1";
  QString sEnd = "// End Generator h#1";

  c.prepend(sBegin);
  h.prepend(sBegin);
  
  c += "\n";
  h += "\n";

  int n = Q7BRuntime_cpp.indexOf(sBegin);
  int n2 = Q7BRuntime_cpp.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_cpp = Q7BRuntime_cpp.replace(n, n2 - n, c);

  n = Q7BRuntime_h.indexOf(sBegin);
  n2 = Q7BRuntime_h.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_h = Q7BRuntime_h.replace(n, n2 - n, h);

  
  

  QString h5;
  QString h6_h;
  QString h6_cpp;

  QString sNonQObjectClasses;
  QString sNonQObjectClasses_CLASSNAME;
  QString sNonQObjectClasses_isQObjectBased;
  {
    QMapIterator<QString, QString> it(Me.classes);
    while (it.hasNext()){
      it.next();

      QString sKey = it.key();

      if (sKey == "List") continue;
      if (sKey == "Dictionary") continue;   
      //if (sKey == "QWebSettings") continue;   // not allowed by Qt/Compiler

      
      QString sKey2 = sKey;

      if (sKey == "QListQStringList") sKey2 = "QList<QStringList>";

      
      //sKey2 = sKey2.replace("<", ""); 
      //sKey2 = sKey2.replace(">", ""); 

      QString sHeader = "Q7B Q7B_" + sKey.toUpper() + "_INIT(QObject *parent, const char *objectName)";
      {
        bool b = true;
                
        if (sKey == "QValidator") b = false;           
        if (sKey == "QAbstractItemModel") b = false;   
        if (sKey == "QAbstractItemView") b = false;   
        if (sKey == "QAbstractButton") b = false;   
        if (sKey == "QAbstractScrollArea") b = false;   
        if (sKey == "QAbstractSlider") b = false;   
        if (sKey == "QAbstractSpinBox") b = false;   
        if (sKey == "QApplication") b = false;   
        if (sKey == "QLayout") b = false;   
        if (sKey == "QSyntaxHighlighter") b = false;   
        if (sKey == "QColumnView") b = false;   
        if (sKey == "QHeaderView") b = false;   
        if (sKey == "QListView") b = false;   
        if (sKey == "QListWidget") b = false;   
        if (sKey == "QTableView") b = false;   
        if (sKey == "QTableWidget") b = false;   
        if (sKey == "QTreeView") b = false;   
        if (sKey == "QTreeWidget") b = false;   
        
        
               
        QString sConstructor;

        if (sKey == "QBoxLayout") sConstructor = "QBoxLayout::LeftToRight";   
        else if (sKey == "QContextMenuEvent") sConstructor = "QContextMenuEvent::Other, QPoint(0, 0)";   
        else if (sKey == "QEvent") sConstructor = "QEvent::None";   
        else if (sKey == "QFocusEvent") sConstructor = "QEvent::None";   
        else if (sKey == "QFontInfo") sConstructor = "QFont()";   
        else if (sKey == "QFontMetrics") sConstructor = "QFont()";   
        else if (sKey == "QInputEvent") sConstructor = "QEvent::None";   
        else if (sKey == "QResizeEvent") sConstructor = "QSize(0, 0), QSize(0, 0)";   
        else if (sKey == "QPaintEvent") sConstructor = "QRect(0, 0, 0, 0)";   

        if (b){
          if (!Q7BRuntime_h.contains("\n" + sHeader)){
            h6_h += "\n" + sHeader + "; // generated";
          }
          if (!Q7BRuntime_cpp.contains("\n" + sHeader)){
            h6_cpp += "\n" + sHeader + " // generated";
            h6_cpp += "\n{\n";
            h6_cpp += "  " + sKey2 + " *o = new " + sKey2 + "(" + sConstructor + ");\n";
            h6_cpp += "  //  o->setProperty(\"Parent\", (qint64) parent);\n";
            h6_cpp += "  //  o->setObjectName(objectName);\n";
            h6_cpp += "  Q7B q (new Q7B_id(typeid(" + sKey2 + ").name(), o, !parent->isWidgetType() )); \n";
            h6_cpp += "  return q;\n";
            h6_cpp += "}\n";       
          }
        }
      }

      if (sKey == "QListQStringList") sKey2 = "QList<QStringList>";

      if (sKey != "Class"
        && sKey != "Module"
        && sKey != "PhononSeekSlider"
        && sKey != "PhononVideoPlayer"
        && sKey != "PhononVolumeSlider"
        && sKey != "uiClass"        
        && sKey != "FormClass"        
      ){
        if (!lNonQObjectClasses.contains(sKey)){ 
          h5 += "\n#define Q7B_ID" + sKey + "(V) (*((" + sKey2 + "*)V->ref))";
        } else {
          h5 += "\n#define Q7B_ID" + sKey + "(V) ((" + sKey2 + "*)V->ref)";
        }
      }

      if (!lNonQObjectClasses.contains(sKey)){    
        sNonQObjectClasses += "\n  } else if (type == typeid(" + sKey2 + ").name()){\n";
        sNonQObjectClasses_CLASSNAME += "\n  } else if (Q7B_Object->type == typeid(" + sKey2 + ").name()){\n";
        sNonQObjectClasses_CLASSNAME += "     return Q7B_ID(\"" + sKey2 + "\");\n";        
        sNonQObjectClasses_isQObjectBased += "\n  } else if (type == typeid(" + sKey2 + ").name()){\n";
        sNonQObjectClasses_isQObjectBased += "     return false;\n";        

        if (sKey == "QCloseEvent") continue; 
        if (sKey == "QFocusEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QPaintEvent") continue; 
        if (sKey == "QResizeEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QWebSettings") continue; 

        if (sKey == "QEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QAccessibleEvent") continue; 
        if (sKey == "QListWidgetItem") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QActionEvent") continue; 
        if (sKey == "QChildEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QDragLeaveEvent") continue; 
        if (sKey == "QDropEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QDynamicPropertyChangeEvent") continue; 
        if (sKey == "QFileOpenEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QGraphicsSceneEvent") continue; 
        if (sKey == "QHelpEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QHideEvent") continue; 
        if (sKey == "QHoverEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QIconDragEvent") continue; 
        if (sKey == "QInputEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QInputMethodEvent") continue; 
        if (sKey == "QMoveEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QShortcutEvent") continue; 
        if (sKey == "QShowEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QStatusTipEvent") continue; 
        if (sKey == "QTimerEvent") continue; // otherwise crash looks like called event is not owner of that pointer
        if (sKey == "QWhatsThisClickedEvent") continue; 
        if (sKey == "QWindowStateChangeEvent") continue; // otherwise crash looks like called event is not owner of that pointer

        sNonQObjectClasses += "     delete (" + sKey2 + " *) ref;\n";        
        
      }
    }
  }

  sBegin = "// Begin Generator h#2";
  sEnd = "// End Generator h#2";

  sNonQObjectClasses.prepend(sBegin);
  
  sNonQObjectClasses += "\n";

  //h5 += "\n";

  n = Q7BRuntime_cpp.indexOf(sBegin);
  n2 = Q7BRuntime_cpp.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_cpp = Q7BRuntime_cpp.replace(n, n2 - n, sNonQObjectClasses);



  sBegin = "// Begin Generator h#8";
  sEnd = "// End Generator h#8";

  sNonQObjectClasses_CLASSNAME.prepend(sBegin);  
  sNonQObjectClasses_CLASSNAME += "\n";

  n = Q7BRuntime_cpp.indexOf(sBegin);
  n2 = Q7BRuntime_cpp.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_cpp = Q7BRuntime_cpp.replace(n, n2 - n, sNonQObjectClasses_CLASSNAME);


  sBegin = "// Begin Generator h#7";
  sEnd = "// End Generator h#7";

  sNonQObjectClasses_isQObjectBased.prepend(sBegin);  
  sNonQObjectClasses_isQObjectBased += "\n";

  n = Q7BRuntime_cpp.indexOf(sBegin);
  n2 = Q7BRuntime_cpp.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_cpp = Q7BRuntime_cpp.replace(n, n2 - n, sNonQObjectClasses_isQObjectBased);



  sBegin = "// Begin Generator h#5";
  sEnd = "// End Generator h#5";

  h5.prepend(sBegin);
  
  h5 += "\n";

  n = Q7BRuntime_h.indexOf(sBegin);
  n2 = Q7BRuntime_h.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_h = Q7BRuntime_h.replace(n, n2 - n, h5);

  
  sBegin = "// Begin Generator h#6";
  sEnd = "// End Generator h#6";

  if (!h6_h.isEmpty()){    
    
    h6_h += "\n";

    n = Q7BRuntime_h.indexOf(sBegin);
    if (n == -1){
      error("generator error");
      return;
    }
    n = Q7BRuntime_h.indexOf("\n", n) + 1;
    Q7BRuntime_h = Q7BRuntime_h.insert(n, h6_h);
  }

  if (!h6_cpp.isEmpty()){
  
    n = Q7BRuntime_cpp.indexOf(sBegin);
    if (n == -1){
      error("generator error");
      return;
    }
    n = Q7BRuntime_cpp.indexOf("\n", n) + 1;
    Q7BRuntime_cpp = Q7BRuntime_cpp.insert(n, h6_cpp);
  }

  

  c = "";
  h = "";

  QStringList ll = Me.classes.keys();
  

  for (int i = 0; i < ll.size(); i++){

    if (ll.at(i) == "Class") continue;
    if (ll.at(i) == "Dictionary") continue;
    if (ll.at(i) == "List") continue;
    if (ll.at(i) == "Module") continue;

    QString sClass = ll.at(i);

    //sClass = sClass.replace("<", ""); // template types
    //sClass = sClass.replace(">", ""); // template types

    c += "  if (*sCast == \"" + ll.at(i) + "\"){ *sCast = \"C" + sClass.toUpper() + "\"; return true; }\n";
  }

  c = "\n" + c;

  sBegin = "// Begin Generator h#3";
  sEnd = "// End Generator h#3";

  c.prepend(sBegin);
  c += "\n";

  n = Q7BRuntime_cpp.indexOf(sBegin);
  n2 = Q7BRuntime_cpp.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_cpp = Q7BRuntime_cpp.replace(n, n2 - n, c);

  

  c = "";
  h = "";

  ll = Me.classes.keys();
  

  for (int i = 0; i < ll.size(); i++){

    QString sClass = ll.at(i);
    QString sClass2 = sClass;

    if (sClass == "Class") continue;
    if (sClass == "Dictionary") continue;
    if (sClass == "List") continue;
    if (sClass == "Module") continue;  
    if (sClass == "uiClass") continue;  
    if (sClass == "FormClass") continue;  
    if (sClass == "QString") continue;  
    if (sClass == "QStringList") continue;  

    if (sClass == "PhononVideoPlayer") sClass2 = "Phonon::VideoPlayer";  
    if (sClass == "PhononSeekSlider") sClass2 = "Phonon::SeekSlider";  
    if (sClass == "PhononVolumeSlider") sClass2 = "Phonon::VolumeSlider";  

    if (sClass == "QListQStringList") sClass2 = "QList<QStringList>";

     //sClass = sClass.replace("<", ""); // template types
     //sClass = sClass.replace(">", ""); // template types


    if (sClass == "QListQStringList"){
      c += sClass2 + " Q7B_C" + sClass.toUpper() + "(Q7B l){ if (l->type == typeid(" + sClass2 + ").name()){ return ( *(" + sClass2 + " *) l->ref ); } Q7B_CASTEXCEPTION(\"'" + sClass + "' expected\"); return " + sClass2 + "(); }\n";
      h += sClass2 + " Q7B_C" + sClass.toUpper() + "(Q7B l);\n";
    } else {
      c += sClass2 + " *Q7B_C" + sClass.toUpper() + "(Q7B l){ if (l->type == typeid(" + sClass2 + ").name()){ return ( (" + sClass2 + " *) l->ref ); } Q7B_CASTEXCEPTION(\"'" + sClass + "' expected\"); return 0; }\n";
      h += sClass2 + " *Q7B_C" + sClass.toUpper() + "(Q7B l);\n";
    }

  }

  c = "\n" + c;
  h = "\n" + h;

  sBegin = "// Begin Generator h#4";
  sEnd = "// End Generator h#4";

  c.prepend(sBegin);
  c += "\n";

  n = Q7BRuntime_cpp.indexOf(sBegin);
  n2 = Q7BRuntime_cpp.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_cpp = Q7BRuntime_cpp.replace(n, n2 - n, c);

  h.prepend(sBegin);
  h += "\n";

  n = Q7BRuntime_h.indexOf(sBegin);
  n2 = Q7BRuntime_h.indexOf(sEnd);
  if (n == -1 || n2 == -1){
    error("generator error");
    return;
  }
  Q7BRuntime_h = Q7BRuntime_h.replace(n, n2 - n, h);

  

  if (Q7BRuntime_cpp != Q7BRuntime_cpp_Original){
    SaveFile("C:/Users/Bernd/Desktop/objb_q7basic/q7b/Runtime/Q7BRuntime.cpp", Q7BRuntime_cpp, false);
  }  
  if (Q7BRuntime_h != Q7BRuntime_h_Original){
    SaveFile("C:/Users/Bernd/Desktop/objb_q7basic/q7b/Runtime/Q7BRuntime.h", Q7BRuntime_h, false);
  }
}

void Parser::createTxtFiles()
{

  QString sPath = "C:/Users/Bernd/Desktop/objb_q7basic/Q7Basic/CopyAll/";

  QDir().mkpath(sPath);

  QStringList l;
  QString s;



  

  SaveFile(sPath + "keyword.txt", Me.keywords.join("\n"), false);  
  l = Me.classes.keys(); SaveFile(sPath + "class.txt", l.join("\n"), false);

  QString sClass2;

  for (int i = 0; i < l.size(); i++){

    QString sClass = l.at(i);

    
    {
      QString sKind = "Property";

      QMapIterator<QString, QString> ii(Me.classes_properties[sClass]); 
      while (ii.hasNext()){
        ii.next();

        QString sName = ii.key();
        QString sArgs = "";
        QString sType = ii.value();

        sClass2 += sClass + ":" + sKind + ":" + sName + ":" + sArgs + ":" + sType + "\n";
      }
    }

    {
      QMapIterator<QString, QStringList> ii(Me.classes_subsfunctions[sClass]); 
      while (ii.hasNext()){
        ii.next();

        QString sName = ii.key();
        QStringList ll = ii.value();
        QString sType = ll.at(0);
        QString sKind;
        if (sType.isEmpty()){
          sKind = "Sub";
        } else {
          sKind = "Function";
        }

        ll.removeAt(0);
        QString sArgs = ll.join(", ");

        sClass2 += sClass + ":" + sKind + ":" + sName + ":" + sArgs + ":" + sType + "\n";
      }
    }
    
    {
      QString sKind = "Event";

      QMapIterator<QString, QStringList> ii(Me.classes_events[sClass]); 
      while (ii.hasNext()){
        ii.next();

        QString sName = ii.key();
        QStringList ll = ii.value();
        QString sType = ll.at(0);
        ll.removeAt(0);
        QString sArgs = ll.join(", ");

        sClass2 += sClass + ":" + sKind + ":" + sName + ":" + sArgs + ":" + sType + "\n";
      }
    }
    
    {
      QString sKind = "Signal";

      QMapIterator<QString, QStringList> ii(Me.classes_signals[sClass]); 
      while (ii.hasNext()){
        ii.next();

        QString sName = ii.key();
        QStringList ll = ii.value();
        QString sType = ll.at(0);
        ll.removeAt(0);
        QString sArgs = ll.join(", ");

        sClass2 += sClass + ":" + sKind + ":" + sName + ":" + sArgs + ":" + sType + "\n";
      }
    }
    
    {
      QString sKind = "Delegate";

      QMapIterator<QString, QStringList> ii(Me.classes_delegates[sClass]); 
      while (ii.hasNext()){
        ii.next();

        QString sName = ii.key();
        QStringList ll = ii.value();
        QString sType = ll.at(0);
        ll.removeAt(0);
        QString sArgs = ll.join(", ");

        sClass2 += sClass + ":" + sKind + ":" + sName + ":" + sArgs + ":" + sType + "\n";
      }
    }

  }

  SaveFile(sPath + "class2.txt", sClass2, false);

  l = Me.objects.keys(); SaveFile(sPath + "object.txt", l.join("\n"), false);
  SaveFile(sPath + "cpp_keyword.txt", Me.cppobjcjava_keywords.join("\n"), false);
  l = Me.constants.keys(); SaveFile(sPath + "const.txt", l.join("\n"), false);
  SaveFile(sPath + "type.txt", Me.types.join("\n"), false);

  {
    s = "";
    l = Me.subsfunctions.keys(); 

    for (int i = 0; i < l.size(); i++){

      QStringList ll = Me.subsfunctions[l.at(i)];

      s += l.at(i) + "(";

      for (int ii = 1; ii < ll.size(); ii++){
        if (ii > 1) s += ", ";
        s += ll.at(ii);
      }
      
      s += ")";
      
      if (!ll.at(0).isEmpty()){
        s += " As ";
        s += ll.at(0);
      }

      s += "\n";

    }

    SaveFile(sPath + "function.txt", s, false);
  }

  {
    s = "";

    l = Me.super_classes.keys(); 

    for (int i = 0; i < l.size(); i++){

      QStringList ll = Me.super_classes[l.at(i)];

      s += l.at(i);

      for (int ii = ll.size() - 1; ii >= 0 ; ii--){
        s += ":";
        s += ll.at(ii);
      }
      
      s += "\n";

    }

    l = Me.objects.keys();

    for (int i = 0; i < l.size(); i++){

      QStringList ll = Me.super_classes[Me.objects[l.at(i)]];

      s += l.at(i);

      for (int ii = ll.size() - 1; ii >= 0 ; ii--){
        s += ":";
        s += ll.at(ii);
      }
      
      s += "\n";

    }

    SaveFile(sPath + "signal_tree.txt", s, false);
  }

  {
    QString sEvents;
    QString sSignals;
    QString sDelegates;

    l = Me.classes_declare_events_signals_delegates.keys(); 

    for (int i = 0; i < l.size(); i++){
      QMap<QString, QString> m = Me.classes_declare_events_signals_delegates[l.at(i)];

      QMapIterator<QString, QString> q(m);
      while (q.hasNext()) {
        q.next();
        QString sType = Me.classes_declaretype_events_signals_delegates[l.at(i)][q.key()];   


        if (sType == "Event"){
          QString sArgs = Me.classes_events[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sEvents += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
        else if (sType == "Signal"){
          QString sArgs = Me.classes_signals[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sSignals += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
        else if (sType == "Delegate"){
          QString sArgs = Me.classes_delegates[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sDelegates += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
      }
    }

    l = Me.controls_declare_events_signals_delegates.keys(); 

    for (int i = 0; i < l.size(); i++){
      QMap<QString, QString> m = Me.controls_declare_events_signals_delegates[l.at(i)];

      QMapIterator<QString, QString> q(m);
      while (q.hasNext()) {
        q.next();
        QString sType = Me.controls_declaretype_events_signals_delegates[l.at(i)][q.key()];


        if (sType == "Event"){
          QString sArgs = Me.controls_events[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sEvents += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
        else if (sType == "Signal"){
          QString sArgs = Me.controls_signals[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sSignals += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
        else if (sType == "Delegate"){
          QString sArgs = Me.controls_delegates[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sDelegates += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }

      }
    }

    l = Me.objects_declare_events_signals_delegates.keys(); 

    for (int i = 0; i < l.size(); i++){
      QMap<QString, QString> m = Me.objects_declare_events_signals_delegates[l.at(i)];

      QMapIterator<QString, QString> q(m);
      while (q.hasNext()) {
        q.next();
        QString sType = Me.objects_declaretype_events_signals_delegates[l.at(i)][q.key()];


        if (sType == "Event"){
          QString sArgs = Me.objects_events[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sEvents += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
        else if (sType == "Signal"){
          QString sArgs = Me.objects_signals[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sSignals += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
        else if (sType == "Delegate"){
          QString sArgs = Me.objects_delegates[l.at(i)][q.key()].join(", ").mid(2);  // remove first ", "
          sDelegates += l.at(i) + ":" + q.key() + "(" + sArgs + ")\n";
        }
      }
    }

    SaveFile(sPath + "event.txt", sEvents, false);
    SaveFile(sPath + "signal.txt", sSignals, false);
    //SaveFile(sPath + "delegate.txt", sDelegates, false);
  }  


}


void generateScanner()
{


}


void print(QStringList l)
{
  QString d;

  for (int i = 0; i < l.size(); i++){
    QString z = l.at(i);
    QString q = z.mid(1);
    if (z == "K\n") d += "[\n]\n";
    else if (z.at(0) == 'K') d += "[" + q + "]";
    else if (z.at(0) == 'I') d += " " + q + " ";
    else if (z.at(0) == 'S') d += " <<<\"" + q + "\">>> ";
    else if (z.at(0) == 'N') d += "{" + q + "}";
    else if (z.at(0) == 'C') d += "|" + q + "|";
  }
  d = d;
}




#include "_Q7BCompiler.h"








QString getAssignmentType(_variableconstant vc)
{
  if (vc.sName == "v"){
    vc.sName = vc.sName;
  }
  if (vc.Array.bEmpty == true) return DEFAULTTYPE;
  return vc.sType;
}

bool Parser::parseAssignment(_statements & ReturnStatements)
{
  _BEGIN_

  bool bMid = false;

  if (parseTerm("Mid")){
    if (parseTerm("$")){} 
    bMid = true;
    if (!parseTerm("(")){ error("( expected"); return false; }
  } 

  if (peekIdentifier(0, "tttt2")){
    bMid = bMid;
  }

  if (Me.nLine == 55){
    Me.nLine = Me.nLine;
  }
    if (Me.nLine == 168 && Me.sFileName == "Module2.QObject.q7b"){
      Me.nLine = Me.nLine;
    }

  _variableconstant Variable;
  _statements VariableStatements;
  if (parseVariableOrObjectIdentifierOrProcedureCall(VariableStatements, Variable, true, false)){


    //Me.sVarNameForOnAction = "this";

    if (Variable.sName == "lUIFiles"){

    

      Variable.sName = Variable.sName;
    }

    _expressions BuiltinObjectOrClassExpression;
    BuiltinObjectOrClassExpression.bReturn = false;

    bool bFakeAlreadyHandled = false;

    if (parseBuiltinClassOrControlOrObject_PropertyOrProcedure(BuiltinObjectOrClassExpression, Variable, VariableStatements, &bFakeAlreadyHandled, true)){
      if (bFakeAlreadyHandled == false){
        ReturnStatements << BuiltinObjectOrClassExpression.Statements << Compiler::push(";");
      }
      return true;
    }

    if (Variable.bConstant){
      error(QString("Constant '%1' must not be changed").arg(Variable.sName)); return false; 
    }

    if (Me.objects.contains(Variable.sName)){ 
      if (peekTerm(".") == true || peekTerm("(") == true){
        _END_
      }
      error(QString("No expression can be assigned to object '%1'").arg(Variable.sName)); return false; 
    }

    if (Variable.sName == "Me"){ 
      if (peekTerm(".") == true){
        _END_
      }

      _END_

      QString token = getToken(Me.nTokenPos);

      error("No expression can be assigned to 'Me'");
      return false;


    }

bool bQObjectPropertyOrKVC = false;
QString sQObjectPropertyOrKVC;


    if (parseQObjectPropertyOrKVC(&sQObjectPropertyOrKVC)){
      bQObjectPropertyOrKVC = true;
      Variable.sType = DEFAULTTYPE;
    }

  

    _expressions MidFromExpression;
    _expressions MidToExpression;
    
		if (bMid){

		  if (!parseTerm(",")){ error(", expected"); return false; }
			if (!parseExpressionInteger(MidFromExpression)){ error(""); return false; }

			if (!parseTerm(",")){ error(", expected"); return false; }
			if (!parseExpressionInteger(MidToExpression)){ error(""); return false; }

			if (!parseTerm(")")){ error(") expected"); return false; }
			
		} 

    if (Variable.sName == "k"){
      Variable.sName = Variable.sName;
    }
	  if (!parseTerm("=")){ _END_ }   

    _expressions Expression;

    if (Me.nLine == 22){
      Me.nLine = Me.nLine;
    }

		if (!parseExpression(Expression)){ error(""); return false; }   
		if (!typeCompatible(Variable.sType, Expression.sType)){ error("types incompatible"); return false; }

    if (bQObjectPropertyOrKVC){
      ReturnStatements << Compiler::push("QObjectPropertyOrKVCAssignment", VariableStatements, Compiler::pushString(sQObjectPropertyOrKVC), Expression.Statements) << Compiler::push(";");
		} else {

		  if (bMid){
	      ReturnStatements << Compiler::push("MidAssignment", VariableStatements, MidFromExpression.Statements, MidToExpression.Statements, Expression.Statements) << Compiler::push(";");
		  } else {
        QString sdaf99 = Compiler::decode(VariableStatements);
        QString sdaf = Compiler::decode(Expression.Statements);
        if (sdaf.contains("type_get")){
          sdaf = sdaf;
        }

        QString sAssignmentType;
        if (Expression.bAlloc == false){
          sAssignmentType = getAssignmentType(Variable);
        }
              ReturnStatements << Compiler::push("Assignment", VariableStatements, Expression.Statements, Compiler::pushIdentifier(sAssignmentType)) << Compiler::push(";");
		  }
		}

    return true;    
  }
  _END_
}






#include "_Q7BCompiler.h"

bool Parser::parseClassConst(_statements & Statements, bool bDeclare)
{
  bool bLocal = false;  
  return parseConst(Statements, bLocal, bDeclare);
}

bool Parser::parseClassDimOutlet(_statements & Statements, bool bDeclare)
{
  bool bLocal = false;  
  return parseDimOutlet(Statements, bLocal, bDeclare);
}  

bool Parser::parseClass(QString sFileName)
{
    Me.sFileName = sFileName;
    Me.nTokenPos = 0;
    Me.nLine = 1;
    Me.nBlock = 0;
    

    _statements ClassStatements;    

    while(Me.nTokenPos < Me.tokens[Me.sFileName].size()){
      if (Me.bError) return false;

      QString token = getToken();

      if (token == "K\n"){ 
        Me.nTokenPos++;
        Me.nLine++;
        continue;
      }

      if (token == "K:"){
        Me.nTokenPos++;
        continue;
      }

      if (token == "K<string>"){
        Me.nTokenPos++;
        Me.nLine++;
        continue;
      }

      if (token.at(0) == 'C'){ 
        Me.nTokenPos++;
        continue;
      }


		  if (peekTerm("Outlet") || peekTerm("Declare") || peekTerm("Global") || peekTerm("Private") || peekTerm("Public") || peekTerm("Sub") || peekTerm("Signal") || peekTerm("Slot") || peekTerm("Event") || peekTerm("Function") || peekTerm("Dim") || peekTerm("Var") || peekTerm("Const") || peekTerm("Property") || peekTerm("Enum") || peekTerm("Type")){
          
          if (getClassName(Me.sFileName) == "Global"){
            Me.sPublicPrivateGlobal = "Public";
          } else {
            Me.sPublicPrivateGlobal = "Public";
          }
          QString sSubFunctionIBActionActionSignalEventDelegateSlot;
          bool bProperty = false;

          if (parseTerm("Private")){
            Me.sPublicPrivateGlobal = "Private";
          } else if (parseTerm("Public")){
            Me.sPublicPrivateGlobal = "Public";

          } else if (parseTerm("Global")){
            Me.sPublicPrivateGlobal = "Global";
          } else if (parseTerm("Property")){
            bProperty = true;
            Me.sPublicPrivateGlobal = "Public";
          }

          bool bDeclare = false;
          if (parseTerm("Declare")){
            bDeclare = true;
          }
      

          Me.SubFunction = _subfunction();


          if (parseTerm("Sub")){
            sSubFunctionIBActionActionSignalEventDelegateSlot = "Sub";
            //if (bDeclare && bPrivate){ error("Declare Sub cannot be private. It is always public."); return false; }
            



          } else if (parseTerm("Signal")){
            if (bProperty){ error("Signal with Property not allowed"); return false; }
            sSubFunctionIBActionActionSignalEventDelegateSlot = "Signal";

            
         
          //    { error("Signal with Declare not allowed yet"); return false; }
          
            
          } else if (parseTerm("Slot")){
            if (bProperty){ error("Slot with Property not allowed"); return false; }

            if (bDeclare){
              { error("Slot with Declare not allowed yet"); return false; }
            }

            { error("Slot not supported yet"); return false; }

            sSubFunctionIBActionActionSignalEventDelegateSlot = "Slot";

            

          } else if (parseTerm("Event")){
            if (bProperty){ error("Event with Property not allowed"); return false; }
            
            sSubFunctionIBActionActionSignalEventDelegateSlot = "Event";
            
            //Me.SubFunction.bLocalSub = false;

          } else if (parseTerm("Function")){
            sSubFunctionIBActionActionSignalEventDelegateSlot = "Function";
            //if (bDeclare && bPrivate){ error("Declare Function cannot be private. It is always public."); return false; }
            
          } else {
          //  bool bIBOutlet = false;
            

            if (parseTerm("Enum")){

              if (bProperty){ error("Enum with Property not allowed"); return false; }

              QString sIdentifier;

              //if (bDeclare && bPrivate){ error("Declare Enum cannot be private. It is always public."); return false; }
              if (bDeclare){

                if (!parseIdentifier(&sIdentifier)){ error("Name of enum expected"); return false; }
                

                if (isCppObjcKeyword(sIdentifier, "Name of enum")) return false;

                QString sConstType = DEFAULTTYPE;
                QString sConstTypeL;
                QString sConstTypeR;
                _type Type;
                if (!parseTerm("As")){ error("As expected"); return false; }
                if (!parseAllType(&sConstType, &sConstTypeL, &sConstTypeR, &Type)){ error(""); return false; }
                Compiler::addReference(getFileNameForClass(sConstType));

                if (!parseTerm("{")){ error("{ expected"); return false; } 

                QStringList EnumNames;

                QString sConst;
                if (!parseIdentifier(&sConst)){ error("at least one Const missing"); return false; }             
                
                if (parseTerm(",")){ 
                  do {

                    if (isCppObjcKeyword(sConst, "Name of enum const")) return false;

                    EnumNames << sConst;                   

                    if (!parseIdentifier(&sConst)){ error("Name of enum element expected"); return false; }

                  } while (parseTerm(","));
                }

                if (!parseTerm("}")){ error("} expected"); return false; } 

                if (parseTerm(";")){  }

                if (!parseReturn()){ error(""); return false; }

                addDeclareEnum(sIdentifier, sConstType, EnumNames);

              } else {
 
                QStringList EnumNames;
                QList<_statements> EnumValues;

                if (!parseIdentifier(&sIdentifier)){ error("identifier expected"); return false; }

                if (isCppObjcKeyword(sIdentifier, "Name of enum")) return false;

                QString sEnumType = "Integer";
                QString sEnumTypeL;
                QString sEnumTypeR;
                _type Type;
                if (parseTerm("As")){ 
                  if (!parseAllType(&sEnumType, &sEnumTypeL, &sEnumTypeR, &Type)){ error(""); return false; }            
                  if (convertType(sEnumType) != "Integer"){ error("enum type name must be an Integer type"); return false; }            
                  Compiler::addReference(getFileNameForClass(sEnumTypeL));
                }

                if (!parseReturn()){ error(""); return false; }

                while (parseReturn());

                QString sConst;
                if (!parseIdentifier(&sConst)){ error("at least one Const missing"); return false; }             
                
                int nCounter = 0;
                
                Me.sParsingPreviousValidEnumName = sIdentifier;

                do {            

                  if (isCppObjcKeyword(sConst, "Name of enum const")) return false;

                  EnumNames << sConst;                  

                  if (parseTerm("=")){ 
                    _expressions Expression;                   
                    if (!parseExpressionInteger(Expression)){ error(""); return false; }                      
                    EnumValues << Expression.Statements;
                  } else {
                    EnumValues << Compiler::pushInteger(nCounter);
                  }

                  if (!parseReturn()){ error(""); return false; }                  

                  while (parseReturn());

                  nCounter++;
                } while (parseIdentifier(&sConst));

                Me.sParsingPreviousValidEnumName = "";                

                if (!parseUntilNextProcecure("End", "Enum")){ error("'End Enum' missing"); return false; }
                
                if (!parseTerm("End")){ error(""); return false; }
                if (!parseTerm("Enum")){ error("'End Enum' expected"); return false; }

                if (Me.nPass == 0){
                  if (existsAllType(sIdentifier)){ error("Enum must not be named like existing type"); return false; }                  
                }

                addEnumType(Me.sFileName, sIdentifier, Me.sPublicPrivateGlobal, EnumNames, EnumValues);

                continue;
              }
                  
              continue;

            } else if (parseTerm("Type")){
              if (bProperty){ error("Type with Property not allowed"); return false; }

              QString sIdentifier;

              QStringList names;
              QStringList types;
              QList<int> sizes;
              QStringList encodings;              

              if (!parseIdentifier(&sIdentifier)){ error("identifier expected"); return false; }

              if (sIdentifier == "type4"){
                sIdentifier = sIdentifier;
              }

              if (existsAllType(sIdentifier)){ error("Type must not be named like existing type"); return false; }                  

              if (isCppObjcKeyword(sIdentifier, "Name of type")) return false;

              if (!parseReturn()){ error(""); return false; }    
              
              while (parseReturn()); 

              QString sField;
              if (!parseIdentifier(&sField)){ error("at least one field missing"); return false; }             
                            
              QList<_array> arrays;
              
              do {   

                 if (isCppObjcKeyword(sField, "Name of field type")) return false;

                  _array Array = parseArrayDimReDim(false);

                  arrays << Array;
                  names << sField;               

                  QString sFieldType = DEFAULTTYPE;
                  if (parseTerm("As")){ 
                

                    if (Me.nPass == 0){

                      if (parseTerm("Global")){
                        sFieldType = "Global";
                        if (!peekTerm(".")){ error(". expected"); return false; }            
                      } else if (!parseIdentifier(&sFieldType)){ error("type name expected"); return false; }            

                      if (parseTerm(".")){
                        QString sFieldType2;
                        if (!parseIdentifier(&sFieldType2)){ error("type name expected"); return false; }            
                        types << sFieldType + "." + sFieldType2;
                      } else {
                        types << sFieldType;
                      }

                    } else {
                      

                      QString sFieldTypeL;
                      QString sFieldTypeR;
                      _type FieldType;

                      if (sField == "d2"){
                        sField = sField;
                      }
                      if (!parseAllType(&sFieldType, &sFieldTypeL, &sFieldTypeR, &FieldType)){ error(""); return false; }            
                      Compiler::addReference(getFileNameForClass(sFieldTypeL));

                    }
                  } else {
                    types << sFieldType;
                  }
                  if (parseTerm("*")){
                    QString sNumber;
                    if (parseNumber(&sNumber)){ 
                      sizes << sNumber.toInt();
                    } else {
                      sizes << -1;
                    }
                  } else {
                    sizes << -1;
                  }                  

                  if (sFieldType == "String"){
                    QString sString;
                    if (parseString(&sString)){ 
                      encodings << sString;                    
                    } else {
                      encodings << "";                    
                    }                                      
                  } else {
                    encodings << "";                    
                  }

                
                  if (!parseReturn()){ error(""); return false; }       

                  while (parseReturn());                  
                
              } while (parseIdentifier(&sField));                           

              if (!parseUntilNextProcecure("End", "Type")){ error("'End Type' missing"); return false; }
              
              if (!parseTerm("End")){ error(""); return false; }
              if (!parseTerm("Type")){ error("'End Type' expected"); return false; }

              addTypeType(Me.sFileName, sIdentifier, Me.sPublicPrivateGlobal, names, types, arrays, sizes, encodings);
                  
              continue;

            } else if (parseTerm("Class")){
              if (bProperty){ error("Class with Property not allowed"); return false; }

              QString sIdentifier;

              if (bDeclare){

                if (!parseString(&sIdentifier)){ error("Name of class expected"); return false; }

                if (Parser::Me.controls.contains(sIdentifier)){ error("Class must be of a built-in object type"); return false; }                  

           
            //      if (existsAllType(sIdentifier)){ error("Class must not be named like existing type"); return false; }                  
             

                QString sSuperClass = DEFAULTCLASS;

                if (parseTerm("SuperClass")){
                  if (!parseString(&sSuperClass)){ error("Name of super class expected"); return false; }                                      
                }

                if (parseTerm("SuperClass")){
                  if (!parseString(&sSuperClass)){ error("Name of super class expected"); return false; }                                      
                }

               QString sDoImport; 


                if (Me.nPass == 0){
                  if (Parser::Me.controls.contains(sSuperClass)){ error("Super class must not be of a built-in object type"); return false; }
                  if (!existsAllType(sSuperClass)){ error("Super class must be an existing type"); return false; }                  


                    Me.DeclareClasses[sIdentifier] = sSuperClass;
                    Me.DeclareClassesFileName[sIdentifier] = Me.sFileName;
                    Me.DeclareClassesImport[sIdentifier] = sDoImport;

                    if (!Me.classes.contains(sIdentifier)){ 
                      Me.DeclareClassesDeclaredInClass[getClassName(Me.sFileName)] << sIdentifier;
                    }
                  }

                if (!parseReturn()){ error(""); return false; }

              } else {
 
                  { error(""); return false; }
              }

              continue;


            } else if (parseClassConst(ClassStatements, bDeclare)){
              continue;

            } else if (parseClassDimOutlet(ClassStatements, bDeclare)){
              continue;

          }

         }

          if (!Me.bError){
            if (bDeclare){ 

              bool bStatic = false;
              if (parseTerm("Static")){
                bStatic = true;
              }
      
              if (!parseDeclareSubFunction(sSubFunctionIBActionActionSignalEventDelegateSlot, bStatic)) return false;
              continue;
            }

            QString sName;
            QString sType;
            _array Array;

            bool bSet = false;
            bool bGet = false;
            if (bProperty){
              if (parseTerm("Set")){ 
                bSet = true; 
              } else if (parseTerm("Get")){ 
                bGet = true; 
              } else {
                error("Name of property procedure must start with 'Set' or 'Get'"); return false; 
              }
              
            }
            
            if (!parseIdentifier(&sName)){ error("identifier expected"); return false; }

            if (bSet){
              sName = "Set" + sName;
            } else if (bGet){
              sName = "Get" + sName;
            }

            
            if (sName.startsWith("_")){ error("Name of procedure must not start with '_'"); return false; }

          if (Me.SubsFunctions[getClassName(Me.sFileName)].contains(sName)){
            Me.SubFunction = Me.SubsFunctions[getClassName(Me.sFileName)][sName];
          } else if (Me.GlobalSubsFunctions.contains(sName)){ 
            Me.SubFunction = Me.GlobalSubsFunctions[sName];
          }
          
          Me.SubFunction.sFileName = Me.sFileName;

          Me.SubFunction.bProperty = bProperty;
       

            Me.SubFunction.sName = sName;
            if (!parseTerm("(")){ error("( expected"); return false; }          

            QString sArgument;
            if (parseIdentifier(&sArgument)){  

              Me.SubFunction.Arguments.clear();

              _argument Argument;
              Argument.sName = sArgument;

              bool bArray = false;

              if ((bArray = parseTerm("["))){
                if (!parseTerm("]")){ error("] expected"); return false; }          
              }

              QString sType;              
              QString sTypeL;              
              QString sTypeR;
              _type Type;

              if (parseTerm("As")){               
                if (!parseAllType(&sType, &sTypeL, &sTypeR, &Type)){ error(""); return false; }          
                Argument.sType = sType;        
                Argument.bIsPointer = false;
              } else if (parseTerm("AsRef")){ 
                if (!parseAllType(&sType, &sTypeL, &sTypeR, &Type)){ error(""); return false; }          
                Argument.sType = sType;              
                Argument.bIsPointer = true;
              } else {
                Argument.sType = DEFAULTTYPE;
                Argument.bIsPointer = false;
              }
              
              Argument.Array.bEmpty = true;

              Me.SubFunction.Arguments.append(Argument);
                     
              while (parseTerm(",")){
                Argument = _argument();

                if (!parseIdentifier(&sArgument)){ error(""); return false; }  
  
                bool bArray = false;

                if ((bArray = parseTerm("["))){
                  if (!parseTerm("]")){ error("] expected"); return false; }          
                }

                Argument.sName = sArgument;
                if (parseTerm("As")){ 
                  if (!parseAllType(&sType, &sTypeL, &sTypeR, &Type)){ error(""); return false; }          
                  Argument.sType = sType;                  
                  Argument.bIsPointer = false;
                                  
                } else if (parseTerm("AsRef")){ 
                  if (!parseAllType(&sType, &sTypeL, &sTypeR, &Type)){ error(""); return false; }          
                  Argument.sType = sType;                  
                  Argument.bIsPointer = true;
                                  
                } else {
                  Argument.sType = DEFAULTTYPE;
                  Argument.bIsPointer = false;
                                 
                }
                
                Argument.Array.bEmpty = true;
              
                Me.SubFunction.Arguments.append(Argument);
              }            
            }

            if (!parseTerm(")")){ error(""); return false; }            

            if (sName == "GetAll"){
                sName=sName;
                 }

            if ( sSubFunctionIBActionActionSignalEventDelegateSlot == "Function" 
              || sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"
              || sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"
            ){
              if (parseTerm("As")){
              
                QString sTypeL;              
                QString sTypeR;
                _type Type;
                if (!parseAllType(&sType, &sTypeL, &sTypeR, &Type)){ error(""); return false; }     
                Array = parseArrayDimReDim(true);

              }
            }

            if (!parseReturn()){ error(""); return false; }

            bool bHasReturnType = !sType.isEmpty();
            Me.SubFunction.sType = sType;

            if (!bHasReturnType && //Me.SubFunction.sName != "Init" && Me.SubFunction.sName != "Finalize" &&
              (
               sSubFunctionIBActionActionSignalEventDelegateSlot == "Function"
         //   || sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"
         //   || sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"
            )
            ){
              Me.SubFunction.sType = DEFAULTTYPE;
            }

            Me.SubFunction.sPublicPrivateGlobal = Me.sPublicPrivateGlobal;
            Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot = sSubFunctionIBActionActionSignalEventDelegateSlot;

            _statements Statements;
            if (Me.nPass == 0){


             
              if (!parseUntilNextProcecure("End", sSubFunctionIBActionActionSignalEventDelegateSlot)){ error("'End " + sSubFunctionIBActionActionSignalEventDelegateSlot + "' missing"); return false; }

            } else {
         
              Statements << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("0")) << Compiler::push(";");         
        
              Me.SubFunction.bExitFunctionUsed = false;
              Me.SubFunction.ExitFunctionVariable.sFileName = Me.SubFunction.sFileName;
              Me.SubFunction.ExitFunctionVariable.sName = Me.SubFunction.sName;
              Me.SubFunction.ExitFunctionVariable.sType = Me.SubFunction.sType;     

              if (!parseStatements(Statements)){ error(""); return false; }

              bool bHasReturnType = !Me.SubFunction.sType.isEmpty();

              if (              
                Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Function"
                || ((bHasReturnType && Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Event")
                || (bHasReturnType && Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"))
              ){
                Statements << Compiler::push("Return ?", Compiler::pushNull());
              }


              Statements << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("2")) << Compiler::push(";");

              if (Me.SubFunction.bExitFunctionUsed){
          
                _statements Expression;
                _statements Array;
                bool bStatic = false;
                bool bType = false;

                _statements StatementsSAVE = Statements;
                Statements.clear();
                Statements << (Compiler::push("Local Dim", Compiler::pushIdentifier(PREFIX + Me.SubFunction.ExitFunctionVariable.sName), Compiler::pushIdentifier(Me.SubFunction.ExitFunctionVariable.sType), Compiler::pushExpression(Expression), Compiler::pushExpression(Array), Compiler::pushIdentifier(bStatic ? "true" : "false"), Compiler::pushBoolean(bType)));          

                Statements << StatementsSAVE;
          
              }           

            }
            
            if (!parseTerm("End")){ error(""); return false; }
        
            if (!parseTerm(sSubFunctionIBActionActionSignalEventDelegateSlot)){ error("'End " + sSubFunctionIBActionActionSignalEventDelegateSlot + "' expected"); return false; }
            
            addSubFunction(sSubFunctionIBActionActionSignalEventDelegateSlot, Me.sFileName, sName, Statements, Me.sPublicPrivateGlobal, Me.SubFunction.Arguments, Me.SubFunction.sType, Array);

            _statements Arguments;

            for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){
              _argument Argument = Me.SubFunction.Arguments.at(i);
              Arguments << Compiler::pushString(Argument.sName);
            }
       
            continue;
          }                
        

      }

      if (Me.nTokenPos != Me.tokens[Me.sFileName].size()){
        error(""); 
        return false;
      }
     
    }     

    Me.ClassStatements[getClassName(Me.sFileName)] = ClassStatements;
    
    return true;
}




#include "_Q7BCompiler.h"



QString Parser::getToken(int nOffset)
{      
  if (Me.nTokenPos + nOffset < Me.tokens[Me.sFileName].size() && Me.nTokenPos + nOffset >= 0){
  
      return Me.tokens[Me.sFileName].at(Me.nTokenPos + nOffset);  
  
  }

  return "";
}

bool Parser::peekReturn(int nOffset)
{      
  QString token = getToken(nOffset);
  if (!token.isEmpty()){
    return token == "K\n";
  }
  return false;
}


bool Parser::peekIdentifier(int nOffset, QString s)
{      
  QString token = getToken(nOffset);
  if (!token.isEmpty()){
    if (token.at(0) == 'I'){
      if (s.isEmpty()){
        return true;
      }
      return token == "I" + s;
    }
  }
  return false;
}

bool Parser::peekTerm(QString s, int nOffset)
{  
  _BEGIN_

  QString token = getToken(nOffset);
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();

    if (c == 'K'){
      QString sToken = token.mid(1, token.length() - 1);
      if (sToken == s){
        _END2_
        return true;
      }
    }

    _END2_
  }
  return false;
}

bool Parser::parseTerm(QString s, bool bAllowSingleColon)
{  
  parseMultiLine();

  QString token = getToken();
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();

    if (c == 'K'){
      QString sToken = token.mid(1, token.length() - 1);
      if (sToken == s){
          

        Me.nTokenPos++;
        return true;
      }
    }

  }

  return false;
}

bool Parser::parseTerm(QString *s)
{  
  parseMultiLine();

  QString token = getToken();
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();


    if (c == 'K'){
      *s = token.mid(1, token.length() - 1);
      Me.nTokenPos++;
      return true;
    }
  }
  return false;
}

bool Parser::parseUntil(QString s, QString s2, QString *s3)
{  
  while(Me.nTokenPos < Me.tokens[Me.sFileName].size()){
    int n = Me.nTokenPos;
    if (parseTerm(s)){
      if (s2.isEmpty() || parseTerm(s2)){ 
        if (s == "\n"){
 
        }
         Me.nTokenPos = n;
        return true;
      }
    } else if (s3){
      
    }

    if (!parseReturn()){
      Me.nTokenPos++;
    }
  }
  return false;  
}

bool Parser::parseUntilNextProcecureHelper()
{  

  while(Me.nTokenPos < Me.tokens[Me.sFileName].size()){
    int n = Me.nTokenPos;


     if (parseTerm("Sub") || parseTerm("Function") || parseTerm("Signal") || parseTerm("Event") || parseTerm("Slot")){

      Me.nTokenPos = n;
      return true;
         
    }
    if (!parseReturn()){
      Me.nTokenPos++;
    }
  }
  return false;  
}

bool Parser::parseUntilNextProcecure(QString s, QString s2)
{  
  int nSaveCurrentLine = Me.nLine;
  _BEGIN_
  if (!parseUntil(s, s2)){ 
    _END2_

    parseUntilNextProcecureHelper();
    
    Me.nLine = nSaveCurrentLine;   
    return false;
  }
  return true;  
}

bool Parser::parseString(QString *sString)
{  
  parseMultiLine();

  QString token = getToken();
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();

    if (c == 'S'){
      *sString = token.mid(1, token.length() - 1);
      

      Me.nTokenPos++;
      return true;
    }
  }
  return false;
}

bool Parser::parseNumber(QString *sNumber)
{  
  parseMultiLine();

  QString token = getToken();
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();

    if (c == 'N'){
      *sNumber = token.mid(1, token.length() - 1);
      Me.nTokenPos++;
      return true;
    }
  }
  return false;
}



bool Parser::parseReturn(bool bColonOnly)
{  
  if (Me.nTokenPos >= Me.tokens[Me.sFileName].size()){
    return false;
  }

  parseMultiLine();

  QString token = getToken();
  if (!token.isEmpty()){
    if (bColonOnly == false && token == "K\n"){
      Me.nTokenPos++;
      Me.nLine++;
      return true;
    }
    if (token == "K:"){
      Me.nTokenPos++;
      return true;
    }
    if (token.at(0) == 'C'){ 
      Me.nTokenPos++;
      
      return true;
    }
  }
  return false;
}

bool Parser::parseComment()
{  
  if (Me.nTokenPos >= Me.tokens[Me.sFileName].size()){
    return false;
  }

  parseMultiLine();

  QString token = getToken();
  if (!token.isEmpty()){
    if (token.at(0) == 'C'){
      Me.nTokenPos++;
      return true;
    }
  }
  return false;
}

void Parser::parseMultiLine()
{

  while (Me.nTokenPos < Me.tokens[Me.sFileName].size() && Me.tokens[Me.sFileName].at(Me.nTokenPos) == "K<string>"){ 
    Me.nTokenPos++;
    Me.nLine++;
  }
  while (Me.nTokenPos < Me.tokens[Me.sFileName].size() && Me.tokens[Me.sFileName].at(Me.nTokenPos) == "K_"){ 
    Me.nTokenPos++;	
    Me.nLine++;
    parseReturn();
  }
}

bool Parser::parseIdentifier(QString *sIdentifier)
{  
  parseMultiLine();  

  QString token = getToken();
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();

    if (c == 'I'){
      *sIdentifier = token.mid(1);
      
      Me.nTokenPos++;
      return true;
    }
  }
  return false;
}

bool Parser::parseIdentifier(QString sIdentifier)
{  
  parseMultiLine();

  if (sIdentifier == "MsgBox"){
    sIdentifier = sIdentifier;
  }

  QString token = getToken();
  if (!token.isEmpty()){
    char c = token.at(0).toLatin1();

    if (c == 'I'){
      if (sIdentifier == token.mid(1)){
        Me.nTokenPos++;
        return true;
      }
    }
  }
  return false;
}

_array Parser::parseArrayDimReDim(bool bEmptyAllowed)
{  
  _array Array;
  

    if (Me.bBlockArrayParsingDueToParseReDim == false && parseTerm("[")){

      bool bFirst = true;
      
      int nCount = 0;
      while (true){
        if (nCount > Q7B_MAX_ARRAYDIM){
          { error("too much dimensions for an array"); break; }
        }
        nCount++;
        
        _expressions Expression;
        if (!parseExpressionInteger(Expression)){ 
          if (bFirst && bEmptyAllowed){
            if (!parseTerm("]")){ error("] expected"); return Array; }
            for (int i = 0; i < Q7B_MAX_ARRAYDIM; i++){ 
              if (i != 0) Array.Statements << Compiler::pushCode(", ");
              Array.Statements << Compiler::pushExpression(Compiler::pushInteger(-1));    
              Array.Statement[i] = Compiler::pushInteger(-1);    
            }
            Array.bEmpty = true;

            Array.Statements = Compiler::pushExpression(Compiler::pushCode(Compiler::decode(Array.Statements)));
            return Array;
          }
          error(""); break; 
        }
        
        if (nCount > 1) Array.Statements << Compiler::pushCode(", ");

//        Array.Statement[Array.nCount] = Compiler::pushExpression(Expression.Statements);                
        Array.Statements << Compiler::pushExpression(Expression.Statements);                
        Array.Statement[Array.nCount] = Compiler::pushExpression(Expression.Statements);                

        Array.nCount++;

        if (!parseTerm(",")){ break; }       

        bFirst = false;

      }
      if (!parseTerm("]")){ error("] expected"); return Array; }

      for (int i = 0; i < Q7B_MAX_ARRAYDIM - Array.nCount; i++){
        Array.Statements << Compiler::pushCode(", ");
        Array.Statements << Compiler::pushExpression(Compiler::pushInteger(-1));            
        Array.Statement[Q7B_MAX_ARRAYDIM - i - 1] = Compiler::pushInteger(-1);            
      }

    
    //  sdfa = sdfa;

      Array.Statements = Compiler::pushExpression(Compiler::pushCode(Compiler::decode(Array.Statements)));
  QString sdaf = Compiler::decode(Array.Statements);
  sdaf = sdaf;

  
    }

  return Array;
}











#include "_Q7BCompiler.h"



bool Parser::parseType(_expressions & ReturnExpression, _statements & VariableStatements, _array VariableArray, _array TypeArray, QString sIdentifier, QString sIdentifier2)
{

  _BEGIN_

  if (sIdentifier.isEmpty() == false || parseIdentifier(&sIdentifier)){

    QString sTypeL;
    QString sTypeR;

    if (sIdentifier.contains(".")){
      sTypeL = sIdentifier.left(sIdentifier.indexOf("."));
      sTypeR = sIdentifier.mid(sIdentifier.indexOf(".") + 1);
    } else {
      sTypeL = sIdentifier;
      sTypeR = "";
    }

    _type Type;

    if (Me.GlobalTypes.contains(sTypeL)){ 
      Type = Me.GlobalTypes[sTypeL];
    } else if (Me.Types.contains(sTypeL) && Me.Types[sTypeL].contains(sTypeR)){ 
      Type = Me.Types[sTypeL][sTypeR];

      // wird folgendes ?berhaupt gebraucht?
    } else if (Me.Types.contains(getClassName(Me.sFileName)) && Me.Types[getClassName(Me.sFileName)].contains(sTypeL)){
      Type = Me.Types[getClassName(Me.sFileName)][sTypeL];
    } else {
      _END_
    }

    Compiler::addReference(Type.sFileName);

    bool bParseArray = sIdentifier2.isEmpty();
    if (sIdentifier2.isEmpty() == false || (parseTerm(".") && parseIdentifier(&sIdentifier2))){
 
       if (bParseArray){
         TypeArray = parseArrayDimReDim(false);
       }


       if (!Type.Names.contains(sIdentifier2)){ error(QString("Type field name '%1' not in type '%2'").arg(sIdentifier2).arg(getClassName(Type.sFileName) + "." + Type.sName)); return false; }   

       _expressions Expression;       
       Expression.Statements << (Compiler::pushExpression(Compiler::pushInteger(Type.Names.indexOf(sIdentifier2))));

       _statements Statements;
       Statements << VariableArray.Statements;

       QString sdf = Compiler::decode(Expression.Statements);

       if (TypeArray.nCount == 0){
         for (int i = 0; i < Q7B_MAX_ARRAYDIM; i++){      
           Expression.Statements << Compiler::pushCode(", ");
           Expression.Statements << Compiler::pushCode("Q7B_ID(-1)");
         }
       } else {
         Expression.Statements << Compiler::pushCode(", ");
         Expression.Statements << TypeArray.Statements;
       }

       Expression.Statements = Compiler::pushExpression(Compiler::pushCode(Compiler::decode(Expression.Statements)));

       if (Me.Types.contains(getClassName(Me.sFileName)) && Me.Types[getClassName(Me.sFileName)].contains(Type.Types.at(Type.Names.indexOf(sIdentifier2)))){
         ReturnExpression.sType = getClassName(Type.sFileName) + "." + Type.Types.at(Type.Names.indexOf(sIdentifier2));
       } else {
         ReturnExpression.sType = Type.Types.at(Type.Names.indexOf(sIdentifier2));
       }

       if (VariableArray.nCount > 0){
         _statements Tests;
         if (VariableStatements.size()){
           ReturnExpression.Statements << Compiler::push("Type Get", Compiler::push("Array At", VariableStatements, Statements), Expression.Statements);
         } else {
           ReturnExpression.Statements = Compiler::push("Type Get", Compiler::push("Array At", ReturnExpression.Statements, Statements), Expression.Statements);
         }   

         




       } else {
         if (VariableStatements.size()){
           ReturnExpression.Statements << Compiler::push("Type Get", VariableStatements, Expression.Statements);
         } else {
           
           ReturnExpression.Statements = Compiler::push("Type Get", ReturnExpression.Statements, Expression.Statements);
         }      
       }

        _array TypeArray2 = Type.Arrays.at(Type.Names.indexOf(sIdentifier2));

       _statements Dummy;
       _array VariableArray2;
       QString sIdentifier3;
      
         if (parseType(ReturnExpression, Dummy, VariableArray2, TypeArray2, ReturnExpression.sType)){ 
            return true;
         }
      
      
       return true;
    }
     
  }
  
  _END_
}

bool Parser::parseObjectIdentifier(_statements & ReturnStatements, _variableconstant & Variable)
{    
  _BEGIN_

  if (parseTerm("Global")){ 
    Variable.sName = "Global";
    Variable.sType = "Global";

    ReturnStatements << Compiler::pushObject(Variable.sName);
    return true;
  }

  if (Me.nLine == 30){
    Me.nLine = Me.nLine;
  }

  QString sIdentifier;
  if (parseIdentifier(&sIdentifier)){ 

    if (sIdentifier == "qApp"){ 
      sIdentifier = "Application";
    }

    if (Me.objects.contains(sIdentifier)){
    
      Variable.sName = sIdentifier;    
      Variable.sType = sIdentifier;

      ReturnStatements << Compiler::pushObject(Variable.sName);
      return true;

    }


  }

  _END_
}

bool Parser::parseProcedure_Call(_expressions & ReturnExpression, QString sClass, QString sIdentifier, QString *sType, bool bPrependSelf)
{
  _BEGIN_

  bool bbb = false;

  if (sIdentifier.isEmpty()){
    bbb = true;
  }
  if (sIdentifier.isEmpty() == false || parseIdentifier(&sIdentifier)){
    if (bbb){
      bbb = bbb;
    }

    if (Me.nLine == 395){
      Me.nLine = Me.nLine;
    }

    if (Me.nLine == 20 && Me.sFileName == "Global.QObject.q7b"){
      Me.nLine = Me.nLine;
    }

    if (sIdentifier == "setText"){
			 sIdentifier = sIdentifier;
		}

    if (parseTerm("(")){

       QList<_expressions> expressions;
       QStringList argumentNames;

       QString sArgumentName;
      _expressions Expression;

      if (peekTerm(":=", 1) == false && peekTerm(":=", 2) == false && parseExpression(Expression)){  
        argumentNames << "";
        expressions << Expression;
        goto r;
      } else {
        if (parseIdentifier(&sArgumentName)){             
          if (!parseTerm(":=")){ 
            _END_ 
          } // error(""); return false; }     //  := expected              
          if (!parseExpression(Expression)){ error(""); return false; } 

          argumentNames << "";
          expressions << Expression;

r:          
          while (parseTerm(",")){
            Expression = _expressions();

            sArgumentName = "";
            if (peekTerm(":=", 1) == false && peekTerm(":=", 2) == false && parseExpression(Expression)){  
              argumentNames << "";
              expressions << Expression;
              goto r;
            } else {
              if (!parseIdentifier(&sArgumentName)){ error(""); return false; }                     
              if (!parseTerm(":=")){ error(""); return false; }      
              if (!parseExpression(Expression)){ error(""); return false; }      

              argumentNames << sArgumentName;
              expressions << Expression;
            }
          }            
        }
      }

      if (!parseTerm(")")){ error(""); return false; }

      if (sIdentifier == "setRange"){
        sIdentifier = sIdentifier;
      }

      QMap<QString, _subfunction> SubsFunctions;

      bool bImplicitGlobalObject = false;
      bool bGlobalKeyword = false;
      QString sGlobalKeywordClass;

      if (!sClass.isEmpty()){

        if (sIdentifier == "insertPlainText"){
          sIdentifier = sIdentifier;
        }
        if (sIdentifier == "setText"){
          sIdentifier = sIdentifier;
        }

        bool bNotFound = true;
        QString sClassSave = sClass;

        do {
          if ((sClass.isEmpty() || !Me.DeclareClasses.contains(sClass)) && Me.Classes.contains(sClass)){
            sClass = Me.Classes[sClass];
            
          }
		      if (sIdentifier == "FindType"){
			     sIdentifier = sIdentifier;
		      }

          if (Me.DeclareSubsFunctions.contains(sClass) && Me.DeclareSubsFunctions[sClass].contains(sIdentifier)){
            SubsFunctions[sIdentifier] = Me.DeclareSubsFunctions[sClass][sIdentifier];

			   if (sIdentifier == "setStyleSheet"){
			     sIdentifier = sIdentifier;
		      }


            if (!Me.classes.contains(sClass) && !Me.controls.contains(sClass)){
              Compiler::addReferenceToClass(getClassName(Me.DeclareSubsFunctions[sClass][sIdentifier].sFileName)); 
              Compiler::addReferenceToClass(sClass); 
            }
            bNotFound = false;
            break;

          } else {
            if (sClass.isEmpty() || !Me.DeclareClasses.contains(sClass)){
              break;
            }
            sClass = Me.DeclareClasses[sClass];
          }
        } while (true);        

        if (bNotFound){
          sClass = sClassSave;

          SubsFunctions = Me.SubsFunctions[sClass];
          if (!SubsFunctions.contains(sIdentifier)){ 
            return false;
          }
        }
        
        if (sClass == "Global"){
          _subfunction sf = SubsFunctions[sIdentifier];
          if (sf.sPublicPrivateGlobal == "Private"){ error(QString("Procedure '%1' is private in Global object and must not be used outside its class").arg(sIdentifier)); return false; }
        }
        
      } else {

        
        if (Me.DeclareSubsFunctions[""].contains(sIdentifier)){ 
          SubsFunctions[sIdentifier] = Me.DeclareSubsFunctions[""][sIdentifier];         
        } else {

          
          SubsFunctions = Me.SubsFunctions[getClassName(Me.sFileName)]; 
          if (!SubsFunctions.contains(sIdentifier)){ 

            
            SubsFunctions = Me.SubsFunctions["Global"];         
            if (!SubsFunctions.contains(sIdentifier)){ 

              
              if (!Me.GlobalSubsFunctions.contains(sIdentifier)){ 

                return false;
              } else {
                SubsFunctions[sIdentifier] = Me.GlobalSubsFunctions[sIdentifier];         
                bGlobalKeyword = true;
              }
            } else{
              bImplicitGlobalObject = true;
              _subfunction sf = SubsFunctions[sIdentifier];
              if (sf.sPublicPrivateGlobal == "Private"){ error(QString("Procedure '%1' is private in Global object and must not be used outside its class").arg(sIdentifier)); return false; }          
            }
            
          } else {
            _subfunction sf = SubsFunctions[sIdentifier];
            if (Me.SubFunction.sPublicPrivateGlobal == "Global" && sf.sPublicPrivateGlobal != "Global"){ error(QString("Procedure '%1' is part of a class and not in global space (sub or function declared with keyword 'Global'). You may directly use it with CLASSNAME.PROCEDURENAME, if it is public declared.").arg(sIdentifier)); return false; }          
          }
        }
      }

      _subfunction sf = SubsFunctions[sIdentifier];      

      if (Me.sFileName != sf.sFileName && sf.sPublicPrivateGlobal == "Private"){ error(QString("Procedure '%1' is private and must not be used outside its class").arg(sIdentifier)); return false; }
      if (sf.bCallAble == false){ error("Procedure " + sIdentifier + " must not directly called in code"); return false; }

      
      //int bb = expressions.size();
      if (sf.Arguments.size() < expressions.size()){ error("too many arguments given"); return false; }
      else if (sf.Arguments.size() > expressions.size()){ error("not enough arguments given"); return false; }

      _statements Statements;

      for (int i = 0; i < expressions.size(); i++){

        _statements Statements88 = expressions.at(i).Statements;
        QString saf = Compiler::decode(Statements88);

        if (sf.bDeclare){
          QString sCast = convertDeclareType(convertDeclareType(sf.Arguments.at(i).sType), 1);


          if(!sf.Arguments.at(i).sNamedAs.isEmpty()) Statements << Compiler::pushExpression(Compiler::pushCode(" " + sf.Arguments.at(i).sNamedAs));
          Statements << Compiler::pushExpression(Compiler::pushCode(sCast + "(" + Compiler::decode(Statements88) + ")"));

        } else {
          Statements << Compiler::pushExpression(Statements88);        
        }
        
      }

      QString sTypeHelper;

      if (sf.bDeclare){
        for (int i = 0; i < expressions.size(); i++){
            QString asdf = sf.Arguments.at(i).sType;
            QString asddf = expressions.at(i).sType;
            QString as = sf.Arguments.at(i).sType;
            QString a88 = expressions.at(i).sType;
          if (!typeCompatible(convertDeclareType(sf.Arguments.at(i).sType), expressions.at(i).sType)){ error(QString("#%1 argument: argument type of %2 incompatible with given expression").arg(i + 1).arg(sf.Arguments.at(i).sName)); return false; }
        }

        QString saf = Compiler::decode(Statements);
 
        QString sProcedureName;

        if (sf.sDeclareAlias.isEmpty()) sProcedureName = sIdentifier;
        else sProcedureName = sf.sName;

        ReturnExpression.Statements << Compiler::push("DeclareCall", Compiler::pushIdentifier(sProcedureName), Statements);
        ReturnExpression.bDeclareUsed = true;

        sTypeHelper = convertDeclareType(sf.sType);

      } else {      
        for (int i = 0; i < expressions.size(); i++){
          if (!typeCompatible(sf.Arguments.at(i).sType, expressions.at(i).sType)){ error(QString("#%1 argument: argument type of %2 incompatible with given expression").arg(i + 1).arg(sf.Arguments.at(i).sName)); return false; }
        }

        if (bImplicitGlobalObject){

            ReturnExpression.Statements << Compiler::pushObjectRef("Global", Compiler::pushObject("Global")) << Compiler::push("->") << Compiler::push("Call", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sGlobalKeywordClass), Compiler::pushIdentifier(ReturnExpression.bReturn ? "true" : "false"), Statements);
        } else if (bGlobalKeyword){
          sGlobalKeywordClass = getClassName(sf.sFileName);

          ReturnExpression.Statements << Compiler::push("Call", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sGlobalKeywordClass), Compiler::pushIdentifier(ReturnExpression.bReturn ? "true" : "false"), Statements);
        } else {
          QString sadf = Compiler::decode(Statements);


          if (CONFIG["VM"] == "true"){
            if (sf.sFileName == Me.sFileName){
              ReturnExpression.Statements << Compiler::pushMe();
            }
          }
          ReturnExpression.Statements << Compiler::push("Call", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sGlobalKeywordClass), Compiler::pushIdentifier(ReturnExpression.bReturn ? "true" : "false"), Statements);
        }

        sTypeHelper = sf.sType;
      }

      if (ReturnExpression.bReturn == false){
        ReturnExpression.Statements << Compiler::push(";");
      }

      ReturnExpression.sType = sTypeHelper;
      if (sType) *sType = sTypeHelper;

      Compiler::addReference(sf.sFileName);

      return true;      
   }

  }

  _END_



}

bool Parser::parseQObjectPropertyOrKVC(QString *sQObjectPropertyOrKVC)
{
  if (parseTerm("!")){

    _BEGIN_



    if (parseIdentifier(sQObjectPropertyOrKVC)){
       return true;
    }




    _END_
  }
  return false;
}

bool Parser::parseMe(_statements & ReturnStatements)
{      
  if (parseTerm("Me")){    
    return true;
  }
  return false;
}

bool Parser::parseEnum(_expressions & Expression, QString sIdentifier, QString sIdentifier2)
{      
  _BEGIN_

  if (sIdentifier.isEmpty() == false || parseIdentifier(&sIdentifier)){   

   if (sIdentifier2.isEmpty() == false || parseTerm(".")){

      bool b = sIdentifier2.isEmpty();
      if (sIdentifier2.isEmpty() == false || parseIdentifier(&sIdentifier2)){

        QString sIdentifier3;
        if (b || parseTerm(".")){

          if (b || parseIdentifier(&sIdentifier3)){

            QString sClass;
            QString s1;
            QString s2;

            if (b){
              sClass = getClassName(Me.sFileName);
              s1 = sIdentifier;
              s2 = sIdentifier2;
            } else {
              sClass = sIdentifier;
              s1 = sIdentifier2;
              s2 = sIdentifier3;
            }

            _enumeration Enum;

            if (Me.GlobalEnums.contains(s1)){ 
              Enum = Me.GlobalEnums[sIdentifier];     
            } else if (Me.Enums.contains(sClass) && Me.Enums[sClass].contains(s1)){ 
              Enum = Me.Enums[sClass][s1];     
            } else if (Me.Enums.contains("Global") && Me.Enums["Global"].contains(s1)){ 
              Enum = Me.Enums["Global"][s1]; 
            } else {
              _END_
            }

            Compiler::addReference(Enum.sFileName);

            if (Enum.EnumNames.contains(s2)){
              if (!(Enum.sPublicPrivateGlobal == "Private" && getClassName(Me.sFileName) != sClass)){
                Expression.sType = "Integer";
                Expression.Statements << Enum.EnumValues.at(Enum.EnumNames.indexOf(s2));
                return true;      
              } else {
                { error(QString("%1 is an element of the private enum %2").arg(s2).arg(sClass + "." + s1)); return false; }
              }
            } else {
              { error(QString("%1 not an element of %2").arg(s2).arg(sClass + "." + s1)); return false; }
            }
          }
        }
      }     
    }    
  }   
  _END_
}

bool Parser::parseProperty(_statements & ReturnStatements, _variableconstant & Variable, QString sClass, bool bReturn)
{      
  
  if (bReturn && Me.SubsFunctions[sClass].contains("Get_" + Variable.sName)){
    
    QString sGlobalKeywordClass;
    _expressions Expression;
    ReturnStatements << Compiler::push("Call", Compiler::pushIdentifier("Get_" + Variable.sName), Compiler::pushIdentifier(sGlobalKeywordClass), Compiler::pushIdentifier(bReturn ? "true" : "false"), Expression.Statements);
    return true;

  
  } else if (!bReturn && Me.SubsFunctions[sClass].contains("Set_" + Variable.sName)){    
    if (!parseTerm("=")){ error("= missing"); return false; }     

    _expressions Expression;
    if (!parseExpression(Expression)){ error(""); return false; }   
    if (!typeCompatible(Variable.sType, Expression.sType)){ error("types incompatible"); return false; }

    QString sGlobalKeywordClass;
    ReturnStatements << Compiler::push("Call", Compiler::pushIdentifier("Set_" + Variable.sName), Compiler::pushIdentifier(sGlobalKeywordClass), Compiler::pushIdentifier(bReturn ? "true" : "false"), Expression.Statements);
    ReturnStatements << Compiler::push(";");
    return true;
  }

  return false;
}

bool Parser::parseVariable(_statements & ReturnStatements, _variableconstant & Variable, _statements & VariableStatements, QString sClass, bool bReturn, bool bStandaloneVariableAllowed)
{    
  _BEGIN_
bool bClassWasEmpty = sClass.isEmpty();

  if (Me.nLine == 55){
    Me.nLine = Me.nLine;
  }

  if (bStandaloneVariableAllowed && sClass.isEmpty() && parseMe(ReturnStatements)){

    if (Me.SubFunction.sPublicPrivateGlobal == "Global"){ error(QString("'Me' must not be used in global space (sub or function declared with keyword 'Global')")); return false; }          

    Variable.sName = "Me";
    Variable.sType = getClassName(Me.sFileName);

    ReturnStatements << Compiler::pushMe();

    return true;
  }

  if (Me.nLine == 10){
    Me.nLine = Me.nLine;
  }

  QString sIdentifier;
  if (parseIdentifier(&sIdentifier)){ 

    _array Array = parseArrayDimReDim(false);
    if (Array.nCount > 0){
      Me.bCheckArrayDimension = true;
    }

    if (sIdentifier == "d3"){
//    if (sIdentifier == "global_s"){
      sIdentifier = sIdentifier;
    }
    if (sIdentifier == "Menu"){
//    if (sIdentifier == "global_s"){
      sIdentifier = sIdentifier;
    }
    if (bStandaloneVariableAllowed && Me.isLocal()){

      if (sClass.isEmpty()){

        
        for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){

          _argument Argument = Me.SubFunction.Arguments.at(i);

          if (Argument.sName == sIdentifier){
            Variable.sName = Argument.sName;
            Variable.sType = Argument.sType;
            Variable.Array = Argument.Array;
            Variable.ArrayAccess = Array;

            if (Me.bCheckArrayDimension && Variable.ArrayAccess.nCount > 0 && Variable.ArrayAccess.nCount != Variable.Array.nCount && Variable.Array.bEmpty == false){ error("array dimension count not equal"); return false; }                                             
            Me.bCheckArrayDimension = false;            

            ReturnStatements << Compiler::push("Argument", Compiler::pushIdentifier(Variable.sName));
          
            Compiler::addReference(getFileNameForClass(Variable.sType));
            return true;
          }

        }

        
        QMap<int, int> possibleLocalVars;
        for (int i = 0; i < Me.SubFunction.VariablesConstants.size(); i++){

          _variableconstant vc = Me.SubFunction.VariablesConstants.at(i);

          if (vc.sName == sIdentifier && vc.nBlock <= Me.nBlock){
             possibleLocalVars[vc.nBlock] = i;
          }
        }

        
        QMapIterator<int, int> ii(possibleLocalVars);
        ii.toBack();
        while (ii.hasPrevious()){
            ii.previous();

            

            int i = ii.value();

            _variableconstant vc = Me.SubFunction.VariablesConstants.at(i);

            if (vc.sName == sIdentifier){

              Variable = vc;
              Variable.ArrayAccess = Array;

              if (Me.bCheckArrayDimension && Variable.ArrayAccess.nCount > 0 && Variable.ArrayAccess.nCount != Variable.Array.nCount && Variable.Array.bEmpty == false){ error("array dimension count not equal"); return false; }                                             
              Me.bCheckArrayDimension = false;                                        

              ReturnStatements << Compiler::push("Local Variable", Compiler::pushIdentifier(Variable.sName), Compiler::pushBoolean(bReturn));

              QString saf = Compiler::decode(ReturnStatements);

              Compiler::addReference(getFileNameForClass(Variable.sType));
              return true;
            }
        }


      }    
    }
    if (bStandaloneVariableAllowed && sClass.isEmpty()){

        if (Me.DeclareClasses.contains(sIdentifier) && peekTerm(".")){ // peekTerm(".") is needed for a working autoInit
          Variable = _variableconstant();
          Variable.sType = sIdentifier;

          ReturnStatements << Compiler::pushCode(sIdentifier + "::");

          Compiler::addReferenceToClass(getClassName(Me.DeclareClassesFileName[sIdentifier])); 
          return true;
        }

      if (Me.DeclareConstValues.contains(sIdentifier)){
        Variable = _variableconstant();
        Variable.sType = Me.DeclareConstTypes[sIdentifier];

        QString sCast;

        if (Variable.sType == "Integer") sCast = "(qint64) ";
        else if (Variable.sType == "Boolean") sCast = "(bool) ";
        else if (Variable.sType == "Float" || Variable.sType == "Single" || Variable.sType == "Double") sCast = "(qreal) ";

        ReturnStatements << Compiler::pushCode(PREFIX + "ID(" + sCast + sIdentifier + ")");

        Compiler::addReference(Me.DeclareConstValues[sIdentifier]);
        return true;
      }

      if (Me.DeclareEnumConsts2.contains(sIdentifier)){
        Variable = _variableconstant();
        Variable.sType = Me.DeclareEnumTypes[Me.DeclareEnumConsts2[sIdentifier]];

        QString sCast;

        if (Variable.sType == "Integer") sCast = "(qint64) ";
        else if (Variable.sType == "Boolean") sCast = "(bool) ";
        else if (Variable.sType == "Float" || Variable.sType == "Single" || Variable.sType == "Double") sCast = "(qreal) ";

        ReturnStatements << Compiler::pushCode(PREFIX + "ID(" + sCast + sIdentifier + ")");

        Compiler::addReference(Me.DeclareEnums[Me.DeclareEnumConsts2[sIdentifier]]);
        return true;
      }
    }

    QString sUseClass = sClass;
    if (sUseClass.isEmpty()) sUseClass = getClassName(Me.sFileName);
    if (!sUseClass.contains(".")){

      
      if (Me.VariablesConstants[sUseClass].contains(sIdentifier)){
        _variableconstant vc = Me.VariablesConstants[sUseClass][sIdentifier];

        QString sdf = getClassName(Me.SubFunction.sFileName);
        if (vc.sPublicPrivateGlobalLocal == "Private" && getClassName(Me.SubFunction.sFileName) != getClassName(vc.sFileName)){ error(QString("Variable or constant '%1' is private and must not be used outside its class").arg(vc.sName)); return false; }

        if (Me.SubFunction.sPublicPrivateGlobal == "Global" && vc.sPublicPrivateGlobalLocal != "Global" && sClass.isEmpty()){ error(QString("Variable or constant '%1' is part of a class and not in global space (sub or function declared with keyword 'Global')").arg(vc.sName)); return false; }          
        
        Variable = vc;
        Variable.ArrayAccess = Array;

        if (Me.bCheckArrayDimension && Variable.ArrayAccess.nCount > 0 && Variable.ArrayAccess.nCount != Variable.Array.nCount && Variable.Array.bEmpty == false){ error("array dimension count not equal"); return false; }                                             
        Me.bCheckArrayDimension = false;                    

        
        if (!sClass.isEmpty()){
          if (parseProperty(ReturnStatements, Variable, sClass, bReturn)){
            return true;
          }
        }

        Compiler::addReference(getFileNameForClass(sUseClass));
        
        if (CONFIG["VM"] == "true"){ 
          if (sClass.isEmpty()){
            ReturnStatements << Compiler::pushMe();
          }
        }

        ReturnStatements << Compiler::push("Class Variable", Compiler::pushIdentifier(Variable.sName));
        return true;
      }

      
      if (bStandaloneVariableAllowed && Me.VariablesConstants["Global"].contains(sIdentifier)){
        _variableconstant vc = Me.VariablesConstants["Global"][sIdentifier];

        if (vc.sPublicPrivateGlobalLocal == "Private"){ error(QString("Variable or constant '%1' is private in global object and must not be used outside its class").arg(vc.sName)); return false; }

        Variable = vc;
        Variable.ArrayAccess = Array;

        if (Me.bCheckArrayDimension && Variable.ArrayAccess.nCount > 0 && Variable.ArrayAccess.nCount != Variable.Array.nCount && Variable.Array.bEmpty == false){ error("array dimension count not equal"); return false; }                                             
        Me.bCheckArrayDimension = false;                    

        
        if (!sClass.isEmpty()){
          if (parseProperty(ReturnStatements, Variable, sClass, bReturn)){
            return true;
          }
        }

        Compiler::addReference(getFileNameForClass("Global"));        

        ReturnStatements << Compiler::pushObjectRef("Global", Compiler::pushObject("Global")) << Compiler::push("->") << Compiler::push("Class Variable", Compiler::pushIdentifier(Variable.sName));        
        return true;
      }

      
      if (sClass.isEmpty()){
 //       QString dsf = ((QStringList)Me.Classes.keys()).join(" ");
        if (Me.Classes.contains(sIdentifier) ){ 

          Variable.sName = "";
          Variable.sType = sIdentifier;

          Compiler::addReference(getFileNameForClass(sIdentifier));

          ReturnStatements << Compiler::push("Class Singleton", Compiler::pushIdentifier(sIdentifier));        
          return true;
        }
      }
    }

    _expressions Expression;
    if (!sClass.isEmpty() && parseEnum(Expression, sClass, sIdentifier)){
      Variable.sName = "Enum";
      Variable.sType = Expression.sType;

      ReturnStatements << Expression.Statements;
     
      return true;
    }

    if (parseType(Expression, VariableStatements, Variable.ArrayAccess, Array, sClass, sIdentifier)){
      Variable.sName = "Type";
      Variable.sType = Expression.sType;

      ReturnStatements << Expression.Statements;
      return true;
    }

    
    if (bStandaloneVariableAllowed && sClass.isEmpty()){
      if (Me.GlobalVariablesConstants.contains(sIdentifier)){
        _variableconstant vc = Me.GlobalVariablesConstants[sIdentifier];

        Variable = vc;
        Variable.ArrayAccess = Array;

        if (Me.bCheckArrayDimension && Variable.ArrayAccess.nCount > 0 && Variable.ArrayAccess.nCount != Variable.Array.nCount && Variable.Array.bEmpty == false){ error("array dimension count not equal"); return false; }                                             
        Me.bCheckArrayDimension = false;            

        
        if (!sClass.isEmpty()){
          if (parseProperty(ReturnStatements, Variable, sClass, bReturn)){
            return true;
          }
        }

        Compiler::addReference(Variable.sFileName);

        ReturnStatements << Compiler::push("Global Variable", Compiler::pushIdentifier(Variable.sName), Compiler::pushIdentifier(getClassName(vc.sFileName)));        
        return true;
      }   
    }

    if (bStandaloneVariableAllowed && Me.isLocal()){

      if (bClassWasEmpty){
        
        if (!peekTerm("(") && !peekTerm(".")){
          if (sIdentifier == Me.SubFunction.ExitFunctionVariable.sName){

            Me.SubFunction.bExitFunctionUsed = true;

            Variable.sName = Me.SubFunction.ExitFunctionVariable.sName;
            Variable.sType = Me.SubFunction.ExitFunctionVariable.sType;
            Variable.Array = Me.SubFunction.ExitFunctionVariable.Array;
            Variable.ArrayAccess = Me.SubFunction.ExitFunctionVariable.Array;

            if (Me.bCheckArrayDimension && Variable.ArrayAccess.nCount > 0 && Variable.ArrayAccess.nCount != Variable.Array.nCount && Variable.Array.bEmpty == false){ error("array dimension count not equal"); return false; }
            Me.bCheckArrayDimension = false;

            ReturnStatements << Compiler::push("ExitFunctionVariable");

            Compiler::addReference(getFileNameForClass(Variable.sType));
            return true;
          }
        }
      }
    }

  }

  _END_  
}

QStringList Parser::SubFunction(QString s) 
{
  QStringList l;

  if (s.isEmpty()) return l;
  
  if (s.startsWith("{")){
    s = s;
  }
  if (s.contains("=")){
    s = s;
  }

  QStringList ll = s.split(",");
  for (int i = 0; i < ll.size(); i++){
    QString k = ll.at(i).trimmed();
    l << k;   
  }
  
  return l;
}

QString getArgumentName(QString s)
{
  int n = s.indexOf(" As ");
  if (n >= 0) return s.left(n).trimmed();

  return s;
}

QString getArgumentType(QString s)
{
  int n = s.indexOf(" As ");
  if (n >= 0) s = s.mid(n + 4).trimmed();
  n = s.indexOf(" = ");
  if (n >= 0) return s.left(n).trimmed();
  n = s.indexOf("[");
  if (n >= 0){
    s = s.left(n).trimmed();
  }
  n = s.indexOf("]");
  if (n >= 0){
    s = s.left(n).trimmed();
  }

  if (s.contains("::")) return "Integer";
  if (s.contains(".")) return "Integer";

  return s;
}

QString getArgumentDefaultValue(QString s)
{
  QString q;
  int n = s.indexOf(" As ");
  if (n >= 0) s = s.mid(n + 4).trimmed();
  n = s.indexOf(" = ");
  if (n >= 0) q = s.mid(n + 3).trimmed();


  if (q == "True") q = "true";
  else if (q == "False") q = "false";
  else if (q == "Me") q = "this";


  else if (q == "Dir.NoFilter") q = "QDir::NoFilter";
  else if (q == "Dir.NoSort") q = "QDir::NoSort";  
  else if (q == "InputDialog.Normal") q = "QLineEdit::Normal";  
  else if (q == "MessageBox.NoButton") q = "QMessageBox::NoButton";  
  else if (q == "MessageBox.Ok") q = "QMessageBox::Ok";  
  else if (q == "Database.LocalHost") q = "\"localhost\"";  
  else if (q == "Database.DefaultOptions") q = "\"\"";  
  else if (q == "Database.DefaultPort") q = "\"\"";  
  else if (q == "QTableWidget.MatchExactly") q = "Qt::MatchExactly";  

  if (!q.isEmpty()){
    if (q.contains(".")){
        bool ok = false;
        q.toDouble(&ok);
        if (ok) return PREFIX + "ID((double) " + q + ")";
    }
    bool ok = false;
    q.toInt(&ok);

    if (ok) return PREFIX + "ID((qint64) " + q + ")";

    return PREFIX + "ID(" + q + ")";
  }
  return "";
}

_statements getArgumentOptionalValue(QString s)
{
  if (s == "Integer") return Compiler::pushInteger(0);
  if (s == "Float") return Compiler::pushFloat(0.0);
  if (s == "Boolean") return Compiler::pushBoolean(false);
  if (s == "String") return Compiler::pushString("");
  return Compiler::pushNull();
}

bool Parser::parseBuiltin_Procedure(QString sIdentifier, QStringList & Arguments, _expressions & ReturnExpression)
{    
  _BEGIN_

  ReturnExpression.sType = Arguments.at(0);

  if (Me.nLine == 31){
    Me.nLine = Me.nLine;
  }

  
  if (Arguments.size() == 1){
    if (parseTerm("(")){ 
      if (!parseTerm(")")){ _END_ } 
    }
    
    return true;
  }




  if (!parseTerm("(")){  _END_ } 

  bool bDefaultValues = false;

  for (int i = 0; i < Arguments.size() - 1; i++){

    QString sArgument = Arguments.at(i + 1);

    bool bOptional = sArgument.endsWith("[") || sArgument.endsWith("]");

    _expressions Expression;

    if (i != 0){
      if (bDefaultValues || !parseTerm(",")){ 
        if (bOptional || Arguments.at(i + 1).contains("=")){
          bDefaultValues = true;

          if (bOptional){
            ReturnExpression.Statements << Compiler::pushExpression(getArgumentOptionalValue(getArgumentType(Arguments.at(i + 1))));            
          } else {
            ReturnExpression.Statements << Compiler::pushExpression(Compiler::pushCode(getArgumentDefaultValue(Arguments.at(i + 1))));            
          }
          
          continue;
        } else {
           _END_  
        }
      }
    }

 




//    if (!parseExpression(Expression)){ 
    bool b = false;
    if (peekTerm(":=", 1) == false && peekTerm(":=", 2) == false && parseExpression(Expression)){  
      b = true;
    }

    if (b == false){
      QString sDummy;
      if (parseIdentifier(&sDummy)){             
        if (!parseTerm(":=")){ 
          _END_ 
        } 
        if (parseExpression(Expression)){ 
          b = true;
        } 
      }
    }

    if (b == false){

      if (i == 0 && (bOptional || bDefaultValues || Arguments.at(i + 1).contains("="))){

        if (bOptional){
          ReturnExpression.Statements << Compiler::pushExpression(getArgumentOptionalValue(getArgumentType(Arguments.at(i + 1))));            
        } else {    
          ReturnExpression.Statements << Compiler::pushExpression(Compiler::pushCode(getArgumentDefaultValue(Arguments.at(i + 1))));            
        }

        continue;
      } else {
         _END_  
      }
     
    } else if (!typeCompatible(Expression.sType, getArgumentType(Arguments.at(i + 1)))){   _END_ } 


    ReturnExpression.Statements << Compiler::pushExpression(Expression.Statements);

    
    //int sadf99 = Compiler::pushExpression(Expression.Statements).size();
    
   // QString sdf = Compiler::decode(ReturnExpression.Statements);
   

  }

  if (!parseTerm(")")){  _END_ } 
    
  return true;
}

bool Parser::parseBuiltinClassControlObject_Procedure(QString *sProcedure, _expressions & Expression, QMap<QString, QStringList> & procedures)
{
  _BEGIN_

  {
    

    int n = 1;
    QString sTest = *sProcedure;
    while (procedures.contains(sTest)){
      _expressions Expression2 = Expression;
      if (!parseBuiltin_Procedure("", procedures[sTest], Expression2)){
        sTest = *sProcedure + QString("%1").arg(++n); 
        continue;
      }
      *sProcedure = sTest;
      Expression = Expression2;
      Expression.sType = procedures[sTest][0];
      if (Expression.bReturn && Expression.sType.isEmpty()){ _END_ }
      goto re;
    }  
  }

  _END_
re:
  return true;
}

bool Parser::parse(QString sFileName)
{
  return parseClass(sFileName);
}

bool Parser::parseLocalConst(_statements & Statements)
{
  bool bLocal = true;
  bool bDeclare = false;
  return parseConst(Statements, bLocal, bDeclare);
}

bool Parser::parseLocalDim(_statements & Statements)
{
  bool bLocal = true;
  bool bDeclare = false;
  return parseDimOutlet(Statements, bLocal, bDeclare);
}  

bool Parser::parseConst(_statements & Statements, bool bAddLocalConstant, bool bDeclare)
{
       
 if (parseTerm("Const")){
   if (Me.SubFunction.bProperty){ error("Const with Property not allowed"); return false; }

    QString sIdentifier;

    ////if (bDeclare && bPrivate){ error("Declare Const cannot be private. It is always public."); return false; }
    if (bDeclare){

      if (!parseIdentifier(&sIdentifier)){ error("Name of const expected"); return false; }
      
      if (existsAllType(sIdentifier)){ error("Constant must not be named like existing type"); return false; }

      if (isCppObjcKeyword(sIdentifier, "Name of constant")) return false;
      
      QString sConstType = DEFAULTTYPE;
      QString sConstTypeL;
      QString sConstTypeR;
      _type Type;
      if (!parseTerm("As")){ error("As expected"); return false; }
      if (!parseAllType(&sConstType, &sConstTypeL, &sConstTypeR, &Type)){ error(""); return false; }
      Compiler::addReference(getFileNameForClass(sConstType));

      if (parseTerm(";")){  }

      if (!parseReturn()){ error(""); return false; }
      
      addDeclareConst(sIdentifier, sConstType);
      return true;

    } else {

      _expressions Expression; 
      if (!parseIdentifier(&sIdentifier)){ error("identifier expected"); return false; }

      QString sConstType = DEFAULTTYPE;
      QString sConstTypeL;
      QString sConstTypeR;
      _type Type;
      if (parseTerm("As")){ 
        if (!parseAllType(&sConstType, &sConstTypeL, &sConstTypeR, &Type)){ error(""); return false; }            
        Compiler::addReference(getFileNameForClass(sConstType));
      }

      if (!parseTerm("=")){ error("= expected"); return false; } 
      if (Me.nPass == 0){
        if (!parseUntil("\n")){ error(""); return false; }
      } else {
        if (!parseExpression(Expression)){ error(""); return false; }
        if (!typeCompatible(sConstType, Expression.sType)){ error("types incompatible"); return false; }
      }

      if (!Me.types.contains(sConstType)){
        { error("Const must be of an built-in type"); return false; }
      }

      if (Me.isLocal()){

        bool bConstant = true;
        _array Array;
        bool bStatic = false;
        bool bType = false;
        addLocalVariable(sIdentifier, sConstType, bConstant, Expression.Statements, Array, bStatic);   

        if (Me.nPass == 1) Statements << Compiler::push("Local Dim", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sConstType), Compiler::pushExpression(Expression.Statements), Compiler::pushExpression(Array.Statements), Compiler::pushIdentifier(bStatic ? "true" : "false"), Compiler::pushBoolean(bType));          

      } else {

        bool bConst = true;
        _array Array;
        bool bIBOutlet = false;
        bool bSet = false;
        bool bType = false;

        addVariable(sIdentifier, sConstType, Me.sPublicPrivateGlobal, bConst, bIBOutlet, Array, bSet);     

        if (Me.sPublicPrivateGlobal == "Global"){
          if (Me.nPass == 1) Statements << Compiler::push("Global Dim", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sConstType), Compiler::pushExpression(Expression.Statements), Compiler::pushExpression(Array.Statements), Compiler::pushIdentifier(getClassName(Me.sFileName)), Compiler::pushBoolean(bType));          
        } else {
          if (Me.nPass == 1) Statements << Compiler::push("Class Dim", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sConstType), Compiler::pushExpression(Expression.Statements), Compiler::pushExpression(Array.Statements), Compiler::pushBoolean(bType), Compiler::pushBoolean(bIBOutlet));
        }

        if (!parseReturn()){ error(""); return false; }

      }        
      return true;
    }
 }

 return false;

}

bool Parser::parseDimOutlet(_statements & ReturnStatement, bool bAddLocalVariable, bool bDeclare)
{

  bool bIBOutlet = false;
  bool bReDim = false;
  bool bStatic = false;


  if (Me.nLine == 19){
    Me.nLine = Me.nLine;
  }



      if ((Me.isLocal() == false && (bIBOutlet = parseTerm("Outlet")))
        || parseTerm("Dim")
        || parseTerm("Var")
        || (Me.isLocal() == true && (bReDim = parseTerm("ReDim")))
        || (Me.isLocal() == true && (bStatic = parseTerm("Static")))){
     
        if (Me.SubFunction.bProperty && !bIBOutlet){ error("Dim with Property not allowed"); return false; }
        if (Me.SubFunction.bProperty && bIBOutlet){ error("Outlet with Property not allowed"); return false; }

        if (bDeclare && bIBOutlet){
          { error("IBOutlet with Declare not allowed"); return false; }
        } else if (bDeclare && bIBOutlet){
          { error("Dim with Declare not allowed"); return false; }
        }

dimredim:
        if (bIBOutlet){
          bIBOutlet = bIBOutlet;
        }
        bool bPreserve = false;

        QString sIdentifier;     
        _statements ReDimVariableStatements;
        _variableconstant ReDimVariable;

        if (bReDim){
          bPreserve = parseTerm("Preserve");
          
          Me.bBlockArrayParsingDueToParseReDim = true;
          if (!parseVariableOrObjectIdentifierOrProcedureCall(ReDimVariableStatements, ReDimVariable, false, true)){
            { error("Variable to use for ReDim must be declared with 'Dim' or 'Var'"); return false; }              
          }
          Me.bBlockArrayParsingDueToParseReDim = false;

        } else if (bStatic){
          if (!parseTerm("Dim") && !parseTerm("Var")){ error("'Dim' or 'Var' expected"); return false; }  
        }
        
        if (bReDim == false){
          if (!parseIdentifier(&sIdentifier)){ error("identifier expected"); return false; }

          if (sIdentifier == "aQ7BFormDesigner"){
            sIdentifier = sIdentifier;
          }
          if (existsAllType(sIdentifier)){ error("Variable must not be named like existing type"); return false; }
          if (isCppObjcKeyword(sIdentifier, "Name of variable")) return false;
          Me.sVarNameForOnAction = sIdentifier;
        }      

        if (sIdentifier ==("vq")){
          sIdentifier = sIdentifier;
        }        
        _array Array = parseArrayDimReDim(!bReDim || !Me.isLocal());        

        bool bSet = false;         

        			       
        QString sType = DEFAULTTYPE;
        QString sTypeL;
        QString sTypeR;
        _type Type;

        if (sIdentifier == "t3"){
          sIdentifier = sIdentifier;
        }

        if (!bReDim && parseTerm("As")){
          if (!parseAllType(&sType, &sTypeL, &sTypeR, &Type)){ 
            if (sType == DEFAULTTYPE) error("no type given"); 
            else error(sTypeL + (sTypeR.isEmpty() ? "" : "." + sTypeR) + " not a valid type or private or you need to write CLASSNAME.TYPENAME or unknown type"); 
            return false; 
          }            
          Compiler::addReference(getFileNameForClass(sType));
        }

        _expressions Expression; 

        bool bType = false;
        
        if (sIdentifier == "dummy"){
          sIdentifier = sIdentifier;
        }

        if (Me.nPass == 0){
          if (!parseUntil("\n")){ error(""); return false; }
        } else {
          if (!bReDim && !bIBOutlet && parseTerm("=")){ 

            if (Me.nLine == 216){
              sIdentifier = sIdentifier;
            }
            if (!parseExpression(Expression)){ error(""); return false; }

            if (Array.isValid()){ error("Assignment expression not allowed when [] are used"); return false; }
            if (!typeCompatible(sType, Expression.sType)){ error("types incompatible"); return false; }
          }     

          if (!bReDim && !bIBOutlet && Expression.Statements.size() == 0 && Array.isValid() == false){
            _statements Statements;
            bool bMustMatch = false;
            bool bParseBrackets = false;


            if (Me.nLine == 980){
              Me.nLine = Me.nLine;
            }

            if (sIdentifier=="dummy"){
              sIdentifier=sIdentifier;

            }
            if (!autoInitForType(Statements, sIdentifier, sType, sTypeL, sTypeR, &bType, Array, bMustMatch, &bParseBrackets)){ 
              error("internal error: autoInitForType failed"); return false; 
            }

            Expression.Statements = Statements;              
          } else if (!bReDim && !bIBOutlet && Expression.Statements.size() == 0 && Array.isValid()){
            _statements Statements;
            if (typeArrayInit(Statements, sIdentifier, Type, sType, Array)){
               Expression.Statements = Statements;                                
            }
          }
        }

        if (bStatic && (bType || Array.isValid())){ error("variables with array with a user defined type must not be static"); return false; }          
          
          
          if (bIBOutlet){
            bSet = parseTerm("Set");  
            
            if (bSet){
                if (parseIdentifier(&sType)){  
                }
                //if (!Me.controls.contains(sType)){ error("control type for Set is invalid"); return false; }
            }
          }
    
    {
      //sType = sType.replace("<", "").replace(">", ""); // template data type

      if (bAddLocalVariable){

        if (bStatic && bType){
          { error("Static declared local variables must not be of an user defined Type..End Type"); return false; }
        }

        if (sIdentifier == "tt2"){
          sIdentifier = sIdentifier;
        }

        if (bReDim){

//          if (Array.nCount != ReDimVariable.Array.nCount){ error("ReDim must have same count of dimension"); return false; }

          
          //QString sd99f = Compiler::decode(ReDimVariableStatements);

          ReturnStatement << Compiler::push("Array ReDim", ReDimVariableStatements, Compiler::pushBoolean(bPreserve), Array.Statements) << Compiler::push(";");

        } else {
          

          bool bConst = false;
          addLocalVariable(sIdentifier, sType, bConst, Expression.Statements, Array, bStatic);     

          QString sadf = Compiler::decode(Array.Statements);

          
          if (Me.nPass == 1) ReturnStatement << Compiler::push("Local Dim", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sType), Compiler::pushExpression(Expression.Statements), Compiler::pushExpression(Array.Statements), Compiler::pushIdentifier(bStatic ? "true" : "false"), Compiler::pushBoolean(bType || Array.isValid()));          
        }

      } else {

        bool bConst = false;            

        addVariable(sIdentifier, sType, Me.sPublicPrivateGlobal, bConst, bIBOutlet, Array, bSet);     
      
        if (Me.sPublicPrivateGlobal == "Global"){
          if (Me.nPass == 1) ReturnStatement << Compiler::push("Global Dim", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sType), Compiler::pushExpression(Expression.Statements), Compiler::pushExpression(Array.Statements), Compiler::pushIdentifier(getClassName(Me.sFileName)), Compiler::pushBoolean(bType || Array.isValid()));          
        } else {
          if (Me.nPass == 1) ReturnStatement << Compiler::push("Class Dim", Compiler::pushIdentifier(sIdentifier), Compiler::pushIdentifier(sType), Compiler::pushExpression(Expression.Statements), Compiler::pushExpression(Array.Statements), Compiler::pushBoolean(bType || Array.isValid()), Compiler::pushBoolean(bIBOutlet));
        }
      }
    }
    
    
    if (bReDim == false && bReDim == false && parseTerm(",")){
      goto dimredim;
    }

     if (!parseReturn()){ error(""); return false; }

      return true;
    }
               
    return false;
}

bool Parser::existsUDFType(QString sType)
{
  if (Me.GlobalTypes.contains(sType)) return true;
  if (Me.Types.contains("Global") && Me.Types["Global"].contains(sType)) return true;

  if (sType.contains(".")){
    QString l = sType.left(sType.indexOf("."));
    QString r = sType.mid(sType.indexOf(".") + 1);
    if (Me.Types.contains(l) && Me.Types[l].contains(r)) return true;
  }
  return false;
}


bool Parser::existsAllType(QString sType, QString *sReturnType)
{
  
  if (Me.types.contains(sType)) return true;
  if (Me.classes.contains(sType)){
    return true;
  }
  if (Me.controls.contains(sType)) return true;

  
  if (Me.Classes.contains(sType)) return true;

  if (Me.nPass == 0){
    if (Me.GlobalEnums.contains(sType)) return true;
    if (Me.Enums.contains("Global") && Me.Enums["Global"].contains(sType)) return true;
    if (Me.Enums.contains(getClassName(Me.sFileName)) && Me.Enums[getClassName(Me.sFileName)].contains(sType)) return true;

    if (Me.GlobalTypes.contains(sType)) return true;
    if (Me.Types.contains("Global") && Me.Types["Global"].contains(sType)) return true;
    if (Me.Types.contains(getClassName(Me.sFileName)) && Me.Types[getClassName(Me.sFileName)].contains(sType)) return true;
  }

  
  if (Me.DeclareClasses.contains(sType)) return true;  
  if (Me.DeclareEnums.contains(sType)){
    if (sReturnType && Me.DeclareEnumConsts2.contains(sType)) *sReturnType = Me.DeclareEnumConsts2[sType]; 
    else if (sReturnType && Me.DeclareEnumTypes.contains(sType)) *sReturnType = Me.DeclareEnumTypes[sType]; 

    Compiler::addReference(Me.DeclareEnums[sType]);
    return true;  
  }

  return false;
}

bool Parser::parseAllType(QString *sType, QString *sTypeL, QString *sTypeR, _type *Type, bool bLookUpOnly)
{

  bool bParse = true;

  if (bLookUpOnly == false){
    if (parseTerm("Global")){ 
      *sType = "Global";
      bParse = false;
    }
  }

  if (bLookUpOnly || bParse == false || parseIdentifier(sType)){
    if (bLookUpOnly == false){
      *sTypeL = *sType;
      *sTypeR = "";
    }    
    
    if (Me.nPass == 1){

      if ((bLookUpOnly && !sTypeL->isEmpty() && !sTypeR->isEmpty()) || parseTerm(".")){
        
        if (bLookUpOnly || parseIdentifier(sTypeR)){
  
          
          if (Me.Enums.contains(*sTypeL) && Me.Enums[*sTypeL].contains(*sTypeR)){

            _enumeration e = Me.Enums[*sTypeL][*sTypeR];
            if (getClassName(e.sFileName) != getClassName(Me.sFileName) && e.sPublicPrivateGlobal == "Private"){
              return false;
            }

            *sType = "Integer";
            return true;           
          }

          
          if (Me.Types.contains(*sTypeL) && Me.Types[*sTypeL].contains(*sTypeR)){

            *Type = Me.Types[*sTypeL][*sTypeR];
            if (getClassName(Type->sFileName) != getClassName(Me.sFileName) && Type->sPublicPrivateGlobal == "Private"){
              return false;
            }

            *sType = *sTypeL + "." + *sTypeR;            
            return true;           
          }		   

        }        

      } else {

        if (*sType == "type3"){
          *sType = *sType;
        }

        

        if (existsAllType(*sType, sType)){          
          return true;
        }

        if (Me.GlobalEnums.contains(*sType)){ 
          *sType = "Integer";
          *sTypeL = getClassName(Me.GlobalEnums[*sType].sFileName); 
          return true;           
        }

        if (Me.Enums.contains(getClassName(Me.sFileName)) && Me.Enums[getClassName(Me.sFileName)].contains(*sType)){ 
          *sTypeL = getClassName(Me.sFileName);
          *sType = "Integer";
          return true;           
        }

        if (Me.Enums.contains("Global") &&Me.Enums["Global"].contains(*sType) && Me.Enums["Global"][*sType].sPublicPrivateGlobal == "Public"){ 
          *sType = "Integer";
          return true;           
        }      

        if (Me.GlobalTypes.contains(*sType)){ 
          *sTypeL = getClassName(Me.GlobalTypes[*sType].sFileName); 
          *Type = Me.GlobalTypes[*sType];
          return true;           
        }

        if (Me.Types.contains("Global") && Me.Types["Global"].contains(*sType) && Me.Types["Global"][*sType].sPublicPrivateGlobal == "Public"){ 
          *Type = Me.Types["Global"][*sType];
          *sType = QString("Global") + "." + *sType;                   
          return true;           
        }   

        if (Me.Types.contains(getClassName(Me.sFileName)) && Me.Types[getClassName(Me.sFileName)].contains(*sType)){ 
          *Type = Me.Types[getClassName(Me.sFileName)][*sType];
          *sTypeL = getClassName(Me.sFileName);
          *sType = *sTypeL + "." + *sType;          
          return true;           
        }

        return false;
      }
    }
   
    return true;
  }  

  return false;
}




#include "_Q7BCompiler.h"


bool Parser::parseVariableOrObjectIdentifierOrProcedureCall(_statements & ReturnStatements, _variableconstant & Variable, bool bAssignment, bool bReturn)
{    
  _BEGIN_


   _statements Statements;
   _statements Dummy;

   if (Me.nLine == 20 && Me.sFileName == "Global.QObject.q7b"){
     Me.nLine = Me.nLine;
   }

  if (parseObjectIdentifier(Statements, Variable) || parseVariable(Statements, Variable, Dummy, "", bReturn)){
   QString qw44tt4333333e = Compiler::decode(Variable.Array.Statements);

   if (Variable.sName == "bbb2"){
     Variable = Variable;
   }

   _statements ReturnStatements2;

   QString sArray;
   if (bReturn){
     sArray = "Array Get";
   } else {
     sArray = "Array At";
   }

   if (Me.nLine == 124 && Me.sFileName == "Module1.QObject.q7b"){
     Me.nLine = Me.nLine;
   }

    do {

      if (Me.nLine == 15){
        Me.nLine = Me.nLine;
      }
      int nSavePos = Me.nTokenPos;
      if (!parseTerm(".")){
        if (Variable.ArrayAccess.nCount > 0){
         
          ReturnStatements2 << Compiler::push(sArray, Statements, Variable.ArrayAccess.Statements);
          Variable.ArrayAccess.nCount = 0;
        } else {
          ReturnStatements2 << Statements;
        }
        Statements.clear();
        break;
      }

      _expressions ReturnExpression;    
      ReturnExpression.bReturn = bReturn;

      QString sName = Variable.sName;
      QString sClass = Variable.sType;
      QString sType;
      QString sIdentifier;

      _variableconstant Variable2 = Variable;
      _variableconstant Variable3 = Variable;

      bool bStandaloneVariableAllowed = false;

      _statements Statements2;
      if (parseVariable(Statements2, Variable, Statements, Variable.sType, bReturn, bStandaloneVariableAllowed)){
        
        if (Variable.sName == "Enum"){
          ReturnStatements << Statements2;
          return true;
        }

        if (Variable.sName == "Type"){      
          QString sdaf = Compiler::decode(Statements2);
          ReturnStatements << Statements2;
        //  if (!peekTerm(".")){
            return true;
         
         
        } else {

          if (Statements.size() > 0){

            if (Variable2.Array.nCount > 0){
              if (Me.types.contains(sClass)){
                ReturnStatements2 << Compiler::push(sArray, Statements, Variable2.Array.Statements); 
              } else {
                ReturnStatements2 << Compiler::push(sArray, Compiler::pushObjectRef(sClass, Statements), Variable2.Array.Statements); 
              }     
              
            } else {
              if (Me.types.contains(sClass)){
                ReturnStatements2 << Statements;
              } else {
                ReturnStatements2 << Compiler::pushObjectRef(sClass, Statements);
              }          
            }

            Statements.clear();
          }

          //if (sName != "Me") 
          ReturnStatements2 << Compiler::push("->");

          if ((Me.types.contains(Variable.sType) || Me.classes.contains(Variable.sType)) || peekTerm(".") == false){
            ReturnStatements2 << Statements2;
          } else {
            ReturnStatements2 << Statements2;

            if (Me.classes.contains(Variable.sType) || Me.controls.contains(Variable.sType)){      
              ReturnStatements2 = Compiler::pushObjectRefDirectCast(Variable.sType, ReturnStatements2);
            } else {
              ReturnStatements2 = Compiler::pushObjectRef(Variable.sType, ReturnStatements2);
            }            
          }     
        }

      } else if (bAssignment == false && parseIdentifier(&sIdentifier) && parseProcedure_Call(ReturnExpression, sClass, sIdentifier, &sType, false)){

        bool bDeclareHandlingFunctionCall = false;
     
  
        _statements ReturnStatements3;

        if (Statements.size() > 0){
          if (sClass == "QPlainTextEdit"){
            sClass = sClass;
          }
          
               QString qw33e = Compiler::decode(ReturnStatements3);
        if (Variable.Array.nCount > 0){
          QString qw44tt433e = Compiler::decode(Variable3.ArrayAccess.Statements);
           QString qw44tt43553e = Compiler::decode(Statements);
          Statements = Compiler::push(sArray, Statements, Variable3.ArrayAccess.Statements);
           Variable.ArrayAccess.nCount = 0;
        } else {
         
        }
       
          {
               
            if (Me.types.contains(sClass)){
                QString qwe = Compiler::decode(Statements);
              ReturnStatements3 << Statements;
            } else {
              if (Me.DeclareSubsFunctions.contains(sClass)){ 

                if (Me.classes.contains(sClass) || Me.controls.contains(sClass)){      
                  QString qwe = Compiler::decode(Statements);
                


                  ReturnStatements3 << Compiler::pushObjectRefDirectCast(sClass, Statements);


                
                 // bDoPointer = false;

                } else {


                  if (ReturnExpression.bReturn){
                    bDeclareHandlingFunctionCall = true;
                    ReturnStatements3 << Compiler::pushCode(PREFIX + "ID(");
                  }
                  ReturnStatements3 << Compiler::pushObjectRef(sClass, Statements);
                }

              } else {
                ReturnStatements3 << Compiler::pushObjectRef(sClass, Statements);
              }
            }

          }

          Statements.clear();
        }

        
   if (Me.nLine == 181 && Me.sFileName == "Module1.QObject.q7b"){
     Me.nLine = Me.nLine;
   }


        QString qw4448833e = Compiler::decode(ReturnStatements2);
 
        QString qw8944433e = Compiler::decode(ReturnStatements3);
 
        if (ReturnStatements2.size() > 0){
          if (Me.classes.contains(Variable.sType) || Me.controls.contains(Variable.sType)){      
            ReturnStatements2 = Compiler::pushObjectRefDirectCast(Variable.sType, ReturnStatements2);
          } else {
           
          }            
        }

        QString qw44433e = Compiler::decode(ReturnStatements2);
 
        ReturnStatements2 << ReturnStatements3;
        
        {
         // if (sName != "Me") 

          
            ReturnStatements2 << Compiler::push("->");
            ReturnStatements2 << ReturnExpression.Statements;
       }
        QString qw444333333e = Compiler::decode(ReturnStatements2);

        if (bDeclareHandlingFunctionCall == true){
          ReturnStatements2 << Compiler::pushCode(")");
        }

        Variable.sName = ""; 
        Variable.sType = sType;
      } else {   
        Me.nTokenPos = nSavePos;
        break;
      }

    } while (true);

    if (Variable.ArrayAccess.nCount > 0){
      QString sdaf1 = Compiler::decode(Variable.ArrayAccess.Statements);
      QString sdaf2 = Compiler::decode(ReturnStatements2);
      QString sdaf3 = Compiler::decode(Statements);
      QString sdaf4 = Compiler::decode(ReturnStatements);
      ReturnStatements2 << Compiler::push(sArray, Statements, Variable.ArrayAccess.Statements);      

      QString sdaf5 = Compiler::decode(ReturnStatements2);

      Statements.clear();
    } else {      
      
    }

    ReturnStatements << ReturnStatements2;
  
    if (Statements.size() > 0){
      ReturnStatements << Statements;
      Statements.clear();
    }

    if (Variable.sName == "Me" && peekTerm(".") == false){
   
      Variable.sType = getClassName(Me.sFileName);
    }

    return true;
  } else if (bAssignment == false){
    _expressions ReturnExpression;

    ReturnExpression.bReturn = bReturn;


    if (parseProcedure_Call(ReturnExpression)){ 
      Variable.sName = "";
      Variable.sType = ReturnExpression.sType;

      ReturnStatements << ReturnExpression.Statements;
      return true; 
    }
  }

  _END_
}


bool Parser::autoInitForType(_statements & ReturnStatements, QString sVariable, QString sClass, QString sTypeL, QString sTypeR, bool *bType, _array Array, bool bMustMatch, bool *bParseBrackets)
{  
  *bParseBrackets = false;


  
  if (!sClass.isEmpty() && Me.DeclareClasses.contains(sClass) && ((peekTerm("(")  && peekTerm(")", 1)) || peekReturn(0))){

    ReturnStatements << Compiler::pushCode("Q7B_ID(\"" + sClass + "\", Q7B_connectSlotsByNameForGivenObjectAndReturnIt(this, new " + sClass + "(), \"" + sVariable + "\"))");   
    *bParseBrackets = true;
    return true;
  }

  if (sClass == "QIcon"){

     if (Me.nPass == 1 && parseTerm("(")){
 
      _expressions Expression;        
      if (!parseExpressionString(Expression)){ error(""); return false; }
      if (!parseTerm(")")){ error(""); return false; }
	  
       ReturnStatements << Compiler::pushCode("Q7B_QICON_INIT(this, \"" + Me.sVarNameForOnAction + "\", " + Compiler::decode(Expression.Statements) + ")");

    } else {
       ReturnStatements << Compiler::pushCode("Q7B_QICON_INIT(this, \"" + Me.sVarNameForOnAction + "\")");
       *bParseBrackets = true;

    }
    return true;

  } else if (sClass == "QPixmap"){

     if (Me.nPass == 1 && parseTerm("(")){
 
      _expressions Expression;        
      if (!parseExpressionString(Expression)){ error(""); return false; }
      if (!parseTerm(")")){ error(""); return false; }
	  
       ReturnStatements << Compiler::pushCode("Q7B_QPIXMAP_INIT(this, \"" + Me.sVarNameForOnAction + "\", " + Compiler::decode(Expression.Statements) + ")");

    } else {
       ReturnStatements << Compiler::pushCode("Q7B_QPIXMAP_INIT(this, \"" + Me.sVarNameForOnAction + "\")");
       *bParseBrackets = true;

    }
    return true;

  } else if (sClass == "QMenu"){
  
     if (Me.nPass == 1 && parseTerm("(")){
 
       _expressions Expression;        
       if (!parseExpressionString(Expression)){ error(""); return false; }
       if (!parseTerm(")")){ error(""); return false; }
	  
       ReturnStatements << Compiler::pushCode("Q7B__QMENU_INIT(this, \"" + Me.sVarNameForOnAction + "\", " + Compiler::decode(Expression.Statements) + ")");          
     } else {
       ReturnStatements << Compiler::pushCode("Q7B_QMENU_INIT(this, \"" + Me.sVarNameForOnAction + "\")");   
       *bParseBrackets = true;
     }
     return true;
                     
  } else if (sClass == "Boolean"){ 
    ReturnStatements << Compiler::pushBoolean(false);  
    //ReturnStatements << Compiler::pushCode("Q7B_ID((bool) false)"); 
    *bParseBrackets = true;
    return true;
  } else if (sClass == "Integer" || sClass == "Byte" || sClass == "Int16" || sClass == "Int32" || sClass == "Int64" || sClass == "Int8" || sClass == "Short"){ 
    ReturnStatements << Compiler::pushInteger(0);  
    //ReturnStatements << Compiler::pushCode("Q7B_ID((qint64) 0)");  
    *bParseBrackets = true;
    return true;
  } else if (sClass == "Float" || sClass == "Double" || sClass == "Single"){ 
    ReturnStatements << Compiler::pushFloat(0.0);  
    //ReturnStatements << Compiler::pushCode("Q7B_ID((qreal) 0.0)");  
    *bParseBrackets = true;
    return true;
  } else if (sClass == "Decimal"){
    ReturnStatements << Compiler::pushDecimal("0.0D");  
    //ReturnStatements << Compiler::pushCode("Q7B_ID(Q7B_ID_DECIMAL(0, 0))");  
    *bParseBrackets = true;
    return true;
  } else if (sClass == "String" || sClass == "CString"){       
    ReturnStatements << Compiler::pushString("");  
//    ReturnStatements << Compiler::pushCode("Q7B_ID(QString(\"\"))");  
    *bParseBrackets = true;
    return true;

  } else if (sClass == "DateTime"){ 

    if (Me.nPass == 1 && parseTerm("(")){

      if (parseTerm(")")){ 

        ReturnStatements << Compiler::pushCode("Q7B_ID(QDateTime())");  

      } else {
   
        _expressions Expression;        
        if (!parseExpressionInteger(Expression)){ error(""); return false; }

        if (!parseTerm(",")){ error(", expected"); return false; }

        _expressions Expression2;
        if (!parseExpressionInteger(Expression2)){ error(""); return false; }

        if (!parseTerm(",")){ error(", expected"); return false; }

        _expressions Expression3;
        if (!parseExpressionInteger(Expression3)){ error(""); return false; }

        _expressions Expression4;
        if (parseTerm(",")){ 
          if (!parseExpressionInteger(Expression4)){ error(""); return false; }
        } else {  Expression4.Statements = Compiler::pushExpression(Compiler::pushCode("Q7B_ID(-1)")); }

        _expressions Expression5;        
        _expressions Expression6;        
        _expressions Expression7;  

        if (parseTerm(",")){ 

          if (!parseExpressionInteger(Expression5)){ error(""); return false; }

          if (!parseTerm(",")){ error(", expected"); return false; }
          
          if (!parseExpressionInteger(Expression6)){ error(""); return false; }

          if (!parseTerm(",")){ error(", expected"); return false; }
          
          if (!parseExpressionInteger(Expression7)){ error(""); return false; }

        } else {
          Expression5.Statements = Compiler::pushExpression(Compiler::pushCode("Q7B_ID(-1)"));
          Expression6.Statements = Compiler::pushExpression(Compiler::pushCode("Q7B_ID(-1)"));
          Expression7.Statements = Compiler::pushExpression(Compiler::pushCode("Q7B_ID(-1)"));
        }

        if (!parseTerm(")")){ error(""); return false; }

        ReturnStatements << Compiler::pushCode("Q7B_DATETIME_INIT(" + Compiler::decode(Expression.Statements) + ", " + Compiler::decode(Expression2.Statements) + ", " + Compiler::decode(Expression3.Statements) + ", " + Compiler::decode(Expression4.Statements) + ", " + Compiler::decode(Expression5.Statements) + ", " + Compiler::decode(Expression6.Statements) + ", " + Compiler::decode(Expression7.Statements) + ")");  
      }
	  
     } else {
       ReturnStatements << Compiler::pushCode("Q7B_ID(QDateTime())");  
       *bParseBrackets = true;
     }

     return true;

  } else if (sClass == "id" || sClass == "Object"){ 
    ReturnStatements << Compiler::pushCode("Q7B_IDNULL()");  
    *bParseBrackets = true;
    return true;  
  } else if (sClass == "FormClass"){ 
    ReturnStatements << Compiler::pushCode("Q7B_FORMCLASS_INIT(this, \"" + Me.sVarNameForOnAction + "\")");  
    *bParseBrackets = true;
    return true;  
  } else if (sClass == "uiClass"){ 
    ReturnStatements << Compiler::pushCode("Q7B_UICLASS_INIT(this, \"" + Me.sVarNameForOnAction + "\")");  
    *bParseBrackets = true;
    return true;  
  } else if (sClass == "Class"){
    ReturnStatements << Compiler::pushCode("Q7B_CLASS_INIT(this, \"" + Me.sVarNameForOnAction + "\")");  
    *bParseBrackets = true;
    return true;  
  } else if (sClass == "Module"){ 
    ReturnStatements << Compiler::pushCode("Q7B_MODULE_INIT(this, \"" + Me.sVarNameForOnAction + "\")");  
    *bParseBrackets = true;
    return true;  
  } else if (sClass == "List"){

      QString s;
      if (Me.nPass == 1 && parseTerm("(")){

        s = "Q7B_List::init(";

        bool bFirst = true;
        bool bFirst2 = true;

        do {
        
          if (bFirst){
            bFirst = false;
          } else {
            s += ", ";
          }
          
          _expressions Expression;        
          if (!parseExpressionid(Expression)){ 
            if (bFirst2){                        
              break;
            } else {
              error(""); return false; 
            }
            
          }
            
          s += Compiler::decode(Expression.Statements);
          bFirst2 = false;
         } while (parseTerm(","));

        s += ")";

	      if (!parseTerm(")")){ error(""); return false; }
        
       } else { 
         s += "Q7B_ID(Q7B_List::init())";
         *bParseBrackets = true;
       }

       ReturnStatements << Compiler::pushCode(s);  
       return true;  

   } else if (sClass == "Dictionary"){
      QString s;

      if (parseTerm("(")){

        _expressions Expression;        
        
   
        if (!parseExpression(Expression)){ 
          if (!parseTerm(")")){ error(""); return false; }
          s += "Q7B_Dictionary::init(";
  
         } else {
        
          if (parseTerm(":=")){
            QStringList Keys;        
            QStringList Values;     
            Keys << "Q7B_QSTRING(" + Compiler::decode(Expression.Statements) + ")";            
            Expression.Statements.clear();
            if (!parseExpression(Expression)){ error(""); return false; }
            Values << Compiler::decode(Expression.Statements);
   
            while (parseTerm(",")){

              Expression.Statements.clear();      
              if (!parseExpression(Expression)){ error(""); return false; }
              Keys << "Q7B_QSTRING(" + Compiler::decode(Expression.Statements) + ")";
              if (!parseTerm(":=")){ error(":= expected"); return false; }           
              Expression.Statements.clear();      
              if (!parseExpression(Expression)){ error(""); return false; }
              Values << Compiler::decode(Expression.Statements);
    
            }
             
            if (!parseTerm(")")){ error(""); return false; }
              
            QString sExpression;
            QString sExpression2;
           
            for (int i = 0; i < Keys.size(); i++){
              sExpression += Keys.at(i);
              if (i + 1 < Keys.size()) sExpression += ", ";
            }
            
            for (int i = 0; i < Values.size(); i++){
              sExpression2 += Values.at(i);
              if (i + 1 < Values.size()) sExpression2 += ", ";
            }
            
            s += "Q7B_Dictionary::init(Q7B_List::init(" + sExpression2 + "), ";
            
            s += "Q7B_List::init(" + sExpression + ")";

          } else {           

            if (!parseTerm(",")){ error(", expected"); return false; }
     
            _expressions Expression2;
            if (!parseExpressionid(Expression2)){ error(""); return false; }
              
	          if (!parseTerm(")")){ error(""); return false; }
            
            s += "Q7B_Dictionary::init(" + Compiler::decode(Expression2.Statements) + ", ";
            
            s += Compiler::decode(Expression.Statements);
        
          }
        
        }
       
        s += ")";
      
       } else { 
         s += "Q7B_Dictionary::init()";
         *bParseBrackets = true;
       }

       ReturnStatements << Compiler::pushCode(s);  
       return true;  

    } else if (Me.classes.contains(sClass) || Me.controls.contains(sClass)){

        //sClass = sClass.replace("<", "").replace(">", ""); // template data type
        ReturnStatements << Compiler::pushCode("Q7B_" + sClass.toUpper() + "_INIT(this, \"" + Me.sVarNameForOnAction + "\")");          
        *bParseBrackets = true;
     
      
    //  if (sClass == "QProgressBar"){
       // ReturnStatements << Compiler::pushCode("Q7B_" + sClass.toUpper() + "_INIT(0, \"" + Me.sVarNameForOnAction + "\")");          
      
        
      
      
      return true;
   
    
    } else if (Me.Classes.contains(sClass)){ 

      QString sClassSave = sClass;

      if (sClass == "myTest99"){
        sClass = sClass;
      }

      if (!isQtDesignerClassFileName(sClass + ".q7b")){
        sClass = Me.Classes[sClass];
      }

      if (!isQtDesignerClassFileName(sClass + ".q7b")){
        if (!sClass.isEmpty() && Me.DeclareClasses.contains(sClass)){
          sClass = Me.DeclareClasses[sClass] + ".q7b";    
          if (isQtDesignerClassFileName(sClass)){        
            ReturnStatements << Compiler::pushCode("Q7B_ID(\"" + sClassSave + "\", Q7B_connectSlotsByNameForGivenObjectAndReturnIt(this, new " + sClassSave + "(), \"" + Me.sVarNameForOnAction + "\"))");   
            *bParseBrackets = true;
            return true;  
          }

        }        
      }

      sClass = sClassSave;

      if (isQtDesignerClassFileName(sClass)){
        ReturnStatements << Compiler::pushCode("Q7B_ID(\"" + sClass + "\", (QObject *) Q7B_connectSlotsByNameWithNewAndReturnIt(new " + sClass + "(" + Me.sVarNameForOnAction + "), this))");  
      } else {
        ReturnStatements << Compiler::pushCode("Q7B_ID(\"" + sClass + "\", (QObject *) Q7B_connectSlotsByNameWithNewAndReturnIt(new " + sClass + "(), this))");  
      }
      *bParseBrackets = true;
      return true;  

    
    } else if (!sTypeL.isEmpty()){

      QString sTypeL;
      QString sTypeR;      
      _type Type;


      QString sType = sClass;
      if (sType.contains(".")){
        sTypeL = sType.left(sType.indexOf("."));
        sTypeR = sType.mid(sType.indexOf(".") + 1);
      }

      bool bLookUpOnly = true;
      if (parseAllType(&sType, &sTypeL, &sTypeR, &Type, bLookUpOnly)){ 

      
        if (typeArrayInit(ReturnStatements, sVariable, Type, sType, Array)){
          *bType = true;
          *bParseBrackets = true;
          return true;  
        }
      }

    }

    




  return false;
}

bool Parser::typeArrayInit(_statements & ReturnStatements, QString sVariable, _type Type, QString sType, _array Array)
{
  
  // tt2.b2[3].c = 777
  QString s;
 
    bool b = false;
  
  if (Me.types.contains(sType)) b = true;
  else if (Me.classes.contains(sType)) b = true;
  else if (Me.controls.contains(sType)) b = true;

 if (Array.isValid()){
    
  
  
    if (Me.nLine == 290){
      Me.nLine = Me.nLine;
    }


    if (!sVariable.contains("q7b_type->at")) {
      s += sVariable + " = Q7B_ID(); ";
    }
    s += "q7b_array_dim(" + sVariable + ", " + Compiler::decode(Array.Statements) + "); ";
  }
  if (!Type.sName.isEmpty() && b == false){
    QString sName = Type.sName;
    if (Type.sPublicPrivateGlobal != "Global") sName = Parser::getClassName(Type.sFileName) + "_" + sName;

    if (Array.bEmpty == false ){

      if (Array.nCount > 0){

        s += "; ";

        QString aa;
        QString bb;
        QString cc;      
        QString dd;      
        int i;
 
        for (i = 0; i < Array.nCount; i++){
          _statements Statement = Array.Statement[i]; 
          aa += QString("for (int q7b_i%1 = 0; q7b_i%2 < " + Compiler::decode(Statement) + ";q7b_i%3++){ ").arg(i).arg(i).arg(i);
          aa = aa.replace("Q7B_ID", "");

          bb += ", ";
          bb += QString("Q7B_ID(q7b_i%1)").arg(i);

          cc += " }";
        }

        for (; i < Q7B_MAX_ARRAYDIM; i++){
          dd += ", ";
          dd += QString("Q7B_ID(%1)").arg(-1);
        }

        s += aa + "Global::q7b_type_" + sName + "_init(q7b_array_at(" + sVariable + bb + dd + "));" + cc;

       
      } else {

        
    bool b = false;
  
  if (Me.types.contains(sType)) b = true;
  else if (Me.classes.contains(sType)) b = true;
  else if (Me.controls.contains(sType)) b = true;

  if (!sVariable.contains("q7b_type->at") && (b || !Array.isValid())){
          s += sVariable + " = Q7B_ID(); "; 
        }
        s += "Global::q7b_type_" + sName + "_init(&" + sVariable + "); ";
      }  

    }
    
  }

  ReturnStatements << Compiler::pushCode(s);

  return true;
}









#include "_Q7BCompiler.h"

extern bool Q7B_Compiler_ConvertDeclareType(QString *sCast);

QString Parser::convertDeclareType(QString sCast, int bConvertDirectionToC)
{
  if (bConvertDirectionToC == 2){



  if (sCast == "Boolean") return "bool";
  if (sCast == "Integer") return "qint64";
  if (sCast == "Float") return "qreal";
  if (sCast == "String") return "QString";
  if (sCast == "List") return "QStringList";
//  if (sCast == "QList<QStringList>") sCast = "QListQStringList"; // template  

  return sCast + "*"; 


  } else if (bConvertDirectionToC == 1){



  if (sCast == "Boolean") return PREFIX + "CBOOL";
  if (sCast == "Integer") return PREFIX + "CQINT64";
  if (sCast == "Float") return PREFIX + "CQREAL";
  if (sCast == "String") return PREFIX + "CQSTRING";
  if (sCast == "List") return PREFIX + "CQSTRINGLIST";  

  if (sCast == "QList<QStringList>") sCast = "QListQStringList"; 

    if (Q7B_Compiler_ConvertDeclareType(&sCast)) return PREFIX + sCast; 

   // { error(QString("Could not find a matching cast function for declare type (C/C++): %1").arg(sCast)); return ""; }

  } else {

    if (Me.DeclareClasses.contains(sCast) && !Me.DeclareClasses[sCast].isEmpty()){
	    return Me.DeclareClasses[sCast];
	  }

    
    if (sCast.startsWith("short ")){
      sCast = sCast.mid(QString("short ").length());
    } else if (sCast.startsWith("long ")){
      sCast = sCast.mid(QString("long ").length());
    } else if (sCast.startsWith("signed ")){
      sCast = sCast.mid(QString("signed ").length());
    } else if (sCast.startsWith("unsigned ")){
      sCast = sCast.mid(QString("unsigned ").length());
    } else if (sCast.startsWith("const ")){
      sCast = sCast.mid(QString("const ").length());
    }

    
    sCast = sCast.remove("&");
 //   bool bPointer = sCast.contains("**");
    sCast = sCast.remove("*");


    if (sCast == "bool"){
      return "Boolean";

    } else if (sCast == "int" || sCast == "long" || sCast == "short" || sCast == "long" || sCast == "signed" || sCast == "unsigned" || sCast == "char"){
      return "Integer";

    } else if (sCast == "float" || sCast == "double"){
      return "Float";

    } else if (sCast == "qreal"){
        return "Float";
    }



    if (sCast == "QString"){
      return "String";
    } else if (sCast == "QStringList"){
      return "QStringList";

    } else if (sCast == "QListQStringList"){
      return "QList<QStringList>";
    }

    QStringList IsInteger;

    IsInteger << "qint8";
    IsInteger << "qint16";
    IsInteger << "qint32";
    IsInteger << "qint64";
    IsInteger << "qlonglong";
    IsInteger << "quint8";
    IsInteger << "quint16";
    IsInteger << "quint32";
    IsInteger << "quint64";
    IsInteger << "qulonglong";
    IsInteger << "uchar";
    IsInteger << "uint";
    IsInteger << "ulong";
    IsInteger << "ushort";

    if (IsInteger.contains(sCast)){
      return "Integer";
    } else if (sCast == "qreal"){
      return "Float";
    }

    return sCast;

  }
  return "";

}

bool Parser::parseDeclareSubFunction(QString sSubFunctionIBActionActionSignalEventDelegateSlot, bool bStatic)
{    
  _BEGIN_  

  QString sClass;
  
  if (!parseString(&sClass)){ 
    
    if (sSubFunctionIBActionActionSignalEventDelegateSlot != "Sub" && sSubFunctionIBActionActionSignalEventDelegateSlot != "Function"){ error("Name of native class expected"); return false; }
  }

  

  QString sAlias;
  if (parseTerm("Alias")){ 
    if (!parseString(&sAlias)){ error("Alias expected"); return false; }
    
  }

  if (bStatic){
    { error("Sorry. Static for declare is not supported yet"); return false; }
  }



  QString sNative;
 
  QString sReturnType;
  if (parseTerm("*")){ sReturnType += "*"; }
  if (parseTerm("&")){ sReturnType += "&"; }
  if (parseIdentifier("const")){ sReturnType += "const "; }
  QString k;
  if (!parseIdentifier(&k)){ error("C++: argument type expected"); return false; }
  sReturnType += k;
  if (parseTerm("*")){ sReturnType += "*"; }
  if (parseTerm("&")){ sReturnType += "&"; }
  if (parseIdentifier("const")){ sReturnType += "const "; }

  sNative += sReturnType;
  sNative += " ";

  QString sSub;
  if (!parseIdentifier(&sSub)){ 
    if (!parseTerm(&sSub)){ 
      error("C++: name expected"); return false; 
    }
  }

  if (!parseTerm("(")){ error("( expected"); return false; }

  sNative += sSub;

  Me.SubFunction.Arguments.clear();

  sNative += "(";

  if (!parseTerm(")")){ 

    bool bFirst = true;
    do {
      if (bFirst == false) sNative += ",";
      bFirst = false;

      QString s;
      if (parseTerm("&")){ s += "&"; }
      if (parseTerm("*")){ s += "*"; }
      if (parseIdentifier("const")){ 
      s += "const "; }
      QString k;
      if (!parseIdentifier(&k)){ error("C++: argument type expected"); return false; }
      s += k;
      if (parseTerm("&")){ s += "&"; }
      if (parseTerm("*")){ s += "*"; }
      if (parseIdentifier("const")){ s += "const "; }

      if (s.trimmed() == "void"){
        if (parseTerm(")")){
          goto we;
        }
      }

      _argument Argument;

      Argument.sType = s;

      sNative += s;

      if (!parseIdentifier(&s)){ error("C++: argument name expected"); return false; }

      Argument.sName = s;

      sNative += " ";
      sNative += s;

      Me.SubFunction.Arguments.append(Argument);

    } while (parseTerm(","));

    if (!parseTerm(")")){ error(""); return false; }
  }
we:  
  sNative += ")";

  if (parseTerm(";")){ }
  
  if (!parseReturn()){ error("new line expected"); return false; }

  addDeclareSubFunction(sSubFunctionIBActionActionSignalEventDelegateSlot, sAlias, sSub, Me.sFileName, sClass, sReturnType, bStatic, sNative);  

  return true;


   return true;

  _END_  
}

void Parser::addDeclareSubFunction(QString sSubFunctionIBActionActionSignalEventDelegateSlot, QString sDeclareAlias, QString sName, QString sFileName, QString sDeclareClass, QString sType, bool bStatic, QString sDeclareNative)
{  
  bool bExists = false;

  if (sName == "showMenu"){
	  sName = sName;
  }

  if (sName == "alloc"){
      error("'" + sName + "' already declared as built-in and ready for use, e.g. NSString.alloc().init()"); return;
  }

  if (Me.nPass == 0){
    bExists = Me.GlobalSubsFunctions.contains(sDeclareAlias.isEmpty() ? sName : sDeclareAlias);

    if (bExists){
      
      error("Procedure '" + sName + "' already declared with the same name somewhere in project"); return;
    }
  }
  
  
 if (sName != "alloc" && isCppObjcKeyword(sName, "Name of procedure")) return;

  _subfunction SubFunction;
  
  SubFunction.sFileName = sFileName;
  SubFunction.sPublicPrivateGlobal = "";
  SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot = sSubFunctionIBActionActionSignalEventDelegateSlot;
  SubFunction.sName = sName;
  SubFunction.sType = sType;
  SubFunction.bStatic = bStatic;
  SubFunction.Arguments = Me.SubFunction.Arguments;

  SubFunction.bDeclare = true;
  SubFunction.sDeclareAlias = sDeclareAlias;
  SubFunction.sDeclareClass = sDeclareClass;
  SubFunction.sDeclareNative = sDeclareNative;   

  SubFunction.bCallAble = 
      ! (sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"
      || sSubFunctionIBActionActionSignalEventDelegateSlot == "Action"
      || sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"
      || sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"
   );

  if (sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
    Me.DeclareSignals[sDeclareClass][sDeclareAlias.isEmpty() ? sName : sDeclareAlias] = SubFunction;
  } else if (sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"){
    Me.DeclareEvents[sDeclareClass][sDeclareAlias.isEmpty() ? sName : sDeclareAlias] = SubFunction;
  } else if (sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"){
    Me.DeclareDelegates[sDeclareClass][sDeclareAlias.isEmpty() ? sName : sDeclareAlias] = SubFunction;

    Me.DeclareDelegatesList[(sDeclareAlias.isEmpty() ? sName : sDeclareAlias) + QString().fill(':', SubFunction.Arguments.count())] = SubFunction;

  } else {
    Me.DeclareSubsFunctionsSignalsEventsDelegates[sDeclareClass][sDeclareAlias.isEmpty() ? sName : sDeclareAlias] = SubFunction;
  }
  Me.DeclareSubsFunctions[sDeclareClass][sDeclareAlias.isEmpty() ? sName : sDeclareAlias] = SubFunction;

  if (!Me.DeclareClasses.contains(sDeclareClass)){
    Me.DeclareClasses[sDeclareClass] = ""; 
    Me.DeclareClassesFileName[sDeclareClass] = sFileName;
  }
  
}

void Parser::addDeclareEnum(QString sName, QString sType, QStringList EnumNames)
{
  if (Me.nPass == 0){
    Me.DeclareEnums[sName] = Me.sFileName;
    Me.DeclareEnumTypes[sName] = sType;
    Me.DeclareEnumConsts[sName] = EnumNames;

    for (int i = 0; i < EnumNames.size(); i++){
      Me.DeclareEnumConsts2[EnumNames.at(i)] = sName;
    }
  }
}

void Parser::addDeclareConst(QString sName, QString sType)
{
  if (Me.nPass == 0){
    Me.DeclareConstValues[sName] = Me.sFileName;
    Me.DeclareConstTypes[sName] = sType;    
  }
}



 
  
// if (parseDeclareConstant(sCurrentFileName, sReturnStatements, sReturnType)){ return true; }







#include "_Q7BCompiler.h"

bool Parser::parseExpression(_expressions & Expression, bool bAllowNamedArguments)
{  
  if (bAllowNamedArguments && peekTerm(":=", 2)){
    QString sArgument;
    if (!parseIdentifier(&sArgument)){ error(""); return false; }                     
    if (!parseTerm(":=")){ error(":= expected"); return false; }           
  }

  bool bSave = Me.bOnlyFunction;
  Me.bOnlyFunction = true;

  if (parseOrElse(Expression)){

    Me.bOnlyFunction = bSave;
    return true; 
  }
  Me.bOnlyFunction = bSave;
  return false;
}

bool Parser::parseExpressionIntegerFloatDecimal(QString sExpressionType, QString sDummy){ return typeCompatible(sExpressionType, "Integer") || typeCompatible(sExpressionType, "Float") || typeCompatible(sExpressionType, "Decimal"); }

bool Parser::parseExpressionBoolean(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "Boolean"); }
bool Parser::parseExpressionInteger(_expressions & Expression){ bool b = parseExpression(Expression); return b && parseExpressionIntegerFloatDecimal(Expression.sType, "Integer"); }
bool Parser::parseExpressionFloat(_expressions & Expression){ bool b = parseExpression(Expression); return b && (parseExpressionIntegerFloatDecimal(Expression.sType, "Float")); }
bool Parser::parseExpressionString(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "String"); }
bool Parser::parseExpressionid(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "id"); }
bool Parser::parseExpressionList(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "Array"); }
bool Parser::parseExpressionDictionary(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "Dictionary"); }
bool Parser::parseExpressionData(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "Data"); }
bool Parser::parseExpressionDecimal(_expressions & Expression){ bool b = parseExpression(Expression); return b && parseExpressionIntegerFloatDecimal(Expression.sType, "Decimal"); }
bool Parser::parseExpressionDateTime(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "DateTime"); }

bool Parser::parseExpressionQWidget(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "QWidget"); }

bool Parser::parseExpressionRect(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "Rect"); }
bool Parser::parseExpressionPoint(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "Point"); }
bool Parser::parseExpressionLong(_expressions & Expression){ bool b = parseExpression(Expression); return b && parseExpressionIntegerFloatDecimal(Expression.sType, "Long"); }
bool Parser::parseExpressionByte(_expressions & Expression){ bool b = parseExpression(Expression); return b && parseExpressionIntegerFloatDecimal(Expression.sType, "Byte"); }
bool Parser::parseExpressionSingle(_expressions & Expression){ bool b = parseExpression(Expression); return b && parseExpressionIntegerFloatDecimal(Expression.sType, "Double"); }
bool Parser::parseExpressionDouble(_expressions & Expression){ bool b = parseExpression(Expression); return b && parseExpressionIntegerFloatDecimal(Expression.sType, "Double"); }
bool Parser::parseExpressionNSImage(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "NSImage"); }


bool Parser::parseExpressionNSView(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "NSView"); }
bool Parser::parseExpressionNSWindow(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "NSWindow"); }
bool Parser::parseExpressionNSDrawer(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "NSDrawer"); }
bool Parser::parseExpressionNSMenuItem(_expressions & Expression){ bool b = parseExpression(Expression); return b && typeCompatible(Expression.sType, "NSMenuItem"); }



bool Parser::parseCondition(_expressions & Expression)
{  
  bool bSave = Me.bOnlyFunction;
  Me.bOnlyFunction = true;

  if (parseOrElse(Expression)){
  
    Me.bOnlyFunction = bSave;
    return true; 
  }
  Me.bOnlyFunction = bSave;
  return false;
}




#include "_Q7BCompiler.h"



bool Parser::parseFactor(_statements & Statements)
{  
  _expressions Expression;
  Expression.bReturn = false;
  bool bReturn = parseFactor(Expression);
  Statements = Expression.Statements;
  return bReturn;
}

bool Parser::parseFactor(_expressions & ReturnExpression)
{    

  bool bEnumParsing = !Me.sParsingPreviousValidEnumName.isEmpty();

  if (ReturnExpression.bReturn){    


    if (parseTerm("True")){ ReturnExpression.Statements << Compiler::pushBoolean(true); ReturnExpression.sType = "Boolean"; return true; }
    if (parseTerm("False")){ ReturnExpression.Statements << Compiler::pushBoolean(false); ReturnExpression.sType = "Boolean"; return true; }
    if (parseTerm("Null")){ ReturnExpression.Statements << Compiler::pushNull(); ReturnExpression.sType = "id"; return true; }
   
   
   
    if (parseBuiltinConstant(ReturnExpression)){ return true; }
  
    {
      QString sString;
      if (parseString(&sString)){ 
        ReturnExpression.Statements << Compiler::pushString(sString); 
        ReturnExpression.sType = "String"; 
        return true; 
      }
    }

    {
      QString sNumber;
      if (parseNumber(&sNumber)){ 
       
        if (sNumber.endsWith("D")){
          ReturnExpression.Statements << Compiler::pushDecimal(sNumber);
          ReturnExpression.sType = "Decimal";
        } else if (sNumber.contains(".") || sNumber.contains("e") || sNumber.contains("E")){
          ReturnExpression.Statements << Compiler::pushFloat(sNumber.toDouble());
          ReturnExpression.sType = "Float";
        } else { 
          ReturnExpression.Statements << Compiler::pushInteger(sNumber.toLongLong());
          ReturnExpression.sType = "Integer";
        }      
      
        return true; 
      }
    }

    

    if (bEnumParsing == false && parseTerm("IIf")){

      if (!parseTerm("(")){ error("'(' expected"); return false; }
      _expressions Condition;
      if (!parseCondition(Condition)){ error(""); return false; }
      if (!parseTerm(",")){ error("',' expected"); return false; }

      _expressions Expression;
      if (!parseExpression(Expression, true)){ error(""); return false; }
        
      if (!parseTerm(",")){ error("',' expected"); return false; }

      _expressions Expression2;
      if (!parseExpression(Expression2, true)){ error(""); return false; }        

      if (!parseTerm(")")){ error("')' expected"); return false; }

      ReturnExpression.Statements << Compiler::push("IIf", Condition.Statements, Expression.Statements, Expression2.Statements);
      ReturnExpression.sType = DEFAULTTYPE;
      return true;                           
    }

    if (parseTerm("Not")){ 
      _expressions Factor(ReturnExpression.sType, ReturnExpression.bReturn);
      if (!parseFactor(Factor)){ error(""); return false; }

      if (!typeCompatible(Factor.sType, "", "NOT")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      ReturnExpression.Statements << Compiler::pushOperator("NOT", Factor.Statements);
      ReturnExpression.sType = Factor.sType;
      return true;
    }
    if (parseTerm("Flip")){ 
      _expressions Factor(ReturnExpression.sType, ReturnExpression.bReturn);
      if (!parseFactor(Factor)){ error(""); return false; }

      if (!typeCompatible(Factor.sType, "", "FLIP")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      ReturnExpression.Statements << Compiler::pushOperator("FLIP", Factor.Statements);
      ReturnExpression.sType = Factor.sType;
      return true;
    }
    
    if (parseTerm("+")){ 
      _expressions Factor(ReturnExpression.sType, ReturnExpression.bReturn);
      if (!parseFactor(Factor)){ error(""); return false; }

      if (!typeCompatible(Factor.sType, "", "+")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      ReturnExpression.Statements << Compiler::pushOperator("PLUS", Factor.Statements);
      ReturnExpression.sType = Factor.sType;
      return true;
    }  
    
    if (parseTerm("-")){ 
      _expressions Factor(ReturnExpression.sType, ReturnExpression.bReturn);
      if (!parseFactor(Factor)){ error(""); return false; }

      if (!typeCompatible(Factor.sType, "", "-")){ error("expression types incompatible or operator not allowed with the expression types"); return false; }

      ReturnExpression.Statements << Compiler::pushOperator("MINUS", Factor.Statements);
      ReturnExpression.sType = Factor.sType;
      return true;
    }

    
    if (parseEnum(ReturnExpression)){
      return true;
    }
  }

  if (parseTerm("(")){ 
    _expressions Factor(ReturnExpression.sType, ReturnExpression.bReturn);
    if (!parseExpression(Factor)){ error(""); return false; }
    if (!parseTerm(")")){ error(""); return false; }

    ReturnExpression.Statements << Compiler::pushOperator("BRACES", Factor.Statements);
    ReturnExpression.sType = Factor.sType;
    return true;
  }    

  if (bEnumParsing){
    return false;
  }
  

  if (Me.nLine == 280 && Me.sFileName == "CodeView.QWidget.q7b"){
    Me.nLine = Me.nLine;
  }
  if (parseBuiltinSubFunction(ReturnExpression)){ return true; }

  _variableconstant Variable;
  _statements VariableStatements;
  

  
  bool bFakeAlreadyHandled = false;
  if (parseVariableOrObjectIdentifierOrProcedureCall(VariableStatements, Variable, false, ReturnExpression.bReturn)){  
    QString sQObjectPropertyOrKVC;
    if (parseQObjectPropertyOrKVC(&sQObjectPropertyOrKVC)){ 
      ReturnExpression.Statements << Compiler::pushBuiltinSubFunction("PROPERTY", ReturnExpression.bReturn, VariableStatements, Compiler::pushExpression(Compiler::pushString(sQObjectPropertyOrKVC)));
      ReturnExpression.sType = DEFAULTTYPE;
      return true;
    } else if (parseBuiltinClassOrControlOrObject_PropertyOrProcedure(ReturnExpression, Variable, VariableStatements, &bFakeAlreadyHandled)){
      QString wert = Compiler::decode(ReturnExpression.Statements);
        return true;
    } else {
   
      ReturnExpression.Statements << VariableStatements;
      ReturnExpression.sType = Variable.sType;
      ReturnExpression.bAlloc = Variable.bAlloc;
      return true;
    }
  }

  return false;
}












#include "_Q7BCompiler.h"


bool Parser::parseStatements(_statements & ReturnStatement, bool bOnlyOneStatement)
{  
  Me.nBlock++;

  int nCount = 0;
  
  while(Me.nTokenPos < Me.tokens[Me.sFileName].size()){
    nCount++;
    if (bOnlyOneStatement && nCount > 1) break;
    if (Me.bError) break;  

    QString token = getToken();

    if (token == "K\n"){ 
      Me.nTokenPos++;
      Me.nLine++;
      continue;
    }

    if (token == "K:"){
      Me.nTokenPos++;
      continue;
    }

    char c = token.at(0).toLatin1();

    if (token.at(0) == 'C'){ 
      Me.nTokenPos++;
      continue;
    }

    if (c == 'K'){


        if (token == "K<objc>"){
          Me.nTokenPos++;
          QString sobjc;
          sobjc = Me.tokens[Me.sFileName].at(Me.nTokenPos).mid(1);

          Me.nTokenPos++;

          ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");
          ReturnStatement << Compiler::pushCode(sobjc);
          continue;
        }



   
   
      if (Me.nLine == 168 && Me.sFileName == "Module2.QObject.q7b"){
          Me.nLine = Me.nLine;
        }

      if (parseTerm("If")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");          
        
        int ndfd = Me.nLine;

        if (Me.nLine == 564 && Me.sFileName == "MainWindow.QMainWindow.q7b"){
          Me.nLine = Me.nLine;
        }

        _expressions Expression;
        if (!parseCondition(Expression)){ error(""); return false; }
        if (!parseTerm("Then")){ error(""); return false; }
        bool bReturn = parseReturn();

        _statements Statements;
        if (!parseStatements(Statements, bReturn == false)){ error(""); return false; }

        ReturnStatement << Compiler::push("If", Expression.Statements, Statements);

_else:
        if (parseTerm("Else")){ 
          if (parseTerm("If")){
            _expressions Expression;
            if (!parseCondition(Expression)){ error(""); return false; }
            if (!parseTerm("Then")){ error(""); return false; }
            if (bReturn && !parseReturn()){ error("new line expected"); return false; }
            _statements Statements;
            if (!parseStatements(Statements, !bReturn)){ error(""); return false; }

            ReturnStatement << Compiler::push("Else If", Expression.Statements, Statements);

            goto _else;
          } else {

            _statements Statements;
            if (!parseStatements(Statements, !bReturn)){ error(""); return false; }

            ReturnStatement << Compiler::push("Else", Statements);

          }
        }

        ReturnStatement << Compiler::push("End If");

        bool bEnd = false;
        if (!(bEnd = parseTerm("End")) && bReturn){ error(""); return false; }
        if (!parseTerm("If") && (bEnd || bReturn)){ error("'End If' expected"); return false; }
        if (!parseReturn()){ error("new line expected"); return false; }
        
        continue;

      }

      if (!peekTerm(".", -1) && parseTerm("Select")){ 
          //peekTerm(".", -2);
          if (parseTerm("Case")){} 

          ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

          _expressions Condition;

          if (!parseExpression(Condition)){ error(""); return false; }
          if (!parseReturn()){ error("new line expected"); return false; }

          while (parseReturn()){}
          
          _expressions Expression2;
          QMap<int, _expressions> conditions;
          QMap<int, _expressions> debugexpressions;
          QMap<int, QString> operators;

          QMap<int, _statements> statements;
          _statements DefaultStatements;
          _statements Statements;

          bool bCaseElseAllowed = false;

          bool bDefault = false;
          QMap<int, _expressions> to;
          
          int x = 0;

          while (parseTerm("Case")){

            int nCount = 0;     

            debugexpressions[x].Statements << Compiler::pushDebugAndAlso(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1"));

            QString sOperator = "EQUAL";

            if (parseTerm("Is")){ 

              if (parseTerm("=")){ sOperator = "EQUAL"; }
              else if (parseTerm("==")){
                sOperator = "EQUALEQUAL"; 
              } else if (parseTerm("===")){ 
                sOperator = "EQUALEQUALEQUAL"; } 

              else if (parseTerm("<>")){ sOperator = "UNEQUAL"; }
              else if (parseTerm(">")){ sOperator = "GREATER"; }
              else if (parseTerm("<")){ sOperator = "SMALLER"; }
              else if (parseTerm(">=")){ sOperator = "GREATEREQUAL"; }
              else if (parseTerm("<=")){ sOperator = "SMALLEREQUAL"; }
              else { error("=, <>, <, >, <= or >= missing"); return false; }
                
            }

            if (bCaseElseAllowed && parseTerm("Else")){ 
              if (!parseReturn()){ error("new line expected"); return false; }
              if (!parseStatements(DefaultStatements)){ error(""); return false; }              
              bDefault = true;
              break;
            }
            
            Expression2.Statements.clear();
            if (!parseExpression(Expression2)){ error(""); return false; }
            if (!typeCompatible(Condition.sType, Expression2.sType)){ error("types incompatible"); return false; }

            conditions[x].Statements << Compiler::pushExpression(Expression2.Statements);
            operators[x] = sOperator;
            
            if (parseTerm("To")){ 

              if (isStringType(Expression2.sType)){ error("String data type must not be used with 'To'"); return false; }

              Expression2.Statements.clear();
              if (!parseExpression(Expression2)){ error(""); return false; }
              if (!typeCompatible(Condition.sType, Expression2.sType)){ error("types incompatible"); return false; }
              to[x].Statements << Compiler::pushExpression(Expression2.Statements);

              if (isStringType(Expression2.sType)){ error("String data type must not be used with 'To'"); return false; }

            } else {
              to[x].Statements << _statements();

              while (parseTerm(",")){
                nCount++;

                to[x + nCount].Statements << _statements(); 
                debugexpressions[x + nCount].Statements << _statements(); 

                Expression2.Statements.clear();
                if (!parseExpression(Expression2)){ error(""); return false; }
                if (!typeCompatible(Condition.sType, Expression2.sType)){ error("types incompatible"); return false; }

                conditions[x + nCount].Statements << Compiler::pushExpression(Expression2.Statements);
                operators[x + nCount] = sOperator;
              }
              
            }
            bCaseElseAllowed = true;

            if (!parseReturn()){ error("new line expected"); return false; }
            Statements.clear();
            if (!parseStatements(Statements)){ error(""); return false; }            
            statements[x] << Statements;
            for (int mm = 0; mm < nCount; mm++){
              statements[x + 1 + mm] << Compiler::pushExpression(Statements);
            }
            x += nCount;
            x++;
          }                      
          if (bCaseElseAllowed == false){
            { error("Case statement missing"); return false; }
          }

          if (!parseTerm("End")){ error(""); break; }
          if (!parseTerm("Select")){ error("'End Select' expected"); return false; }
          if (!parseReturn()){ error("new line expected"); return false; }

          for (int i = 0; i < conditions.size(); i++){

            QString sId;
            if (i == 0){
              sId = "If";
            } else {
              sId = "Else If";
            }
            if (to[i].Statements.size() == 0){

              if (debugexpressions[i].Statements.size() == 0){
                ReturnStatement << Compiler::push(sId, Compiler::pushOperator(operators[i], Condition.Statements, conditions[i].Statements), statements[i]);
              } else {
                ReturnStatement << Compiler::push(sId, Compiler::pushOperator("DEBUG_ANDALSO", debugexpressions[i].Statements, Compiler::pushOperator(operators[i], Condition.Statements, conditions[i].Statements)), statements[i]);
              }
            } else {
              ReturnStatement << Compiler::push(sId, Compiler::pushOperator("DEBUG_ANDALSO", debugexpressions[i].Statements, Compiler::pushOperator("DEBUG_ANDALSO", Compiler::pushOperator("GREATEREQUAL", Condition.Statements, conditions[i].Statements), Compiler::pushOperator("SMALLEREQUAL", Condition.Statements, to[i].Statements))), statements[i]);
            }
          }

          if (bDefault){               
            ReturnStatement << Compiler::push("Else", DefaultStatements);
          }

          ReturnStatement << Compiler::push("End If");

        continue;
      }


      

      bool bWhile = false;
      if (parseTerm("Do") || (bWhile = parseTerm("While"))){
        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        bool bUntil = false;
        if (bWhile || parseTerm("While") || (bUntil = parseTerm("Until"))){
          
          _expressions Condition;
          if (!parseCondition(Condition)){ error(""); return false; }
          if (!parseReturn()){ error("new line expected"); return false; }

          bool bSAVE = Me.SubFunction.bLocalLoop;
          Me.SubFunction.bLocalLoop = true;

          _statements Statements;
          if (!parseStatements(Statements)){ error(""); return false; }
          Me.SubFunction.bLocalLoop = bSAVE;
          if (bWhile){
            if (!parseTerm("End")){ error("'End While' missing"); return false; }
            if (!parseTerm("While")){ error("'End While' missing"); return false; }
          } else {
            if (!parseTerm("Loop")){ error("'Loop' missing"); return false; }
          }
          if (!parseReturn()){ error("new line expected"); return false; }

          if (bUntil){
            ReturnStatement << Compiler::push("Do Until ? ... Loop", Condition.Statements, Statements);
            ReturnStatement << Compiler::push("End Do Until ? ... Loop");
          } else {
            ReturnStatement << Compiler::push("Do While ? ... Loop", Condition.Statements, Statements);
            ReturnStatement << Compiler::push("End Do While ? ... Loop");
          }

        } else {
          if (!parseReturn()){ error("new line expected"); return false; }
          bool bSAVE = Me.SubFunction.bLocalLoop;
          Me.SubFunction.bLocalLoop = true;
          _statements Statements;
          if (!parseStatements(Statements)){ error(""); return false; }
          Me.SubFunction.bLocalLoop = bSAVE;
          if (!parseTerm("Loop")){ error(""); return false; }
          if (!(bUntil = parseTerm("Until"))){ 
            if (!parseTerm("While")){ error("'While' expected"); return false; }
          }
          _expressions Condition;
          if (!parseCondition(Condition)){ error(""); return false; }
          if (!parseReturn()){ error("new line expected"); return false; }

          if (bUntil){
            ReturnStatement << Compiler::push("Do ... Loop Until ?");
            ReturnStatement << Compiler::push("End ... Do Loop Until ?", Condition.Statements, Statements);
          } else {
            ReturnStatement << Compiler::push("Do ... Loop While ?");
            ReturnStatement << Compiler::push("End ... Do Loop While ?", Condition.Statements, Statements);
          }

        }

        continue;
      }
    

      if (parseTerm("For")){
        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");
        _statements DebugInfo;
        DebugInfo << Compiler::pushDebugAndAlso(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1"));

          
        //if (parseTerm("Each"))
        
          
        
          _variableconstant Variable;
          _statements VariableStatements;
          _statements Dummy;
          if (!parseVariable(VariableStatements, Variable, Dummy)){ error("variable expected"); return false; }

          if (convertType(Variable.sType) != "Integer"){ error("counter variable must be of type 'Integer'"); return false; }
          if (!parseTerm("=")){ error("= expected"); return false; }
          _expressions Expression;
          if (!parseExpression(Expression)){ error(""); return false; }
          if (!typeCompatible(Variable.sType, Expression.sType)){ error("types incompatible"); return false; }

          
          //if (!(bTill = parseTerm("Till"))){ 
            if (!parseTerm("To")){ error("'To' expected"); return false; }
          
          _expressions Expression2;
           if (!parseExpression(Expression2)){ error(""); return false; }
          if (!typeCompatible(Variable.sType, Expression2.sType)){ error("types incompatible"); return false; }
      
          _expressions Expression3;

          bool bStep = false;
          if ((bStep = parseTerm("Step"))){                        
            if (!parseExpression(Expression3)){ error(""); return false; }
            if (!typeCompatible(Variable.sType, Expression3.sType)){ error("types incompatible"); return false; }
        
        //    sdf = sdf;

          } else {
            Expression3.Statements = Compiler::pushInteger(1);
          }

          _expressions Expression4;
          Expression4.Statements = Compiler::pushInteger(0);

          if (!parseReturn()){ error("new line expected"); return false; }

          bool bSAVE = Me.SubFunction.bLocalLoop;
          Me.SubFunction.bLocalLoop = true;
          _statements Statements;
          if (!parseStatements(Statements)){ error(""); return false; }
          Me.SubFunction.bLocalLoop = bSAVE;

          if (convertType(Variable.sType) != "Integer"){ error("'For Next' variable must be of an 'Integer' type"); return false; }
              
            

             _statements Assignment; Assignment << Compiler::push("Assignment", VariableStatements, Expression.Statements, Compiler::pushIdentifier(Variable.sType)) << Compiler::push(";");
             _statements Increment = Compiler::pushOperator("DEBUG_ANDALSO", DebugInfo, Compiler::push("Assignment", VariableStatements, Compiler::pushOperator("ADD", VariableStatements, Expression3.Statements), Compiler::pushIdentifier(Variable.sType)));

             _statements Test;
             if (bStep){            
               Test << Compiler::push("IIf", Compiler::pushOperator("GREATEREQUAL", Expression3.Statements, Expression4.Statements), Compiler::pushOperator("SMALLEREQUAL", VariableStatements, Expression2.Statements), Compiler::pushOperator("GREATEREQUAL", VariableStatements, Expression2.Statements));
             } else {
               Test << Compiler::pushOperator("SMALLEREQUAL", VariableStatements, Expression2.Statements);
             }

             if (Statements.size() > 0){
               ReturnStatement << Compiler::push("For", VariableStatements, Assignment, Test, Compiler::pushExpression(Increment), Statements);
               ReturnStatement << Compiler::push("Next");
             }

        if (!parseTerm("Next")){ error("'Next' missing"); return false; }

        QString sVariable2;
	      QString sType2;
        
        //int nTypeIndex2;
        QStringList ArrayExpression2;

        _variableconstant Variable2;
        _statements Dummy2;
        if (parseVariable(VariableStatements, Variable2, Dummy2)){
          if (Variable2.sName != Variable.sName || Variable2.sType != Variable.sType){          
            { error("variable loop index different"); return false; }
          }
        }

        if (!parseReturn()){ error("new line expected"); return false; }

        continue;
      }

      if (parseTerm("Break")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (!Me.SubFunction.bLocalLoop){ error("'Break' must be used inside a loop"); return false; }

        ReturnStatement << Compiler::push("Break");
        continue;
      }

      if (peekTerm("For", 1) && parseTerm("Exit") && parseTerm("For")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (!Me.SubFunction.bLocalLoop){ error("'Exit For' must be used inside a loop"); return false; }

        ReturnStatement << Compiler::push("Break");
        continue;
      }

      if (peekTerm("Do", 1) && parseTerm("Exit") && parseTerm("Do")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (!Me.SubFunction.bLocalLoop){ error("'Exit Do' must be used inside a loop"); return false; }

        ReturnStatement << Compiler::push("Break");
        continue;
      }


      if (parseTerm("Continue")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (!Me.SubFunction.bLocalLoop){ error("'Continue' must be used inside a loop"); return false; }

        ReturnStatement << Compiler::push("Continue");
        continue;
      }

      if (peekTerm("For", 1) && parseTerm("Iterate") && parseTerm("For")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (!Me.SubFunction.bLocalLoop){ error("'Iterate For' must be used inside a loop"); return false; }

        ReturnStatement << Compiler::push("Continue");
        continue;
      }

      if (peekTerm("Do", 1) && parseTerm("Iterate") && parseTerm("Do")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (!Me.SubFunction.bLocalLoop){ error("'Iterate Do' must be used inside a loop"); return false; }
        
        ReturnStatement << Compiler::push("Continue");
        continue;
      }

      
      if (Me.nLine == 2460){
        Me.nLine = Me.nLine;
      }



      bool bExit = false;
      if (parseTerm("Return") || (bExit = parseTerm("Exit"))){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");

        if (bExit){
          if (Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"){
            if (!parseTerm("Event")){ error(""); return false; } 
          } else if (Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"){
            if (!parseTerm("Signal")){ error(""); return false; } 
          } else if (Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Sub"){
            if (!parseTerm("Sub")){ error(""); return false; } 
          } else {
            if (!parseTerm("Function")){ error("'Function' missing"); return false; } 

            Me.SubFunction.bExitFunctionUsed = true;    

            ReturnStatement << Compiler::push("Exit Function");

            continue;
          }

          ReturnStatement << Compiler::push("Return");

          continue;
        }

        if (
          Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot != "Function"
          && Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot != "Event"
          && Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot != "Delegate"
        ){

          ReturnStatement << Compiler::push("Return");
          _expressions Expression;
          if (parseExpression(Expression)){ 
            error(""); return false; 
          }
          continue;

        } else {


            if (Me.nLine == 2460){
              Me.nLine = Me.nLine;
            }


          _expressions Expression;
          if (!parseExpression(Expression)){ 
            if (              
              Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"
              || Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"
              || Me.SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"
              ){ 

              ReturnStatement << Compiler::push("Return");
              continue;

             } else {
                error(""); return false; 
             }
          }

          bool bHasReturnType = !Me.SubFunction.sType.isEmpty();
          if (bHasReturnType){
            if (!typeCompatible(Me.SubFunction.sType, Expression.sType)){ error("types incompatible"); return false; }
          }
          ReturnStatement << Compiler::push("Return ?", Expression.Statements);

        }

        continue;
      }

      if (parseTerm("GoTo")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");          
        
        QString sIdentifier;
        if (!parseIdentifier(&sIdentifier)){ error("identifier expected"); return false; }

        if (isCppObjcKeyword(sIdentifier, "Name for GoTo")) return false;

        ReturnStatement << Compiler::push("GoTo", Compiler::pushIdentifier(sIdentifier));

        Me.SubFunction.GoTos << _label(sIdentifier, Me.nLine);

        if (!parseReturn()){ error(""); return false; }

        continue;
      }

      if (parseTerm("IIf")){

        ReturnStatement << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");          
        
        if (!parseTerm("(")){ error("'(' expected"); return false; }
        _expressions Condition;
        if (!parseCondition(Condition)){ error(""); return false; }
        if (!parseTerm(",")){ error("',' expected"); return false; }

        _statements Statements;
        _statements AllStatements;
        do {
          if (!parseStatements(Statements, true)){ error(""); return false; }
          AllStatements << Statements;
        } while (parseReturn(true));

        if (!parseTerm(",")){ error("',' expected"); return false; }

        _statements Statements2;
        _statements AllStatements2;
        do {
          if (!parseStatements(Statements2, true)){ error(""); return false; }
          AllStatements2 << Statements2;
        } while (parseReturn(true));

        if (!parseTerm(")")){ error("')' expected"); return false; }
        if (!parseReturn()){ error("new line expected"); return false; }

        ReturnStatement << Compiler::push("If", Condition.Statements, Statements);
        ReturnStatement << Compiler::push("Else", Statements2);
        ReturnStatement << Compiler::push("End If");

        continue;                    
      }
    }
    
    if (peekIdentifier(0) && peekTerm(":", 1) && peekReturn(2)){

      QString sIdentifier;
      if (!parseIdentifier(&sIdentifier)){ error("identifier expected"); return false; }

      if (isCppObjcKeyword(sIdentifier, "Name for label")) return false;

      if (!parseTerm(":", true)){ error(""); return false; }
      if (!parseReturn()){ error(""); return false; }

      Me.SubFunction.Labels << _label(sIdentifier, Me.nLine);

      ReturnStatement << Compiler::push("Label", Compiler::pushIdentifier(sIdentifier));

      continue;
    }

    _statements DebugInfo;
    DebugInfo << Compiler::pushDebug(Compiler::pushIdentifier(Me.sFileName), Compiler::pushIdentifier(Me.SubFunction.sName), Compiler::pushIdentifier(QString("%1").arg(Me.nLine)), Compiler::pushIdentifier("1")) << Compiler::push(";");          

    _statements StatementsSAVE = ReturnStatement;
    ReturnStatement.clear();
    _statements Statements2 = _statements();
    
    if (parseLocalConst(Statements2)){ 
      ReturnStatement << StatementsSAVE << DebugInfo << Statements2;
      continue; 
    }

    if (parseLocalDim(Statements2)){ 
      ReturnStatement << StatementsSAVE << DebugInfo << Statements2;
      continue; 
    }

    if (parseAssignment(Statements2)){ 
      ReturnStatement << StatementsSAVE << DebugInfo << Statements2;
      continue; 
    }

    if (parseFactor(Statements2)){
      ReturnStatement << StatementsSAVE << DebugInfo << Statements2;
      continue; 
    }


    ReturnStatement << StatementsSAVE << Statements2;

    break;
  }  

  
  for (int qz = 0; qz < Me.SubFunction.GoTos.count(); qz++){
    if (!Me.SubFunction.Labels.contains(Me.SubFunction.GoTos.at(qz))){
      { error("Label " + Me.SubFunction.GoTos.at(qz).sName + " has not been declared in line " + Me.SubFunction.GoTos.at(qz).nLine); break; }
    }
  }

  
  for (int qz = 0; Me.bError == false && qz < Me.SubFunction.Labels.count() && qz < Me.SubFunction.GoTos.count(); qz++){
    if (Me.SubFunction.GoTos.at(qz).nLine < Me.SubFunction.Labels.at(qz).nLine && Me.SubFunction.GoTos.at(qz).sName == Me.SubFunction.Labels.at(qz).sName){
      for (int xx = 0; xx < Me.SubFunction.VariablesConstants.count(); xx++){
        if (Me.SubFunction.VariablesConstants.at(xx).nLine > Me.SubFunction.GoTos.at(qz).nLine && Me.SubFunction.VariablesConstants.at(xx).nLine < Me.SubFunction.Labels.at(qz).nLine){
          { error(QString("GoTo (in line %1) to label ").arg(Me.SubFunction.GoTos.at(qz).nLine) + Me.SubFunction.Labels.at(qz).sName + " by-passes declaration of " + Me.SubFunction.VariablesConstants.at(xx).sName + QString(" in line %1 in file %2\n").arg(Me.SubFunction.VariablesConstants.at(xx).nLine).arg(Me.sFileName)); return false; }
        }
      }

    }
  }
 
  return true;
}





#include "_Q7BCompiler.h"

//addHierarchy("QMenuBar", "QWidget", "QObject");
//addHierarchy("QPushButton", "QAbstractButton", "QWidget", "QObject");

void Parser::addHierarchy(QString sClass, QString sSuperClass)
{
  if (sClass == "Class") return;
  if (sClass == "Dictionary") return;
  if (sClass == "List") return;
  if (sClass == "Module") return;  
  if (sClass == "uiClass") return;  
  if (sClass == "FormClass") return;  




  //if (sSuperClass.isEmpty()) return;


}

QString Parser::plainCType(QString sCast)
{
  sCast = sCast.replace("*", "");
  sCast = sCast.replace("&", "");
  return sCast;
}

bool Parser::StringInit(QString l, QString r)
{
  
  if (l == "String" || r == "String"){
    if (l == "NSData" || r == "NSData") return true;
    if (l == "NSImage" || r == "NSImage") return true;
    if (l == "NSMenu" || r == "NSMenu") return true;
    if (l == "NSMenuItem" || r == "NSMenuItem") return true;
  }
  return false;
}

QString Parser::convertType(QString s)
{

  if (s == "Byte" || s == "Short" || s == "Int8" || s == "Int16" || s == "Int32" || s == "Int64")
    return "Integer";

  if (s == "Single" || s == "Double")
    return "Float";

  if (s == "CString")
    return "String";

  if (s == "Object")
    return "id";

  if (s.contains(".")) return "Integer";  

    return s;
}


bool Parser::checkClassHierarchy(QString l, QString r)
{
  if (Me.Classes.contains(l) && Me.Classes.contains(r)){
    return true; 
  }    

  if (Me.Classes.contains(l)){
    l = Me.Classes[l]; 
  }          

  if (Me.Classes.contains(r)){
    r = Me.Classes[r]; 
  }    
  if (l == r) return true;

  if (l == "NSView"){
      l = l;
  }
  if (Me.super_classes.contains(l)){
    QStringList h = Me.super_classes[l];
    QString asfd = h.join(";");
    if (h.contains(r)){
      return true;
    }
  }

  if (Me.super_classes.contains(r)){
    QStringList h = Me.super_classes[r];
   // QString asfd = h.join(";");
    if (h.contains(l)){
      return true;
    }
  }
  return false;
}

bool Parser::typeCompatible(QString l, QString r, QString o)
{



  l = convertDeclareType(l);
  r = convertDeclareType(r);

  l = convertType(l);
  r = convertType(r);

 // if (l == "NSString") l = "String";

  if (o.isEmpty()){ 
    if (l == r) return true;
    if (l == "id" || r == "id") return true; 

    if (StringInit(l, r)){ 
      return true;
    } else if (l == "Boolean"){
      return false;

    } else if (l == "String"){
      return false;

    } else if (l == "DateTime"){
      return false;

    } else if (l == "Integer"){
      return r == "Float" || r == "Decimal" || r == "id";

    } else if (l == "Float"){
      return r == "Integer" || r == "Decimal" || r == "id";

    } else if (l == "Decimal"){
      return r == "Integer" || r == "Float" || r == "id";

    } else { 

      if (checkClassHierarchy(l, r)){
        return true;
      }      

    }

  } else {
    if (l == "id" || r == "id") return true; 

    if (o == ("MUL") || o == ("POWER")){
      return (l == "Integer" || l == "Float" || l == "Decimal") && (r == "Integer" || r == "Float" || r == "Decimal");
    } else if (o == ("DIV")){
      return (l == "Integer" || l == "Float" || l == "Decimal") && (r == "Integer" || r == "Float" || r == "Decimal");
    } else if (o == ("IDIV")){
      return (l == "Integer" || l == "Float" || l == "Decimal") && (r == "Integer" || r == "Float" || r == "Decimal");
    } else if (o == ("MOD")){
      return (l == "Integer" || l == "Float" || l == "Decimal") && (r == "Integer" || r == "Float" || r == "Decimal");

    } else if (o == ("ADD")){
      if (l == "String") return true;
      if ((l == "Integer" || l == "Float" || l == "Decimal") && (r == "Integer" || r == "Float" || r == "Decimal")) return true;

#ifdef QTBASIC 
#else // OBJB
      if ((l == "NSArray" || l == "NSMutableArray" || l == "Array") && (r == "NSArray" || r == "NSMutableArray" || r == "Array")) return true;
#endif 
      return false;

    } else if (o == ("CONCAT")){

      return l == "String" || r == "String";
    } else if (o == ("SUB")){
      return (l == "Integer" || l == "Float" || l == "Decimal") && (r == "Integer" || r == "Float" || r == "Decimal");

    } else if (o == ("SHR")){
      return l == "Integer" && r == "Integer";
    } else if (o == ("SHL")){
      return l == "Integer" && r == "Integer";

    } else if (o == ("EQUALEQUAL")){
      return true; 
    } else if (o == ("EQUALEQUALEQUAL")){
      return true; 
    } else if (o == ("EQUAL")){
      if (l == "String") return true;
      if ((l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean")) return true;
      if (l == r) return true;

      if (checkClassHierarchy(l, r)){
        return true;
      }      

    } else if (o == ("UNEQUAL")){
      if (l == "String") return true;
      if ((l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean")) return true;
      if (l == r) return true;

      if (checkClassHierarchy(l, r)){
        return true;
      }     

    } else if (o == ("GREATER")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("SMALLER")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("GREATEREQUAL")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("SMALLEREQUAL")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");

    } else if (o == ("AND")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("OR")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("XOR")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("ANDALSO")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");
    } else if (o == ("ORELSE")){
      return (l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean") && (r == "Integer" || r == "Float" || r == "Decimal" || r == "Boolean");

    
    } else if (o == ("NOT")){
      return l == "Integer" || l == "Float" || l == "Decimal" || l == "Boolean" || l == "String"; 
    } else if (o == ("FLIP")){
      return l == "Integer";
    } else if (o == ("+")){
      return l == "Integer" || l == "Float" || l == "Decimal";
    } else if (o == ("-")){
      return l == "Integer" || l == "Float" || l == "Decimal";      

    }
    
  }
  return false;
}

void Parser::addEnumType(QString sFileName, QString sName, QString sPublicPrivateGlobal, QStringList EnumNames, QList<_statements> & EnumValues)
{
  if (Me.nPass == 0){
    _enumeration Enum;

    Enum.sPublicPrivateGlobal = sPublicPrivateGlobal;
    Enum.sFileName = sFileName;
    Enum.sName = sName;

    Enum.EnumNames = EnumNames;
    Enum.EnumValues = EnumValues;

    if (sPublicPrivateGlobal == "Global"){
      Me.GlobalEnums[sName] = Enum;
    } else {
      Me.Enums[getClassName(sFileName)][sName] = Enum;
    }  
  }
}

void Parser::addTypeType(QString sFileName, QString sName, QString sPublicPrivateGlobal, QStringList names, QStringList types, QList<_array>arrays, QList<int> sizes, QStringList encodings)
{
  if (Me.nPass == 0){
    _type Type;

    Type.sPublicPrivateGlobal = sPublicPrivateGlobal;
    Type.sFileName = sFileName;
    Type.sName = sName;

    Type.Names = names;
    Type.Types = types;
    Type.Arrays = arrays;
    Type.Sizes = sizes;
    Type.Encodings = encodings;

    if (sPublicPrivateGlobal == "Global"){
      Me.GlobalTypes[sName] = Type;
    } else {
      Me.Types[getClassName(sFileName)][sName] = Type;
    }

  }
}

void Parser::addSubFunction(QString sSubFunctionIBActionActionSignalEventDelegateSlot, QString sFileName, QString sName, _statements Statements, QString sPublicPrivateGlobal, QList<_argument> Arguments, QString sType, _array & Array)
{

  bool bExists = false;

  QString sKey;
  if (sSubFunctionIBActionActionSignalEventDelegateSlot != "Delegate"){ 
    sKey = sName;
  } else {
      sKey = sName + QString().fill(':', Arguments.count());
  }

  if (sName == "tableView"){
      sName=sName;
       }
  if (Me.nPass == 0 && sSubFunctionIBActionActionSignalEventDelegateSlot != "Delegate"){ 
    if (sPublicPrivateGlobal == "Global"){
      bExists = Me.GlobalSubsFunctions.contains(sKey);
    } else {
      bExists = Me.SubsFunctions[getClassName(sFileName)].contains(sKey);
    }

    if (bExists){
      
      error("sub or function already declared with the same name in the same class '" + sName + "'"); return;
    }
  }
  
  

  if (isCppObjcKeyword(sName, "Name of procedure")) return;

  _subfunction SubFunction;
  
  SubFunction.sFileName = sFileName;
  SubFunction.sPublicPrivateGlobal = sPublicPrivateGlobal;
  SubFunction.sSubFunctionIBActionActionSignalEventDelegateSlot = sSubFunctionIBActionActionSignalEventDelegateSlot;
  SubFunction.sName = sName;
  SubFunction.Arguments = Arguments;

  SubFunction.sType = sType;

  SubFunction.Statements = Statements;

  SubFunction.bCallAble = 
      ! (sSubFunctionIBActionActionSignalEventDelegateSlot == "Event"
      || sSubFunctionIBActionActionSignalEventDelegateSlot == "Action"
      || sSubFunctionIBActionActionSignalEventDelegateSlot == "Delegate"
      || sSubFunctionIBActionActionSignalEventDelegateSlot == "Signal"
   );

  SubFunction.Array = Array;

  if (sPublicPrivateGlobal == "Global"){
    Me.GlobalSubsFunctions[sKey] = SubFunction;
  } else {
    Me.SubsFunctions[getClassName(sFileName)][sKey] = SubFunction;
  }

}

void Parser::addLocalVariable(QString sName, QString sType, bool bConstant, _statements Statement, _array Array, bool bStatic)
{
  {
    for (int i = 0; i < Me.SubFunction.Arguments.size(); i++){

      _argument Argument = Me.SubFunction.Arguments.at(i);

      if (Argument.sName == sName){
        
        error("An argument is already declared with the same name in the same sub/function and scope '" + sName + "'"); return;
      }

    }

    for (int i = 0; i < Me.SubFunction.VariablesConstants.size(); i++){

      _variableconstant vc = Me.SubFunction.VariablesConstants.at(i);

       if (vc.sName == sName && vc.nBlock >= Me.nBlock){
         
         error("local variable or local constant '" + sName + "' already declared with the same name in the same sub/function and scope"); return;
       }     
       //cout << i.key() << ": " << i.value() << endl;
    }
   
    
  	
    _variableconstant vc;

    vc.sFileName = Me.sFileName;
    vc.nLine = Me.nLine;
    vc.sPublicPrivateGlobalLocal = "Local";
    vc.sName = sName;
    vc.sType = sType;
    vc.bConstant = bConstant;
    vc.nBlock = Me.nBlock;
    vc.Array = Array;

    Me.SubFunction.VariablesConstants << vc;

  }
}

void Parser::addVariable(QString sName, QString sType, QString sPrivatePublicGlobal, bool bConstant, bool bOutlet, _array & Array, bool bSet)
{
  if (getClassName(Me.sFileName) == "MainWindow" && Me.nLine > 1000){
    sName = sName;
  }
  if (sName == "bBlockLastPosition"){
    sName = sName;
  }
  
  if (sPrivatePublicGlobal == "Global"){
    if (Me.nPass == 0 && Me.GlobalVariablesConstants.contains(sName)){
       error("variable or constant '" + sName + "' already declared with the same name with keyword Global in global space (sub or function declared with keyword 'Global')"); return;
    }
  } else {
    if (Me.nPass == 0 && Me.VariablesConstants[getClassName(Me.sFileName)].contains(sName)){
      error("variable or constant '" + sName + "' already declared with the same name in the same class"); return;
    }
  }

  _variableconstant vc;

  vc.sFileName = Me.sFileName;
  vc.nLine = Me.nLine;
  vc.sPublicPrivateGlobalLocal = sPrivatePublicGlobal;
  vc.sName = sName;
  vc.sType = sType;
  vc.bConstant = bConstant;
  vc.nBlock = 0;
  vc.Array = Array;
  vc.bOutlet = bOutlet;

  if (sPrivatePublicGlobal == "Global"){
    Me.GlobalVariablesConstants[vc.sName] = vc;
  } else {
    Me.VariablesConstants[getClassName(Me.sFileName)][vc.sName] = vc;
  }

  if (Me.nPass == 1){
  
      Me.sOutletsName[Me.sFileName] << sName;
      Me.sOutletsType[Me.sFileName] << sType;
      Me.sOutletsSet[Me.sFileName] << ( bSet ? "true" : "");    
    }

}










#include "_Q7BCompiler.h"

// !!!! * The following code is generated. Do not touch it. * !!!!







#include "_Q7BCompiler.h"




inline bool isWhitespace(const QString & s, int p, int len){ return s.at(p + 0) == '\v' || s.at(p + 0) == '\t' || s.at(p + 0) == '\r' || s.at(p + 0) == ' '; }



inline bool isSeparator(const QString & s, int p, int len){ return s.at(p + 0) == '|' || s.at(p + 0) == '_' || s.at(p + 0) == '^' || s.at(p + 0) == ']' || s.at(p + 0) == '}' || s.at(p + 0) == '\n' || s.at(p + 0) == '\"' || s.at(p + 0) == '[' || s.at(p + 0) == '{' || (s.at(p + 0) == '>' && p + 1 < len && s.at(p + 1) == '=') || s.at(p + 0) == '>' || (s.at(p + 0) == '=' && p + 1 < len && s.at(p + 1) == '=' && p + 2 < len && s.at(p + 2) == '=') || (s.at(p + 0) == '=' && p + 1 < len && s.at(p + 1) == '=') || s.at(p + 0) == '=' || s.at(p + 0) == '=' || (s.at(p + 0) == '<' && p + 1 < len && s.at(p + 1) == 's' && p + 2 < len && s.at(p + 2) == 't' && p + 3 < len && s.at(p + 3) == 'r' && p + 4 < len && s.at(p + 4) == 'i' && p + 5 < len && s.at(p + 5) == 'n' && p + 6 < len && s.at(p + 6) == 'g' && p + 7 < len && s.at(p + 7) == '>') || (s.at(p + 0) == '<' && p + 1 < len && s.at(p + 1) == '>') || (s.at(p + 0) == '<' && p + 1 < len && s.at(p + 1) == '=') || (s.at(p + 0) == '<' && p + 1 < len && s.at(p + 1) == '/' && p + 2 < len && s.at(p + 2) == 's' && p + 3 < len && s.at(p + 3) == 't' && p + 4 < len && s.at(p + 4) == 'r' && p + 5 < len && s.at(p + 5) == 'i' && p + 6 < len && s.at(p + 6) == 'n' && p + 7 < len && s.at(p + 7) == 'g' && p + 8 < len && s.at(p + 8) == '>') || s.at(p + 0) == '<' || s.at(p + 0) == ';' || (s.at(p + 0) == ':' && (p + 1 >= len || s.at(p + 1) != ':')) || s.at(p + 0) == '/' || s.at(p + 0) == '.' || s.at(p + 0) == '-' || s.at(p + 0) == ',' || s.at(p + 0) == '+' || (s.at(p + 0) == '*' && p + 1 < len && s.at(p + 1) == '*') || s.at(p + 0) == '*' || s.at(p + 0) == ')' || s.at(p + 0) == '(' || s.at(p + 0) == '\'' || s.at(p + 0) == '\\' || s.at(p + 0) == '&' || s.at(p + 0) == '$' || s.at(p + 0) == '#' || s.at(p + 0) == '!'; }



QStringList Scanner::scan(QString s, bool *bError, QString *sError, int *nErrorLine)
{



int len = s.length();
bool bString1 = false;
bool bString11 = false;
bool bString2 = false;
bool bString22 = false;
bool bIdentifier = false;
bool bTemplate = false;
bool bKeyword = false;
bool bNumber = false;
bool bNumberX = false;
bool bNumberDot = false;
bool bNumberE = false;
bool bNumberPlusMinus1 = false;
bool bNumberPlusMinus2 = false;
bool bNumberEDone = false;
bool bNewLine = false;
bool bComment = false;
bool bDotDot = false;
int nComment = -1;
int nComment2 = -1;
int nStringLine = -1;
int nString = -1;
int nNumber = -1;
int nIdentifier = -1;
int nCurrentLine = 1;
int l = 0;
QString v;
QStringList tokens;
QChar c00;
QChar c0;
QChar c1;
QChar c2;
int p = 0;


char cc0 = 0;
char cc1 = 0;
char cc2 = 0;

for (; *bError == false && p < len; p++){
c00 = p - 1 > 0 ? s.at(p - 1) : 0;
c0 = s.at(p + 0);
c1 = p + 1 < len ? s.at(p + 1) : 0;
c2 = p + 2 < len ? s.at(p + 2) : 0;

cc0 = c0.toLatin1();
cc1 = c1.toLatin1();
cc2 = c2.toLatin1();

if (c0 == '\r') continue;
if (bString1 && (c0 != '\n' && (c0 != '\"' || c1 == '\"'))){
  if (c0 == '\"' && c1 == '\"'){ p++; continue; }
  if (c0 == '\\' && c1 == '\"' && c00 != '\\'){ p++; continue; }
  continue;
  
}
if (bString2 && !(c0 == '<' && c1 == '/' && c2 == 's' && p + 3 < len && s.at(p + 3) == 't' && p + 4 < len && s.at(p + 4) == 'r' && p + 5 < len && s.at(p + 5) == 'i' && p + 6 < len && s.at(p + 6) == 'n' && p + 7 < len && s.at(p + 7) == 'g' && p + 8 < len && s.at(p + 8) == '>' && p + 9 < len && (s.at(p + 9).isDigit() || s.at(p + 9).isLetter() || isWhitespace(s, p + 9, len) || isSeparator(s, p + 9, len)))) continue;

if (!bString1 && !bString2 && c0 == '\n') (*nErrorLine)++;if (!bString1 && !bString2 && isWhitespace(s, p + 0, len)){
  if (bIdentifier || bNumber){
  l = 0; goto identifier; }
 continue;
}


if (!bIdentifier && !bNumber && c0.isLetter()){
switch(c0.toLatin1()){
case 'A':
if (c1 == 's' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "As"; l = 1; bKeyword = true; goto identifier; }

if (c1 == 'n' && c2 == 'd' && p + 3 < len && s.at(p + 3) == 'A' && p + 4 < len && s.at(p + 4) == 'l' && p + 5 < len && s.at(p + 5) == 's' && p + 6 < len && s.at(p + 6) == 'o' && (p + 7 == len || (p + 7 < len && (isWhitespace(s, p + 7, len) || isSeparator(s, p + 7, len))))){ v = "AndAlso"; l = 6; bKeyword = true; goto identifier; }

if (c1 == 'n' && c2 == 'd' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "And"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'l' && c2 == 'i' && p + 3 < len && s.at(p + 3) == 'a' && p + 4 < len && s.at(p + 4) == 's' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Alias"; l = 4; bKeyword = true; goto identifier; }

break;
case 'B':
if (c1 == 'y' && c2 == 'V' && p + 3 < len && s.at(p + 3) == 'a' && p + 4 < len && s.at(p + 4) == 'l' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "ByVal"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'y' && c2 == 'R' && p + 3 < len && s.at(p + 3) == 'e' && p + 4 < len && s.at(p + 4) == 'f' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "ByRef"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'r' && c2 == 'e' && p + 3 < len && s.at(p + 3) == 'a' && p + 4 < len && s.at(p + 4) == 'k' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Break"; l = 4; bKeyword = true; goto identifier; }

break;
case 'C':
if (c1 == 'o' && c2 == 'n' && p + 3 < len && s.at(p + 3) == 't' && p + 4 < len && s.at(p + 4) == 'i' && p + 5 < len && s.at(p + 5) == 'n' && p + 6 < len && s.at(p + 6) == 'u' && p + 7 < len && s.at(p + 7) == 'e' && (p + 8 == len || (p + 8 < len && (isWhitespace(s, p + 8, len) || isSeparator(s, p + 8, len))))){ v = "Continue"; l = 7; bKeyword = true; goto identifier; }

if (c1 == 'o' && c2 == 'n' && p + 3 < len && s.at(p + 3) == 's' && p + 4 < len && s.at(p + 4) == 't' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Const"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'l' && c2 == 'a' && p + 3 < len && s.at(p + 3) == 's' && p + 4 < len && s.at(p + 4) == 's' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Class"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'a' && c2 == 's' && p + 3 < len && s.at(p + 3) == 'e' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Case"; l = 3; bKeyword = true; goto identifier; }

break;
case 'D':
if (c1 == 'o' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "Do"; l = 1; bKeyword = true; goto identifier; }

if (c1 == 'i' && c2 == 'm' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Dim"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'e' && c2 == 'c' && p + 3 < len && s.at(p + 3) == 'l' && p + 4 < len && s.at(p + 4) == 'a' && p + 5 < len && s.at(p + 5) == 'r' && p + 6 < len && s.at(p + 6) == 'e' && (p + 7 == len || (p + 7 < len && (isWhitespace(s, p + 7, len) || isSeparator(s, p + 7, len))))){ v = "Declare"; l = 6; bKeyword = true; goto identifier; }

break;
case 'E':
if (c1 == 'x' && c2 == 'i' && p + 3 < len && s.at(p + 3) == 't' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Exit"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'v' && c2 == 'e' && p + 3 < len && s.at(p + 3) == 'n' && p + 4 < len && s.at(p + 4) == 't' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Event"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'n' && c2 == 'u' && p + 3 < len && s.at(p + 3) == 'm' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Enum"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'n' && c2 == 'd' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "End"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'l' && c2 == 's' && p + 3 < len && s.at(p + 3) == 'e' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Else"; l = 3; bKeyword = true; goto identifier; }

break;
case 'F':
if (c1 == 'u' && c2 == 'n' && p + 3 < len && s.at(p + 3) == 'c' && p + 4 < len && s.at(p + 4) == 't' && p + 5 < len && s.at(p + 5) == 'i' && p + 6 < len && s.at(p + 6) == 'o' && p + 7 < len && s.at(p + 7) == 'n' && (p + 8 == len || (p + 8 < len && (isWhitespace(s, p + 8, len) || isSeparator(s, p + 8, len))))){ v = "Function"; l = 7; bKeyword = true; goto identifier; }

if (c1 == 'o' && c2 == 'r' && p + 3 < len && s.at(p + 3) == 'm' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Form"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'o' && c2 == 'r' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "For"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'l' && c2 == 'i' && p + 3 < len && s.at(p + 3) == 'p' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Flip"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'a' && c2 == 'l' && p + 3 < len && s.at(p + 3) == 's' && p + 4 < len && s.at(p + 4) == 'e' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "False"; l = 4; bKeyword = true; goto identifier; }

break;
case 'G':
if (c1 == 'o' && c2 == 'T' && p + 3 < len && s.at(p + 3) == 'o' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "GoTo"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'l' && c2 == 'o' && p + 3 < len && s.at(p + 3) == 'b' && p + 4 < len && s.at(p + 4) == 'a' && p + 5 < len && s.at(p + 5) == 'l' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Global"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'e' && c2 == 't' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Get"; l = 2; bKeyword = true; goto identifier; }

break;
case 'I':
if (c1 == 't' && c2 == 'e' && p + 3 < len && s.at(p + 3) == 'r' && p + 4 < len && s.at(p + 4) == 'a' && p + 5 < len && s.at(p + 5) == 't' && p + 6 < len && s.at(p + 6) == 'e' && (p + 7 == len || (p + 7 < len && (isWhitespace(s, p + 7, len) || isSeparator(s, p + 7, len))))){ v = "Iterate"; l = 6; bKeyword = true; goto identifier; }

if (c1 == 's' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "Is"; l = 1; bKeyword = true; goto identifier; }

if (c1 == 'f' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "If"; l = 1; bKeyword = true; goto identifier; }

if (c1 == 'I' && c2 == 'f' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "IIf"; l = 2; bKeyword = true; goto identifier; }

break;
case 'L':
if (c1 == 'o' && c2 == 'o' && p + 3 < len && s.at(p + 3) == 'p' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Loop"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'B' && c2 == 'o' && p + 3 < len && s.at(p + 3) == 'u' && p + 4 < len && s.at(p + 4) == 'n' && p + 5 < len && s.at(p + 5) == 'd' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "LBound"; l = 5; bKeyword = true; goto identifier; }

break;
case 'M':
if (c1 == 'o' && c2 == 'd' && p + 3 < len && s.at(p + 3) == 'u' && p + 4 < len && s.at(p + 4) == 'l' && p + 5 < len && s.at(p + 5) == 'e' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Module"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'o' && c2 == 'd' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Mod"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'i' && c2 == 'd' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Mid"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'e' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "Me"; l = 1; bKeyword = true; goto identifier; }

break;
case 'N':
if (c1 == 'u' && c2 == 'l' && p + 3 < len && s.at(p + 3) == 'l' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Null"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'o' && c2 == 't' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Not"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'e' && c2 == 'x' && p + 3 < len && s.at(p + 3) == 't' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){
  v = "Next"; l = 3; bKeyword = true; goto identifier;
}

break;
case 'O':
if (c1 == 'u' && c2 == 't' && p + 3 < len && s.at(p + 3) == 'l' && p + 4 < len && s.at(p + 4) == 'e' && p + 5 < len && s.at(p + 5) == 't' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Outlet"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'r' && c2 == 'E' && p + 3 < len && s.at(p + 3) == 'l' && p + 4 < len && s.at(p + 4) == 's' && p + 5 < len && s.at(p + 5) == 'e' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "OrElse"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'r' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "Or"; l = 1; bKeyword = true; goto identifier; }

break;
case 'P':
if (c1 == 'u' && c2 == 'b' && p + 3 < len && s.at(p + 3) == 'l' && p + 4 < len && s.at(p + 4) == 'i' && p + 5 < len && s.at(p + 5) == 'c' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Public"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'r' && c2 == 'o' && p + 3 < len && s.at(p + 3) == 'p' && p + 4 < len && s.at(p + 4) == 'e' && p + 5 < len && s.at(p + 5) == 'r' && p + 6 < len && s.at(p + 6) == 't' && p + 7 < len && s.at(p + 7) == 'y' && (p + 8 == len || (p + 8 < len && (isWhitespace(s, p + 8, len) || isSeparator(s, p + 8, len))))){ v = "Property"; l = 7; bKeyword = true; goto identifier; }

if (c1 == 'r' && c2 == 'i' && p + 3 < len && s.at(p + 3) == 'v' && p + 4 < len && s.at(p + 4) == 'a' && p + 5 < len && s.at(p + 5) == 't' && p + 6 < len && s.at(p + 6) == 'e' && (p + 7 == len || (p + 7 < len && (isWhitespace(s, p + 7, len) || isSeparator(s, p + 7, len))))){ v = "Private"; l = 6; bKeyword = true; goto identifier; }

if (c1 == 'r' && c2 == 'e' && p + 3 < len && s.at(p + 3) == 's' && p + 4 < len && s.at(p + 4) == 'e' && p + 5 < len && s.at(p + 5) == 'r' && p + 6 < len && s.at(p + 6) == 'v' && p + 7 < len && s.at(p + 7) == 'e' && (p + 8 == len || (p + 8 < len && (isWhitespace(s, p + 8, len) || isSeparator(s, p + 8, len))))){ v = "Preserve"; l = 7; bKeyword = true; goto identifier; }

break;
case 'R':
if (c1 == 'e' && c2 == 't' && p + 3 < len && s.at(p + 3) == 'u' && p + 4 < len && s.at(p + 4) == 'r' && p + 5 < len && s.at(p + 5) == 'n' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Return"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'e' && c2 == 'D' && p + 3 < len && s.at(p + 3) == 'i' && p + 4 < len && s.at(p + 4) == 'm' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "ReDim"; l = 4; bKeyword = true; goto identifier; }

break;
case 'S':
if (c1 == 'u' && c2 == 'p' && p + 3 < len && s.at(p + 3) == 'e' && p + 4 < len && s.at(p + 4) == 'r' && p + 5 < len && s.at(p + 5) == 'C' && p + 6 < len && s.at(p + 6) == 'l' && p + 7 < len && s.at(p + 7) == 'a' && p + 8 < len && s.at(p + 8) == 's' && p + 9 < len && s.at(p + 9) == 's' && (p + 10 == len || (p + 10 < len && (isWhitespace(s, p + 10, len) || isSeparator(s, p + 10, len))))){ v = "SuperClass"; l = 9; bKeyword = true; goto identifier; }

if (c1 == 'u' && c2 == 'p' && p + 3 < len && s.at(p + 3) == 'e' && p + 4 < len && s.at(p + 4) == 'r' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Super"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'u' && c2 == 'b' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Sub"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 't' && c2 == 'e' && p + 3 < len && s.at(p + 3) == 'p' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Step"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 't' && c2 == 'a' && p + 3 < len && s.at(p + 3) == 't' && p + 4 < len && s.at(p + 4) == 'i' && p + 5 < len && s.at(p + 5) == 'c' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Static"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'l' && c2 == 'o' && p + 3 < len && s.at(p + 3) == 't' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Slot"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'i' && c2 == 'g' && p + 3 < len && s.at(p + 3) == 'n' && p + 4 < len && s.at(p + 4) == 'a' && p + 5 < len && s.at(p + 5) == 'l' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Signal"; l = 5; bKeyword = true; goto identifier; }

if (c1 == 'h' && c2 == 'r' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Shr"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'h' && c2 == 'l' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Shl"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'e' && c2 == 't' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Set"; l = 2; bKeyword = true; goto identifier; }

if (c1 == 'e' && c2 == 'l' && p + 3 < len && s.at(p + 3) == 'e' && p + 4 < len && s.at(p + 4) == 'c' && p + 5 < len && s.at(p + 5) == 't' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "Select"; l = 5; bKeyword = true; goto identifier; }

break;
case 'T':
if (c1 == 'y' && c2 == 'p' && p + 3 < len && s.at(p + 3) == 'e' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Type"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'r' && c2 == 'u' && p + 3 < len && s.at(p + 3) == 'e' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "True"; l = 3; bKeyword = true; goto identifier; }

if (c1 == 'o' && (p + 2 == len || (p + 2 < len && (isWhitespace(s, p + 2, len) || isSeparator(s, p + 2, len))))){ v = "To"; l = 1; bKeyword = true; goto identifier; }

if (c1 == 'h' && c2 == 'e' && p + 3 < len && s.at(p + 3) == 'n' && (p + 4 == len || (p + 4 < len && (isWhitespace(s, p + 4, len) || isSeparator(s, p + 4, len))))){ v = "Then"; l = 3; bKeyword = true; goto identifier; }

break;
case 'U':
if (c1 == 'n' && c2 == 't' && p + 3 < len && s.at(p + 3) == 'i' && p + 4 < len && s.at(p + 4) == 'l' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "Until"; l = 4; bKeyword = true; goto identifier; }

if (c1 == 'B' && c2 == 'o' && p + 3 < len && s.at(p + 3) == 'u' && p + 4 < len && s.at(p + 4) == 'n' && p + 5 < len && s.at(p + 5) == 'd' && (p + 6 == len || (p + 6 < len && (isWhitespace(s, p + 6, len) || isSeparator(s, p + 6, len))))){ v = "UBound"; l = 5; bKeyword = true; goto identifier; }

break;
case 'V':
if (c1 == 'a' && c2 == 'r' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Var"; l = 2; bKeyword = true; goto identifier; }

break;
case 'W':
if (c1 == 'h' && c2 == 'i' && p + 3 < len && s.at(p + 3) == 'l' && p + 4 < len && s.at(p + 4) == 'e' && (p + 5 == len || (p + 5 < len && (isWhitespace(s, p + 5, len) || isSeparator(s, p + 5, len))))){ v = "While"; l = 4; bKeyword = true; goto identifier; }

break;
case 'X':
if (c1 == 'o' && c2 == 'r' && (p + 3 == len || (p + 3 < len && (isWhitespace(s, p + 3, len) || isSeparator(s, p + 3, len))))){ v = "Xor"; l = 2; bKeyword = true; goto identifier; }

break;
case 'u':
if (c1 == 'i' && c2 == 'C' && p + 3 < len && s.at(p + 3) == 'l' && p + 4 < len && s.at(p + 4) == 'a' && p + 5 < len && s.at(p + 5) == 's' && p + 6 < len && s.at(p + 6) == 's' && (p + 7 == len || (p + 7 < len && (isWhitespace(s, p + 7, len) || isSeparator(s, p + 7, len))))){ v = "uiClass"; l = 6; bKeyword = true; goto identifier; }

break;
}
}


if (!c0.isLetter()){
switch(c0.toLatin1()){
case '!':
{ v = "!"; l = 0; goto identifier; }

break;
case '#':
{ v = "#"; l = 0; goto identifier; }

break;
case '$':
{ v = "$"; l = 0; goto identifier; }

break;
case '&':
{ if (c1 != 'H' || !c2.isDigit() || !(c2 == 'A' || c2 == 'B' || c2 == 'C' || c2 == 'D' || c2 == 'E' || c2 == 'F' || c2 == 'a' || c2 == 'b' || c2 == 'c' || c2 == 'd' || c2 == 'e' || c2 == 'f')){ l = 0; v = "&"; goto identifier; } } 

break;
case '\'':
{ nComment = p + 1; nComment2 = p; while(nComment2 + 1 < len && s.at(nComment2) != '\n') nComment2++;  bComment = true; if (s.at(nComment2) == '\n'){ nComment2--; } l = 0; goto identifier; } 

break;
case '(':
{ v = "("; l = 0; goto identifier; }

break;
case ')':
{ v = ")"; l = 0; goto identifier; }

break;
case '*':
if ((c1 == '*')){ v = "**"; l = 1; goto identifier; }

{ v = "*"; l = 0; goto identifier; }

break;
case '+':
{ if (!bNumberE || bNumberEDone){
  if (!bIdentifier && !bNumberEDone && tokens.size() > 0 && (tokens.last() == "K|" || tokens.last() == "K^" || tokens.last() == "K\\" || tokens.last() == "KXor" || tokens.last() == "KShr" || tokens.last() == "KShl" || tokens.last() == "KOrElse" || tokens.last() == "KOr" || tokens.last() == "KMod" || tokens.last() == "KAndAlso" || tokens.last() == "KAnd" || tokens.last() == "K>=" || tokens.last() == "K>" || tokens.last() == "K===" || tokens.last() == "K==" || tokens.last() == "K=" || tokens.last() == "K=" || tokens.last() == "K<=" || tokens.last() == "K<" || tokens.last() == "K/" || tokens.last() == "K-" || tokens.last() == "K+" || tokens.last() == "K*" || tokens.last() == "K&" || tokens.last() == "K#")){ 
    bNumber = true; nNumber = p; continue; } 
  v = "+"; l = 0; goto identifier; } } 

break;
case ',':
{ v = ","; l = 0; goto identifier; }

break;
case '\\':
{ v = "\\"; l = 0; goto identifier; }

break;
case '-':
{ if (!bNumberE || bNumberEDone){
    if (!bIdentifier && !bNumberEDone && !isWhitespace(s, p + 1, 1) && tokens.size() > 0 && (tokens.last() == "K|" || tokens.last() == "K^" || tokens.last() == "K\\" || tokens.last() == "KXor" || tokens.last() == "KShr" || tokens.last() == "KShl" || tokens.last() == "KOrElse" || tokens.last() == "KOr" || tokens.last() == "KMod" || tokens.last() == "KAndAlso" || tokens.last() == "KAnd" || tokens.last() == "K>=" || tokens.last() == "K>" || tokens.last() == "K===" || tokens.last() == "K==" || tokens.last() == "K=" || tokens.last() == "K=" || tokens.last() == "K<=" || tokens.last() == "K<" || tokens.last() == "K/" || tokens.last() == "K-" || tokens.last() == "K+" || tokens.last() == "K*" || tokens.last() == "K&" || tokens.last() == "K#")){


     
      bNumber = true;
      nNumber = p;
      continue;
    }
    v = "-"; l = 0; goto identifier;
  }
} 

break;
case '.':
{ int pp = p; while(p + 1 < len && s.at(++p).isSpace()); if (s.at(p).isDigit() || s.at(p) == '+' || s.at(p) == '-'){ p = pp; } else { p = pp; l = 0; v = "."; goto identifier; } } //  v = "."; l = 0; goto identifier; }

break;
case '/':
{ v = "/"; l = 0; goto identifier; }

break;
case ':':
{
  if (c1 == ':'){
    bDotDot = true;
    continue;
  }
  if (c1 == '='){
    p++;
    v = ":="; l = 0; goto identifier;
  }
  if (bDotDot){
    bDotDot = false;
    continue;
  }
  v = ":"; l = 0; goto identifier;
}

break;
case ';':
{ v = ";"; l = 0; goto identifier; }

break;

case '<':
if ((c1 == 's' && c2 == 't' && p + 3 < len && s.at(p + 3) == 'r' && p + 4 < len && s.at(p + 4) == 'i' && p + 5 < len && s.at(p + 5) == 'n' && p + 6 < len && s.at(p + 6) == 'g' && p + 7 < len && s.at(p + 7) == '>')){ bString22 = true; l = 7; goto identifier; }

if ((c1 == '>')){ v = "<>"; l = 1; goto identifier; }

if ((c1 == '=')){ v = "<="; l = 1; goto identifier; }

if ((c1 == '/' && c2 == 's' && p + 3 < len && s.at(p + 3) == 't' && p + 4 < len && s.at(p + 4) == 'r' && p + 5 < len && s.at(p + 5) == 'i' && p + 6 < len && s.at(p + 6) == 'n' && p + 7 < len && s.at(p + 7) == 'g' && p + 8 < len && s.at(p + 8) == '>')){ bString22 = true; l = 8; goto identifier; }

{
    QString sTestForTemplateType;
    if (nIdentifier >= 0){
     sTestForTemplateType = s.mid(nIdentifier, p - nIdentifier);
    }
    if (Parser::isTemplateType(sTestForTemplateType)){
      QChar cq;
      if (!(++p < len && (s.at(p).isLetter() || s.at(p).isSpace()))){
        Parser::Me.nLine = s.left(p).count("\n") + 1;
        Parser::error("template data type error: " + s.mid(nString, p - nString));
        return tokens;
      }
      while (++p < len){
        cq = s.at(p);
        if (cq == '>'){
          p++;
          break;
        }
        if (!cq.isLetterOrNumber() && !cq.isSpace()){
          Parser::Me.nLine = s.left(p).count("\n") + 1;
          Parser::error("template data type not closed (watch for < >): " + s.mid(nString, p - nString));
          return tokens;
        }
      }
      bIdentifier = true;
      bTemplate = true;
      { v = ""; l = 0; goto identifier; }
    }
  }
{ v = "<"; l = 0; goto identifier; }
  break;
  

case '=':
if ((c1 == '=' && c2 == '=')){ v = "==="; l = 2; goto identifier; }

if ((c1 == '=')){ v = "=="; l = 1; goto identifier; }

{ v = "="; l = 0; goto identifier; }

{ v = "="; l = 0; goto identifier; }

break;
case '>':
if ((c1 == '=')){ v = ">="; l = 1; goto identifier; }

{ v = ">"; l = 0; goto identifier; }

break;
case '[':
{ v = "["; l = 0; goto identifier; }

break;
case '{':
{ v = "{"; l = 0; goto identifier; }

break;
case '\"':
{ bString11 = true; l = 0; goto identifier; }

break;
case '\n':
{
  if (bString1){
    Parser::Me.nLine = s.left(p).count("\n") + 1;
    Parser::error("string literal not closed (watch for escape codes): " + s.mid(nString, p - nString));

    nString = -1; return tokens; }
  if (bIdentifier || bNumber){ bNewLine = true; l = 0; v = "\n"; goto identifier; } nCurrentLine++;
    tokens.append("K\n"); continue;

}


break;
case ']':
{ v = "]"; l = 0; goto identifier; }

break;
case '}':
{ v = "}"; l = 0; goto identifier; }

break;

case '^':
{ v = "^"; l = 0; goto identifier; }

break;
case '_':
{ if (!bString1 && !bString2 && !bIdentifier){ int pp = p; while(p + 1 < len && isWhitespace(s, ++p, len)); if (s.at(p) == '\''){ while(p + 1 < len && s.at(++p) != '\n'); } if (s.at(p) == '\n'){ p++; nCurrentLine++; tokens.append("K_"); continue; } else { p = pp; } } } //  v = "_"; l = 0; goto identifier; }

break;
case '|':
{ v = "|"; l = 0; goto identifier; }

break;
}
}


if (!bNumber){
if (!bIdentifier && (c0 == '_' || c0.isLetter())){ bIdentifier = true; nIdentifier = p; continue; }
else if (bIdentifier && (c0 == '_' || c0.isLetter() || c0.isDigit())){ continue; }
else if (!bNumberPlusMinus1 && (c0 == '+' || c0 == '-')){ bNumber = true; bNumberPlusMinus1 = true; nNumber = p; continue; }
else if (bNumberDot && !bNumberPlusMinus2 && (c0 == '+' || c0 == '-')){ bNumber = true; bNumberPlusMinus2 = true; nNumber = p; continue; }
else if (c0 == '.'){ bNumber = true; bNumberDot = true; nNumber = p; continue; }
else if (!bNumberX && c0 == '&' && c1 == 'H'){ bNumber = true; bNumberX = true; nNumber = p; p++; continue; }
}
else if (bNumber){
if (c0 == 'D' || c0 == 'F' || c0 == 'd' || c0 == 'f'){ p++; goto identifier; }
else if (!bNumberX && (c0 == 'x' || c0 == 'X') && p - nNumber == 1 && s.at(p - 1) == '0'){ bNumberX = true; continue; }
else if (!bNumberDot && !bNumberX && c0 == '.'){ bNumberDot = true; continue; }
else if (!bNumberE && !bNumberX && (c0 == 'e' || c0 == 'E')){ bNumberE = true; continue; }
else if (bNumberE && (s.at(p - 1) == 'e' || s.at(p - 1) == 'E') && (c0 == '+' || c0 == '-')){ continue; }
else if (bNumberX && (c0 == 'A' || c0 == 'B' || c0 == 'C' || c0 == 'D' || c0 == 'E' || c0 == 'F' || c0 == 'a' || c0 == 'b' || c0 == 'c' || c0 == 'd' || c0 == 'e' || c0 == 'f')){ continue; }
}
if (c0.isDigit()){ if (!bNumber){ nNumber = p; bNumber = true; bNumberEDone = false; } if (bNumberE) bNumberEDone = true; continue; }
else {
  Parser::Me.nLine = s.left(p).count("\n") + 1; Parser::error(QString("scanner error: forbidden character") + c0); return tokens;
}
continue;
identifier:
 if (bKeyword && v == "Next"){
   if (c00 == '.'){
     nIdentifier = p;
     p += v.length() - 1;
     bKeyword = false;
     tokens.append("I" + s.mid(nIdentifier, p - nIdentifier + 1));
     v = "";
     l = 0;
   }
 }

 if (bIdentifier){ 
   QString qewr = s.mid(nIdentifier, p - nIdentifier);
   if (bTemplate){ bTemplate = false; qewr = qewr.replace("<", "").replace(">", ""); }
   tokens.append("I" + qewr); nIdentifier = -1; bIdentifier = false;  
 }
 else if (bNumber){ bNumber = false; bNumberPlusMinus1 = false; bNumberPlusMinus2 = false; bNumberX = false; bNumberDot = false; bNumberE = false; bNumberEDone = false; tokens.append("N" + s.mid(nNumber, p - nNumber)); nNumber = -1; }
 if (bComment){ bComment = false; tokens.append("C" + s.mid(nComment, nComment2 - nComment + 1)); p = nComment2; nComment2 = -1; nComment = -1; l = 0; }
 else if (bString11){ if (bString1){ tokens.append("S" + s.mid(nString, p - nString)); nString = -1; } else { nString = p + 1; } bString1 = !bString1; bString11 = false; }
 else if (bString22){ if (bString2){ int nCR = s.mid(nString, p - nString).count("\n"); tokens.append("S" + s.mid(nString, p - nString).replace("\n", "\\n")); for (int m = 0; m < nCR; m++){ tokens.append("K<string>"); } nString = -1; nStringLine = -1; } else { nStringLine = nCurrentLine; nString = p + l + 1; } bString2 = !bString2; bString22 = false; }


 if (!v.isEmpty()){ tokens.append("K" + v); v = ""; bKeyword = false; }
 if (l > 0){ p += l; l = 0; } if (bNewLine){ bNewLine = false; nCurrentLine++; }
}
if (bString2){
  Parser::Me.nLine = s.left(p).count("\n") + 1; Parser::error(QString("</string> missing start from line %1").arg(nStringLine));
  return tokens; }
if (!v.isEmpty() || bIdentifier || bNumber) goto identifier;



tokens.append("K\n");
return tokens;

}






